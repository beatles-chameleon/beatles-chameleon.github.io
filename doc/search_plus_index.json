{"./":{"url":"./","title":"介绍","keywords":"","body":" Chameleon Chameleon/kəˈmiːlɪən/，简写CML，中文名卡梅龙；中文意思变色龙，意味着就像变色龙一样能适应不同环境的跨端整体解决方案。 English Introduction | 中文介绍 文档 主站: CMLJS.org 安装 快速上手 API文档 组件文档 资源汇总&#x1F4B0;：依赖库、demo、完整应用示例、学习资源 后续规划 CML 即 多端 一端所见即多端所见——多端高度一致，无需关注各端文档。 基于多态协议不影响各端差异化灵活性 web 微信小程序 native-weex 百度小程序 支付宝小程序 背景 研发同学在端内既追求h5的灵活性，也要追求性能趋近于原生。 面对入口扩张，主端、独立端、微信小程序、支付宝小程序、百度小程序、Android厂商联盟快应用，单一功能在各平台都要重复实现，开发和维护成本成倍增加。迫切需要维护一套代码可以构建多入口的解决方案，滴滴跨端解决方案Chameleon终于发布。真正专注于让一套代码运行多端。 设计理念 软件架构设计里面最基础的概念“拆分”和“合并”，拆分的意义是“分而治之”，将复杂问题拆分成单一问题解决，比如后端业务系统的”微服务化“设计；“合并”的意义是将同样的业务需求抽象收敛到一块，达成高效率高质量的目的，例如后端业务系统中的“中台服务”设计。 而 Chameleon 属于后者，通过定义统一的语言框架+统一多态协议，从多端（对应多个独立服务）业务中抽离出自成体系、连续性强、可维护强的“前端中台服务”。 跨端目标 虽然不同各端环境千变万化，但万变不离其宗的是 MVVM 架构思想，Chameleon 目标是让MVVM跨端环境大统一。 开发语言 从事过网页编程的人知道，网页编程采用的是HTML + CSS + JS这样的组合，同样道理，chameleon中采用的是 CML + CMSS + JS。 JS语法用于处理页面的逻辑层，与普通网页编程相比，本项目目标定义标准MVVM框架，拥有完整的生命周期，watch，computed，数据双向绑定等优秀的特性，能够快速提高开发速度、降低维护成本。 CML（Chameleon Markup Language）用于描述页面的结构，我们知道HTML是有一套标准的语义化标签，例如文本是 按钮是。CML同样具有一套标准的标签，我们将标签定义为组件，CML为用户提供了一系列组件。同时CML中还支持模板语法，例如条件渲染、列表渲染，数据绑定等等。同时，CML支持使用类VUE语法，让你更快入手。 CMSS(Chameleon Style Sheets)用于描述CML页面结构的样式语言，其具有大部分CSS的特性，并且还可以支持各种css的预处语言less stylus。 通过以上对于开发语言的介绍，相信你看到只要是有过网页编程知识的人都可以快速的上手chameleon的开发。 多端高度一致 深入到编程语言维度保障一致性，包括框架、生命周期、内置组件、事件通信、路由、界面布局、界面单位、组件作用域、组件通信等高度统一 丰富的组件 在用CML写页面时，chameleon提供了丰富的组件供开发者使用，内置的有button switch radio checkbox等组件，扩展的有c-picker c-dialog c-loading等等,覆盖了开发工作中常用的组件。 丰富的API 为了方便开发者的高效开发，chameleon提供了丰富的API库,发布为npm包chameleon-api，里面包括了网络请求、数据存储、地理位置、系统信息、动画等方法。 自由定制API和组件 基于强大的多态协议，可自由扩展任意API和组件，不强依赖框架的更新。各端原始项目中已积累大量组件，也能直接引入到跨端项目中使用。 基于强大的多态协议，充分隔离各端差异化实现，轻松维护一套代码实现跨多端 智能规范校验 代码规范校验，当出现不符合规范要求的代码时，编辑器会展示智能提示，不用挨个调试各端代码，同时命令行启动窗口也会提示代码的错误位置。 渐进式跨端 既想一套代码运行多端，又不用大刀阔斧的重构项目？不仅可以用cml开发页面，也可以将多端重用组件用cml开发，直接在原有项目里面调用。 先进前端开发体验 Chameleon 不仅仅是跨端解决方案。基于优秀的前端打包工具Webpack，吸收了业内多年来积累的最有用的工程化设计，提供了前端基础开发脚手架命令工具，帮助端开发者从开发、联调、测试、上线等全流程高效的完成业务开发。 联系我们 ChameleonCore@didiglobal.com Beatles Chameleon 团队 负责人：Conan 内部成员：透心凉、Sgoddon、动机不纯、Jalon、Jack、卡尺哈哈、change、Observer、Kevin、guoqingSmile、Mr.MY、JiM、lzc、名字待定 贡献者： luyixin、期待你加入 微信 & QQ交流群 微信 QQ "},"quick_start/quick_start.html":{"url":"quick_start/quick_start.html","title":"快速上手","keywords":"","body":"快速上手(Quick start) 视频教程 1 安装启动 [success] 运行环境 node >= 8.10.0 npm >= 5.6.0 建议安装使用nvm管理 node 版本 1.1 全局安装 chameleon-tool 构建工具 npm i -g chameleon-tool 注：暂不支持使用 yarn、cnpm 等第三方 npm 工具进行安装。 安装成功后，执行 cml -v 即可查看当前版本， cml -h查看命令行帮助文档。 1.2 创建项目与启动 执行 cml init project 输入项目名称 等待自动执行 npm install 依赖 切换到项目根目录执行cml dev 会自动打开预览界面 预览界面如下： web 端可以点击模拟器内页面右上角打开 \b 新的浏览器窗口。 native 端的效果请 \b 下载chameleon playground(目前可下载 Android 端，IOS 端即将发布)或者下载weex playground扫码预览 小程序端请下载对应小程序开发工具，打开项目根目录下的/dist/[wx|alipay|baidu]目录预览。 微信开发者工具、 支付宝开发者工具、 百度开发者工具 2 目录与文件结构 生成的目录结构如下，详细介绍参见目录结构： ├── chameleon.config.js // 项目的配置文件 ├── dist // 打包产出目录 ├── alipay // 支付宝小程序代码 ├── baidu // 百度小程序代码 ├── wx // 微信小程序代码 ├── mock // 模拟数据目录 ├── node_modules // npm包依赖 ├── package.json └── src // 项目源代码 ├── app // app启动入口 ├── components // 组件文件夹 ├── pages // 页面文件夹 ├── router.config.json // 路由配置 └── store // 全局状态管理 \b 编辑器中语法高亮，暂时使用.vue的插件，参见编辑器插件，后续会推出更强大的插件。 3 编辑器插件 Idea、Webstorm 插件cml-language-support Vscode 插件cml Atom 插件language-cml sublime 插件审核中，敬请期待... 4 语法体验 替换src/pages/index/index.cml文件，删除src/pages/index/index.cml文件中的所有代码，然后替换为下面的代码，体验 chameleon 语法。 数据绑定 {{ message }} {{ message2 }} {{idx}}: {{itemName.city}} 切换展示 class Index { data = { message: \"Hello Chameleon!\", array: [ { city: \"北京\" }, { city: \"上海\" }, { city: \"广州\" } ], showlist: true }; computed = { message2: function() { return \"computed\" + this.message; } }; watch = { showlist(newVal, oldVal) { console.log(`showlist changed:` + newVal); } }; methods = { changeShow() { this.showlist = !this.showlist; } }; created() { console.log(\"生命周期\"); } } export default new Index(); .class1 { color: #f00; } { } 5 创建新页面 项目根目录下 \b 执行 \bcml init page, 输入页面名称 first-page $ cml init page ? Please input page name: 回车，即可生成页面 \b 组件src/pages/first-page/first-page.cml。 6 创建及引用组件 项目根目录下 \b 执行 \bcml init component，选择Normal component,输入 first-com，\b 回车，即可生成文件components/first-com/first-com.cml。 组件也是 cml 文件 \b 结构上与页面相同。 拷贝如下代码到first-com.cml 我是组件first-com class FirstCom {} export default new FirstCom(); .first-com-text { color: #0f0; } { } 然后在刚才的src/pages/index/index.cml中引用first-com { \"base\": { \"usingComponents\": { \"first-com\": \"components/first-com/first-com\" } } } template 中使用 first-com 组件。 经过以上操作，你已经学会了组件的引用，丰富的组件等待着你去学习! 进阶 \b 体验 7 项目配置 chameleon.config.js为项目的配置文件，以后定制化构建会 \b 使用到，比如是否带 hash，是否 \b 压缩等等,可以在项目根目录下执行cml build \b，\b 执行完成后 \b，项目根目录的dist文件夹下生成 build 模式的文件。 8 模拟 \b 数据 mock/api/index.js文件内容如下，可以本地模拟 api 请求。访问localhost:8000/api/getMessage\b 即可看到模拟的 api 返回。端口以实际启动为准，默认 8000. module.exports = [ { method: [\"get\", \"post\"], path: \"/api/getMessage\", controller: function(req, res, next) { res.json({ total: 0, message: [ { name: \"Hello chameleon!\" } ] }); } } ]; 9 \b 示例 demo 学习 \bchameleon-tool中内置了 todolist 的项目模板，\b 通过命令cml init project --demo todo 即可生成该模板，按照 1.2 节中的说明启动项目，即可看到如下页面 经过以上的介绍和实践操作，相信你已经了解了 chameleon 的基本使用，本文档其余部分将涵盖剩余功能和其他高级功能的详尽细节，所以请务必完整阅读整个文档！ 10 FAQ 我想使用chameleon，是否需要大刀阔斧的重构项目？ 不需要，可以使用chameleon开发公用组件，导出到各端原有项目中使用。 用CML标准编写代码，是否增加调试成本？ 我们实现了全面的语法检查功能，且在持续加强。理论上框架是降低调试成本，就像从原生js开发到vuejs、reactjs是否认为也增加了调试成本，见仁见智。 各端包括小程序的接口更新频繁，如何保证框架编译的抽象度和稳定性？ 1、自建输入语法标准 cml，编译输出结果自定的格式语法。 2、框架的runtime层实现匹配接收的编译输出代码，runtime跟随小程序更新。 3、框架整体方向一致：mvvm底层设计模式为标准设计接口。 基于以上三条，你可以理解为：我们设计了一个框架统一标准协议，再在各个端runtime分别实现这个框架，宏观的角度就像nodejs同时运行在window和macOS系统，就像flutter运行在Android和iOS一个道理。各端小程序接口更新除非遇到不向下兼容情况，否则不影响框架，如果真遇到不向下兼容更新，这种情况下是否用框架都需要改。 框架有多大，性能是否有影响？ 1、小程序的主要运行性能瓶颈是webview和js虚拟机的传输性能，我们在这里会做优化，尽可能diff出修改的部分进行传输，性能会更好。 2、包大小，小程序有包大小限制，web端包大小也是工程师关心的点。首先基于多态协议，产出包纯净保留单端代码；其次框架的api和组件会按需打包。包大小是我们重点发力点，会持续优化到极致。目前build模式包大小测试结果如下: minimize | minimize + gzip 平台js总体积外部框架chameleon运行时代码其他代码 web 141.87kb | 43.72kb vue+vuex+vue-router 99.26kb | 33.89kb 35.96kb | 8.85kb 业务代码 weex 135kb | 32.43kb vuex+vue-router 33.49kb | 17.96kb 25.23kb | 5.94kb 业务代码 wx 101.66kb | 28.12kb mobx算在chameleon运行时中 98.75kb | 26.53kb 业务代码 baidu 101.72kb | 28.13kb mobx算在chameleon运行时中 98.78kb | 26.61kb 业务代码 alipay 102kb | 28.12kb mobx算在chameleon运行时中 99.15kb | 26.34kb 业务代码 我只想跨web和各类小程序，是否可以不使用 Flexbox 布局模型？ 可以，如果你的项目不在 快应用、react-native、weex等平台运行，可以更便捷开发项目，特别是CSS的限制更少： 只跨web和小程序的应用 "},"example/guide.html":{"url":"example/guide.html","title":"cml 迁移指南","keywords":"","body":"cml 迁移指南(CML Migrate Guide) cml 作为真正让一套代码运行多端的框架，提供标准的 MVVM 模式，统一开发各类终端。 同时，拥有各端独立的 运行时框架(runtime)、数据管理(store)、组件库(ui)、接口(api)。 此外，cml在跨端能力加强、能力统一、表现一致等方面做了许多工作。 今天，为了让大家的项目优雅升级，快速接入，给你带来一份丰盛的cml 迁移指南~ 目录结构 和微信小程序一样，cml 包含一个描述整体程序的 app 和多个描述各自页面的 page。 小程序目录结构 . ├── components // 包含各个组件 ├── pages // 包含各个页面 ├── app.js // 包含各个组件 ├── app.js // 应用启动入口 ├── app.json // 全局配置 ├── app.wxss // 全局样式 └── project.config.json // 项目配置文件 cml 目录结构 . ├── dist // 各个端构建结果 │ ├── alipay │ ├── baidu │ ├── wx │ ├── web │ ├── weex │ └── config.json // 跨端配置map映射表 ├── node_modules // 第三方库 ├── mock // 模拟 接口数据 和 模板数据 ├── src // 源代码开发目录 │ ├── app // 应用启动入口 │ ├── assets // 静态资源 │ ├── components // 包含组件 │ ├── pages // 包含页面 │ ├── store //数据管理 │ └── router.config.json // 路由配置文件 ├── chameleon.config.js // 项目配置文件 └── package.json // npm包配置文件 如何修改配置 在小程序项目里面，分为： 小程序 —— 项目配置 可以在项目根目录使用 project.config.json 文件对项目进行配置。 配置示例： { \"miniprogramRoot\": \"./src\", \"debugOptions\": {} } 小程序 —— 全局配置 小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等 配置示例： { \"pages\": [\"pages/index/index\", \"pages/logs/index\"], \"window\": { \"navigationBarTitleText\": \"Demo\" }, \"networkTimeout\": { \"request\": 10000, \"downloadFile\": 10000 } } 小程序 —— 页面配置 每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。 页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 配置示例： { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"微信接口功能演示\", \"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\" } 同样，在 cml项目里面，分为： cml —— 项目配置 chameleon.config.js 为项目的配置文件，你可以定制化构建，比如是否带 hash，是否 \b 压缩等等。 配置示例： // 设置静态资源的线上路径 const publicPath = \"//www.static.chameleon.com/static\"; // 设置api请求前缀 const apiPrefix = \"https://api.chameleon.com\"; // 合并配置 cml.config.merge({ wx: { build: { apiPrefix } }, alipay: { build: { apiPrefix } }, baidu: { build: { apiPrefix } }, web: { dev: { hot: true, console: true }, build: { publicPath: `${publicPath}/web`, apiPrefix } }, weex: { build: { publicPath: `${publicPath}/weex`, apiPrefix } } }); cml —— 全局配置 cml 项目 app 目录下的 app.cml 文件的 用来对 cml应用 进行全局配置，具有 跨端配置 和 差异化 的能力 配置示例： { \"base\": { \"window\": { \"navigationBarTitleText\": \"各个端共同title\", }, \"permission\": { \"scope.userLocation\": { \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\" } } }, \"wx\": { \"window\": { \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"差异化 title\", \"navigationBarTextStyle\":\"black\" } }, \"baidu\": { \"window\": { \"backgroundTextStyle\": \"light\" } }, \"alipay\": { \"window\": { \"defaultTitle\": \"Chameleon\" } } } cml —— 页面/组件配置 通过 usingComponents 配置 组件路径 注册引用的组件。 配置示例： { \"base\": { \"usingComponents\": { \"navi\": \"/components/navi/navi\", \"navi-npm\": \"cml-test-ui/navi/navi\" } }, \"wx\": { }, \"alipay\": { }, \"baidu\": { }, \"web\": { }, \"weex\": { } } 如何使用路由能力 小程序配置路由 app.json 配置项列表的 pages 字段用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径+文件名 信息。 数组的第一项代表小程序的初始页面（首页）。新增/减少页面，需要对 pages 数组进行修改。 如果项目有 pages/index/index.wxml、pages/logs/logs.wxml 两个页面，则需要在 app.json 中写 { \"pages\": [\"pages/index/index\", \"pages/logs/logs\"] } cml 配置路由 src/router.config.json 是路由的配置文件，cml 内置了一套各端统一的路由管理方式。相应有 cml 路由配置映射如下： { \"mode\": \"history\", \"domain\": \"https://www.chameleon.com\", \"routes\":[ { \"url\": \"/cml/h5/index\", \"path\": \"/pages/index/index\", \"mock\": \"index.php\" }, { \"url\": \"/cml/h5/logs\", \"path\": \"pages/logs/logs\", \"mock\": \"logs.php\" } ] } 文件名不需要写文件后缀，cml框架会自动去寻找对于位置的 .cml 文件进行处理。 小程序使用路由 打开新页面：调用 API wx.navigateTo 页面重定向：调用 API wx.redirectTo 页面返回：调用 API wx.navigateBack 打开另一个小程序：调用 API wx.navigateToMiniProgram 返回到上一个小程序：调用 API wx.navigateBackMiniProgram cml 使用路由 依据统一资源索引 URI，自适应打开不同环境同一路由 PATH： 打开新页面：调用 chameleon-api cml.navigateTo 页面重定向：调用 chameleon-api cml.redirectTo 页面返回：调用 chameleon-api cml.navigateBack 打开另一个跨端应用：调用 chameleon-api cml.open 返回到上一个跨端应用：调用 chameleon-api cml.close 如何注册 如何注册程序 小程序注册程序 在小程序项目里面，App() 函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。 示例代码 App({ onLaunch(options) { // Do something initial when launch. }, globalData: \"I am global data\" }); cml 注册程序 示例代码 import store from \"../store/index.js\"; import routerConfig from \"../router.config.json\"; class App { data = { store, routerConfig }; created(res) {} } export default new App(); 细心的你会发现， 小程序中app.json app.js app.wxss和 src/app/app.cml的对应关系如下 小程序 app.js cml 项目 src/app/app.cml app.js app.wxss app.json 如何注册页面 小程序注册页面 在小程序项目里面，Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。 示例代码： // index.js Page({ data: { text: \"This is page data.\" }, changeText: function(e) { // sent data change to view this.setData({ text: \"CML\" }); } }); cml 注册页面 示例代码 class Index { data = { text: \"Chameleon\" }; methods = { changeText: function(e) { // sent data change to view this.text = \"CML\"; } }; computed = {}; watch = {}; } export default new Index(); 如何注册组件 小程序注册组件 在小程序项目里面， Component(Object) 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。 示例代码 Component({ properties: { myProperty: { // 属性名 type: String, // 类型（必填） value: \"\" // 属性初始值（可选） }, myProperty2: String // 简化的定义方式 }, data: { text: \"\" }, // 私有数据，可用于模板渲染 // 生命周期函数，可以为函数，或一个在methods段中定义的方法名 attached() {}, ready() {}, methods: { onMyButtonTap() { this.setData({ // 更新属性和数据的方法与更新页面数据的方法类似 text: \"wx\" }); } } }); cml 注册组件 示例代码 class MyComponent { props = { myProperty: { // 属性名 type: String, // 类型（必填） default: \"\" // 属性初始值（可选） }, myProperty2: String // 简化的定义方式 }; data = { text: \"\" }; // 私有数据，可用于模板渲染 beforeMount() {} mounted() {} methods = { onMyButtonTap() { this.text = \"cml\"; } }; computed = {}; watch = {}; } export default new MyComponent(); 如何声明生命周期 统一各端应用生命周期的定义，是跨端框架的重要组成，也是迁移的必经之路。 小程序声明生命周期 可以在 App(Object)、Page(Object)、Component(Object) 传入Object参数，其指定小程序的生命周期回调等 代码示例 // index.js Page({ onLoad(options) { // Do some initialize when page load. }, onReady() { // Do something when page ready. }, onShow() { // Do something when page show. }, onHide() { // Do something when page hide. }, onUnload() { // Do something when page close. }, onShareAppMessage() { // return custom share data when user share. } }); cml 声明生命周期 在.cml 文件 代码块返回的对象实例，其指定生命周期回调 示例代码 class Index { beforeCreate(query) { // data数据挂载到this根节点上之前，以及methods所有方法挂载到实例根节点之前 // 注意：只用页面的 beforeCreate钩子 会返回页面query console.log(\"App beforeCreate: 打开当前页面路径中的参数是 \", query); } created() { // data,methods里面的这些events挂载完成 console.log(\"App created\"); } beforeMount() { // 开始挂载已经编译完成的cml到对应的节点时 console.log(\"App beforeMount\"); } mounted() { // cml模板编译完成,且渲染到dom中完成,在整个生命周期中只执行一次 console.log(\"App mounted\"); } beforeDestroy() { // 实例销毁前 console.log(\"App beforeDestroy\"); } destroyed() { // 实例销毁后 console.log(\"App destroyed\"); } } export default new Index(); App 生命周期 映射 小程序 app.js中的生命周期 -> cml src/app/app.cml 小程序 chameleon onLaunch beforeCreate onShow mounted onHide destroyed Page 生命周期 映射 小程序 Page()中的生命周期 -> cml src/pages/mypage/mypage.cml 小程序 chameleon onLoad beforeCreate onShow mounted onUnload destroyed onReady 生命周期多态 onHide 生命周期多态 onShareAppMessage 生命周期多态 Component 生命周期 映射 小程序 Component()中的生命周期 -> cml src/components/mycomponent/mycomponent.cml 小程序 chameleon created created attached beforeMount ready mounted detached destroyed 生命周期总结 每个 cml 实例(App、Page、Component)在被创建时都要经过一系列的初始化过程 ———— 例如，需要设置数据监听、编译模板、将实例挂载到 \bCML节点 并在数据变化时更新 \bCML节点 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给开发者在不同阶段添加自己的代码的机会。 cml 为App、页面Page、组件Component 提供了一系列生命周期事件，保障应用有序执行。 另外，如果你想使用某个端特定的生命周期，你可以从业务出发使用 生命周期多态。 数据如何响应到视图 如今，双向数据绑定&单向数据流 已深入开发者日常，MVMM 开发模式算是框架标配。 数据绑定、条件渲染、列表渲染 是如何书写的呢？ 示例代码 小程序使用数据响应 {{message}} WEBVIEW APP MINA {{item}} // page.js Page({ data: { message: \"Hello MINA!\", view: \"MINA\", array: [1, 2, 3, 4, 5] }, onLoad() { this.setData({ message: \"wx\" }); } }); cml 使用数据响应 {{message}} WEBVIEW APP MINA {{item}} class Index { data = { message: \"Hello MINA!\", view: \"MINA\", array: [1, 2, 3, 4, 5] }; beforeCreate() { this.message = \"cml\"; } } export default new Index(); 数据响应总结 cml运行时框架 提供了跨端响应式数据绑定系统(Data binding)，当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。 只需要将 viewmodel 交互部分逻辑，作简单迁移，便可使它成为跨多端的数据响应系统。 事件交互 cml 支持一些基础的事件，保障各端效果(类型、绑定、事件对象)一致运行。 示例代码 小程序使用事件 Click me! // page.js Page({ tapName(event) { console.log(event); } }); cml 使用事件 Click me! class Index { methods = { tapName(e) { // 打印事件对象 console.log(\"事件对象:\", e); } }; } export default new Index(); 事件使用总结 同时，还支持自定义事件，用于父子组件之间的通信。 另外，如果你想要使用某个端特定的事件，cml 并不会限制你的自由发挥，你可以从业务出发使用 组件多态 或者 接口多态 差异化实现功能。 布局和外观 各端描述 布局和外观 的层叠样式表(CSS)实现存在差异，包括不限于 布局、盒模型、定位、文本。 所以， cml 框架内置跨端一致性基础样式能力。 并且，定义了用于描述页面的样式规范CMSS(Chameleon Style Sheet)。 如何导入外部样式 使用 @import 语句可以导入外联样式表，@import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。 小程序导入外部样式 示例代码： /** common.wxss **/ .small-p { padding: 5px; } /** app.wxss **/ @import \"common.wxss\"; .middle-p { padding: 15px; } cml 导入外部样式 详细文档 示例代码： /** common.css **/ .small-p { padding: 5px; } @import \"./common.css\"; .middle-p { padding: 15 cpx; } 样式使用总结 同时，为了统一多端尺寸单位，呈现效果一致，同时页面响应式布局，cml 项目统一采用 cpx 作为尺寸单位，规定以屏幕 750px（占满屏幕）视觉稿作为标准。 而且，各端样式表拥有的能力 不尽相同，是项目迁移的主要阵地之一。 另外，如果你想要使用某个端特定的样式能力，cml 并不会限制你的自由发挥，你可以从业务出发使用 样式多态 注意：由于 chameleon 应用是 跨多端web native 小程序框架，如果需要跨native，必须使用 flexbox 进行样式布局！！！ 组件 cml 项目一切皆组件。组件(Component)是视图的基本组成单元。 框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。 如： view 基础组件 text 基础组件 同时，cml 支持简洁的组件化编程。 自定义组件 开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用。自定义组件在使用时与基础组件非常相似。 如何创建自定义组件 小程序创建自定义组件 代码示例： Component({ properties: { // 这里定义了innerText属性，属性值可以在组件使用时指定 innerText: { type: String, value: \"default value\" } }, data: { // 这里是一些组件内部数据 someData: {} }, methods: { // 这里是一个自定义方法 customMethod() {} } }); cml 创建自定义组件 示例代码 class MyComponent { props = { // 这里定义了innerText属性，属性值可以在组件使用时指定 innerText: { type: String, value: \"default value\" } }; data = { // 这里是一些组件内部数据 someData: {} }; methods = { // 这里是一个自定义方法 customMethod() {} }; computed = {}; watch = {}; } export default new MyComponent(); 如何使用自定义组件 使用已注册的自定义组件前，首先要进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。 小程序使用自定义组件 代码示例： 在 page.json 中进行引用声明 { \"usingComponents\": { \"component-tag-name\": \"path/to/the/custom/component\" } } 在 page.wxml 中使用 cml 使用自定义组件 代码示例： 在 page.cml中进行引用声明 { \"base\": { \"usingComponents\": { \"component-tag-name\": \"path/to/the/custom/component\" } } } 在 page.cml中使用 如何实现父子组件事件通信 事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。 小程序组件通信 代码示例： // 页面 page.js Page({ methods: { onMyEvent(e) { console.log(e.detail); // 自定义组件触发事件时提供的detail对象 } } }); 点击这个按钮将触发“myevent”事件 // 组件 my-component.js Component({ methods: { onTap() { this.triggerEvent(\"customevent\", {}); // 触发 自定义组件事件 } } }); cml 组件通信 代码示例： class Index { methods = { // 这里是一个自定义方法 onMyEvent(e) { console.log(e.detail); // 自定义组件触发事件时提供的detail对象 } }; } export default new Index(); { \"base\": { \"usingComponents\": { \"my-component\": \"path/to/the/custom/component\" } } } 点击这个按钮将触发“myevent”事件 class MyComponent { methods = { // 这里是一个自定义方法 onTap() { this.$cmlEmit(\"customevent\", {}); // 触发 自定义组件事件 } }; } export default new MyComponent(); { } 组件使用总结 和小程序一样，cml框架 提供了大量内置组件和扩展组件，抹平多端差异，便于开发者通过组合这些组件，创建出强大的应用程序。 扩展组件需要额外引入。如： { \"base\": { \"usingComponents\": { \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\" } } } 在执行 cml build 构建打包时，cml 框架 会按需打包引用的内置组件和扩展组件，为代码瘦身。 内置组件和扩展组件 都是支持跨多端的，对于一些没有提供的某个端的组件，可以通过组件多态来实现。 如果希望使用小程序端的原生组件，那么可以在原生标签前加上 origin-*，cml框架会渲染原生组件参考 注意：origin-* 只能在灰度区文件中使用！！ 如在 map.wx.cml 文件中使用原生地图组件 ： 如何调用平台接口能力 在小程序里面，可以通过微信原生 API，调起如获取用户信息，本地存储，支付功能等。 示例代码 try { wx.setStorageSync(\"name\", \"Hanks\"); } catch (e) { console.error(e); } 同样，在 cml 项目里面可以这样调用： 示例代码 import cml from \"chameleon-api\"; cml.setStorage(\"name\", \"Hanks\").then( res => { console.log(res); }, function(e) { console.error(e); } ); 接口使用总结 cml 框架提供了丰富的多态接口，可以调起各端提供的原生能力，如系统信息、元素节点信息、动画效果、本地存储、网络请求、地理位置等。请参考 API 文档。 chameleon-api提供的接口都是支持跨多端的，对于一些没有提供的某个端的原生接口，可以通过接口多态来调用。 迁移总结 CML 作为一端代码运行多端的框架，所有接口设计都考虑的是具备跨端要求的设计，没有使用任何一端的接口设计规范，而是全新一套框架，所以不要”想当然“用微信小程序或者 vue 的接口来开发 CML。 例如，如果你是微信小程序开发者，当你想使用 tabbar 功能时，可能会在app.json 里面配置，这是错误的，这是微信特有模式，只在微信里面有效。在 cml 中请使用 c-tabbar 来实现，这样所有端都有效。 迁移实例 下面给出各端(vue、weex、小程序)迁移cml指南 以及 cml 导出组件到各端指南的具体迁移文档： 如何迁移一个 Vue 项目到 chameleon 如何迁移一个 Weex 项目到 chameleon 如何迁移一个微信小程序到 chameleon 普通项目使用 chameleon 跨端 dialog 组件 "},"example/wx_to_chameleon.html":{"url":"example/wx_to_chameleon.html","title":"微信小程序项目迁移 chameleon 指引","keywords":"","body":"如何迁移一个微信小程序到chameleon 1 迁移原则： 以小逻辑块为单位，对照老代码，以cml语法重写，报错可修正 这样可避免以下问题： 1、大块逻辑迁移会导致报错无法追查 2、直接copy会导致语法隐藏bug不可控（虽然ide没有问题，但真机调试出问题） 请尽量按照cml语法重写迁移，避免语法纠错浪费时间 1.1 小程序多文件结构 -> cml单文件页面 小程序 chameleon xxx.wxml xxx.js xxx.wxss xxx.json 2 项目初始化 cml init project 初始化后，cml项目如下： 依具体情况 配置构建平台 和 配置平台基础样式 可修改 chameleon.config.js 的 platforms 和 baseStyle 字段，如下： 假设有下面&#x1F447;结构的小程序项目 pages下包含各个页面，components下包含各个组件代码 3 迁移 app.js、app.json 小程序代码配置 微信应用的配置 app.json { \"pages\":[ \"pages/index1\", \"pages/index2\", \"pages/index3\", \"pages/index4\", ], \"window\":{ \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" } } 3.1.0 迁移 app.json ———— 路由pages配置 以上小程序 app.json 中 pages 字段 -> src/router.config.json 中 path 字段 { \"mode\": \"history\", \"domain\": \"https://www.chameleon.com\", \"routes\":[ { \"url\": \"/cml/h5/index\", \"path\": \"/pages/index1/index1\", \"name\": \"首页\", \"mock\": \"index.php\" }, { \"url\": \"/cml/h5/inner-detail\", \"path\": \"/pages/index2/index2\", \"name\": \"首页\", \"mock\": \"index.php\" }, { \"url\": \"/cml/h5/inner-home\", \"path\": \"/pages/index3/index3\", \"name\": \"首页\", \"mock\": \"index.php\" }, { \"url\": \"/cml/h5/inner-my\", \"path\": \"/pages/index4/index4\", \"name\": \"首页\", \"mock\": \"index.php\" } ] } 3.1.1 迁移 app.json ———— 其他配置 小程序 app.json 中 其他字段 -> src/app/app.cml 中配置 { \"wx\": { \"window\": { \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"Chameleon\", \"navigationBarTextStyle\":\"black\" } } } 3.2 迁移 app.js ———— 生命周期映射 小程序 app.js中的生命周期 -> src/app/app.cml 小程序 chameleon onLaunch beforeCreate onShow mounted onHide destroyed 总结 小程序中app.json app.js app.wxss和 src/app/app.cml的对应关系如下 小程序 app.js cml项目 src/app/app.cml app.js app.wxss app.json 4 迁移页面 4.1 新建页面 如上所述，小程序 app.json 中 pages 每个字段，对应router.config.json中每条路由项，对应cml项目的每个页面 cml init page 输入 index1 cml init page 输入 index2 ... 利用脚手架命令，在src/pages中生成对应的页面 4.2 迁移页面配置 假设小程序原有页面 index1.json 配置如下 { \"usingComponents\": { \"my-component1\": \"/components/comp1\", \"my-component2\": \"/components/comp2\", \"my-component3\": \"/components/comp3\", }, \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } 修改src/pages/index1.cml 页面配置，如下： { \"base\": { \"usingComponents\": { \"my-component1\": \"/components/comp1\", \"my-component2\": \"/components/comp2\", \"my-component3\": \"/components/comp3\", } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } 其中： base 代表各个小程序页面的共有配置 wx 代表微信小程序端特有的配置 4.3 迁移页面 ———— 生命周期映射 小程序 chameleon onLoad beforeCreate onShow mounted onUnload destroyed onReady 生命周期多态 onHide 生命周期多态 onShareAppMessage 生命周期多态 总结 1 小程序页面的迁移都要通过 cml init page去初始化这个页面 2 初始化的页面要在src/router.config.json配置对应的path字段 5 迁移组件 5.1 新建组件 如上，index1.json页面中引用了组件 comp1 comp2 comp3; 组件分为：普通组件 和 多态组件 这里以普通组件为例，多态组件具体使用可以参考 cml init component 选择 普通组件(normal-component) 输入 comp1 cml init component 选择 普通组件(normal-component) 输入 comp2 ..... 之后，会在 src/components下生成对应的组件; 5.2 迁移组件 ———— 配置 同4.2 迁移页面配置 5.3 迁移组件 ———— 生命周期映射 小程序 chameleon created created attached beforeMount ready mounted detached destroyed 总结 1 小程序组件的迁移都要通过 cml init component去初始化这个组件 2 初始化的组件要在使用该组件的地方配置 usingComponents字段 6 页面&&组件迁移细节 6.1 template模板迁移 这里以cml语法为例：cml基础语法 6.1.1 数据绑定、条件渲染、循环、事件绑定的迁移 假设，原有小程序代码，如下： 数据绑定 {{}} 条件渲染 wx:if wx:elif wx:else 循环 事件绑定 Click me! 那么，使用 cml语法后： 数据绑定 {{}} 条件渲染 c-if c-else-if c-else 循环 事件绑定 Click me! chameleon语法扩展了事件绑定，支持直接在函数中传参 Click me! 6.1.2 小程序内置组件 -> cml内置组件 小程序 chameleon view view text text block block scroll-view scroller list list swiper carousel button button input input textarea textarea switch switch radio radio checkbox checkbox image image video video 注意： 小程序和cml的内置组件传参是不一样的 具体cml内置组件使用方式参考 6.1.3 小程序原生组件的迁移 对于原生组件，需要在多态组件中调用，并且，需要找到其他端类似的组件。 小程序 chameleon xxx.web.cml 可以再这里调用vue第三方库的组件 xxx.wx.cml 可以在这里调用微信第三方组件库或者微信的原生组件（origin-） xxx.weex.cml 可以在这里调用weex第三方组件库 具体使用 参考-多态组件 如果希望使用小程序端的原生组件，那么可以在原生标签前加上 origin-，cml框架会渲染原生组件参考 如果想要用微信小程序的第三方组件库，参考:手把手教你系列-实现多态 echarts 假设，原有小程序代码，如下： {{item}} 那么，使用cml语法后： {{item}} 6.1.4 模板上需要替换的语法汇总 小程序 chameleon wx:if c-if wx:elif c-else-if wx:else c-else wx:for c-for wx:for-index c-for-index wx:for-item c-for-item wx:key c-key bindtap c-bind:tap catchtap c-catch:tap 6.1.5 chameleon对于语法的扩展支持 指令的扩展 c-show、c-model、c-show 参考 component is 动态组件的扩展 参考 事件绑定支持内联事件传参数 参考 总结 1 对于小程序的语法，比如wx:if wx:for等要替换成cml对应的语法 c-if c-for 2 对于小程序的事件绑定，要转化成cml的c-bind c-catch的形式，cml扩展了支持事件传参 6.2 JS内容迁移 6.2.1 数据的迁移 参考 其中需要注意点 小程序中的 properties 对应于 cml中的 props 小程序 properties: { innerText: { type: String, value: 'default value', } }, cml项目 props = { innerText: { type: String, default: 'default value', } } 6.2.2 微信小程序API的迁移 假设，原有小程序代码，如下： wx.redirectTo({ url: 'test?id=1' }) 那么，使用cml语法后： import cml from 'chameleon-api' cml.redirectTo({ path: '/pages/navigateBack/index', query: { id:1 } }) 小程序的API文档 chameleon-api的文档 这里对于API小程序的API和chameleon的API的文档中对应细则做个简单的表格，如下 微信小程序API chameleon-api wx.canIUse canIUse 系统信息 系统信息 计时器 计时器 路由 路由 交互 交互 设置页面title 设置页面title 动画 动画 网络 网络 数据缓存 数据缓存 获取图片信息 获取图片信息 位置 位置 以上 chameleon-api提供的接口都是支持跨多端的，对于一些没有提供的跨多端的接口，而你的项目中又是必须用到的情况下，可以通过接口多态来实现 参考 6.2.3 小程序事件的迁移 注意，自定义组件的事件的触发机制，映射如下： 小程序 chameleon this.triggerEvent(xxx,xxx) this.$cmlEmit(xxx,xxx) 事件对象参数 chameleon对web native wx各个端的事件对象进行了统一代理 参考； 对于灰度区组件(多态组件) 各个端的事件对象还是对应端的事件对象，chameleon框架不会对灰度区origin-开头的标签和第三方组件 标签上绑定的事件进行事件代理 6.2.4 模块化的迁移 小程序的模块化-参考 cml的模块化 假如 模块文件 m1.js module.exports = { info:\"I am chameleon\" } xxx.cml 引用了 m1.js import cml from 'chameleon-api' //node_modules中的模块 console.log('cml',cml) const m1 = require('path/to/m1.js') console.log('m1',m1.info) // I am chameleon 总结 1 小程序JS层用到的全局变量wx要通过chameleon-api去替换成对应的,如果没有对应的API，需要通过多态接口去实现 2 小程序中的properties data对应于cml项目 props ,data 3 小程序中的除了生命周期之外的事件都对应在 cml项目中的methods 4 chameleon提供了chameleon-store参考,可以用来存储一些全局的变量 5 小程序触发视图更新的setData不能再使用，chameleon自带了一套响应式的数据视图绑定 6 模块化中引用的模块要保证多端的适用性，参考 chameleon-api 6.3 style内容的迁移 6.3.1 页面布局的迁移 由于chameleon应用是 跨多端web native 小程序框架，如果需要跨native，必须使用 flexbox进行样式布局，其他场景可以参考只跨web和小程序的应用 关于样式的使用教程 参考 模板上的样式语法 参考,基本和微信小程序是相同的； 6.3.2 样式单位的迁移 如果样式想要适配多端，需要将单位改成cpx; 假设，原有小程序代码，如下： .demo-com { display: flex; flex-direction: column; align-items: center; height:400rpx; justify-content: center; } .title { align-self: center; color: #61c7fc; font-size: 72rpx; margin-top: 160rpx; margin-bottom: 20rpx; } .logo { width: 150rpx; height: 150rpx; margin-top: 100rpx; } 那么，使用cml语法后： .demo-com { display: flex; flex-direction: column; align-items: center; height:400cpx; justify-content: center; } .title { align-self: center; color: #61c7fc; font-size: 72cpx; margin-top: 160cpx; margin-bottom: 20cpx; } .logo { width: 150cpx; height: 150cpx; margin-top: 100cpx; } 以上，简单的介绍了微信小程序迁移到chameleon的简单步骤，如果还有任何疑问，欢迎随时在chameleon官方微信和官方QQ群里进行反馈，我们将随时解答你的困惑，再次感谢你对chameleon的支持~ ​ Best wishes ​ Chameleon 团队 "},"example/web_to_chameleon.html":{"url":"example/web_to_chameleon.html","title":"web 项目迁移 chameleon 指引","keywords":"","body":"如何迁移一个Vue项目到chameleon 1 迁移原则： 以小逻辑块为单位，对照老代码，以cml语法重写，报错可修正 这样可避免以下问题： 1、大块逻辑迁移会导致报错无法追查 2、直接copy会导致语法隐藏bug不可控（虽然ide没有问题，但真机调试出问题） 请尽量按照cml语法或者类vue语法重写迁移，避免语法纠错浪费时间 2 项目初始化 cml init project 初始化后，cml项目如下： 依具体情况 配置构建平台 和 配置平台基础样式 可修改 chameleon.config.js 的 platforms 和 baseStyle 字段，如下： 假设有下面&#x1F447;结构的vue项目（vue-cli 2版本生成的） components下包含各个组件代码，router下是路由配置，store是数据管理中心，config和build下是vue项目的webpack构建的基本配置 接下来就一步步展示如何将这个项目迁移到chameleon 3 工程层面的迁移 3.1 迁移 —— webpack配置 chameleon的工程配置具体参考 chameleon脚手架工具，提供了 dev build两种构建模式，可以对应到 vue 项目中的dev build vue项目 cml项目 npm run dev cml dev npm run build cml build chameleon内置了对于webpack和项目的构建，参考这里修改chameleon内置webpack构建 3.2 迁移 —— store chameleon中的store使用参考 cml项目中的store和 vue 项目中的store文件下是对应的； 假设vue项目中某个组件 import {mapState} from 'vuex'; export default { computed: mapState(['count']) } 那么在cml项目中 import store from '../path/to/store'; class Index { computed = store.mapState(['count']) } export default new Index(); 3.3 迁移 —— router 1 router-view出口的的对应关系 假设vue项目中入口文件 src/App.vue 那么对应着cml项目中的src/app/app.cml,这里的会渲染成对应的某个路由； 2 路由配置对应关系 vue项目中的路由 src/router/index.js import Vue from 'vue' import Router from 'vue-router' import HelloWorld from '@/components/HelloWorld' Vue.use(Router) export default new Router({ routes: [ { path: '/helloworld', name: 'HelloWorld', component: HelloWorld } ] }) 对于router.js中配置的一级路由，需要通过 cml init page 去生成对应的组件 cml项目中 src/router.config.json { \"mode\": \"history\", \"domain\": \"https://www.chameleon.com\", \"routes\":[ { \"url\": \"/helloworld\", \"path\": \"/pages/HelloWorld/HelloWorld\", \"name\": \"helloworld\", \"mock\": \"index.php\" } ] } 其中： url字段 对应vue中的path字段； path字段对应着 vue中 import Comp from '/path/to/Comp'中的组件路径 chameleon会自动引入component字段配置的组件,不需要再配置component字段； 总结 1 注意cml项目中不支持路由嵌套,如果有路由嵌套的情况需要考虑转化成组件去实现 2 在迁移路由的时候，要一个一个路由对应着去迁移 3 vue项目中的一级路由的组件都通过 cml init page去初始化这个组件 4 迁移页面/组件 假如 vue 项目中 src/components/HelloWorld.vue组件内有个子组件 comp; 首先我们修改下这两个组件，使其有一些简单的新增todolist的功能 HelloWorld.vue this is helloworld import lodash from 'lodash' import comp from './comp.vue'; export default { name: 'HelloWorld', data () { return { } }, methods:{ handleParentClick(...args){ console.log('parentClick',...args) } }, components:{ comp } } .demo-com { display: flex; flex-direction: column; align-items: center; height:400px; justify-content: center; } .title { align-self: center; color: #61c7fc; font-size: 72px; margin-bottom: 20px; } comp.vue {{item}} addTodo 触发父组件事件 export default { name: 'HelloWorld', data () { return { todo:'todo1', todos:[], } }, methods:{ addTodo(){ this.todos.push(this.todo) }, handleClick(){ console.log('click'); this.$emit('parentClick',{ value:1, }) } } } 4.1 新建页面/组件 cml init page 输入 HelloWorld 利用脚手架命令，在src/pages中生成对应的页面 Hello Chameleon! class HelloWorld { //... } export default new HelloWorld(); { \"base\": { \"usingComponents\": {} }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" }, \"alipay\": { \"defaultTitle\": \"index\", \"pullRefresh\": false, \"allowsBounceVertical\": \"YES\", \"titleBarColor\": \"#ffffff\" }, \"baidu\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"index\", \"backgroundColor\": \"#ffffff\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": false, \"onReachBottomDistance\": 50 } } cml init component 选择 Normal component 输入 comp 利用脚手架命令，在src/components中生成对应的组件 Hello Chameleon! class Comp { //... } export default new Comp(); { \"base\": { \"usingComponents\": {} } } 4.2 迁移组件引用 假设vue项目src/components/HelloWorld.vue中引用了其他组件 import comp from './comp.vue'; 对应到cml项目 组件需要在 usingComponents 引用，不需要在配置 components字段 修改src/pages/HelloWorld/HelloWorld.cml 页面配置，如下： { \"base\": { \"usingComponents\": { \"comp\":\"/components/comp/comp\" } } } 总结 1 router.js中对应的组件需要通过 cml init page生成，然后在 router.config.js中配置对应路由 2 组件内部引用的子组件要通过cml init component 生成 ，然后通过usingComponents字段去引用 3 组件内引用的其他js库，比如import lodash from 'lodash'仍然通过import的形式引用 5 页面&&组件迁移细节 5.1 template模板迁移 这里以cml的vue 语法为例：cml类vue基础语法 5.1.1 数据绑定、条件渲染、循环、事件绑定的迁移 假设，原有vue项目代码，如下： 数据绑定 {{}} 条件渲染 v-if v-else-if v-else 循环 事件绑定 Click me! 那么，使用 cml的类vue语法后：整体基本上不用变,只需要将标签改成cml的内置标签即可参考 注意需要声明 数据绑定 {{}} 条件渲染 v-if v-else-if v-else 循环 事件绑定 Click me! 5.1.2 vue项目标签 -> cml标签 vue项目 cml div view text span text img image input input 组件 button button 组件 textarea textarea 组件 switch switch 组件 radio radio 组件 checkbox checkbox 组件 image image 组件 video video 组件 没有列出来的标签比如head p main等等只能在多态组件中使用，不支持跨多端 对于 a标签的 href,如果想要达到跨多端的效果，需要通过绑定事件使用 chameleon-api去跳转。 5.1.3 chameleon对于语法的扩展支持 指令的扩展 c-show、c-model、c-show 参考 component is 动态组件的扩展 参考 事件绑定支持内联事件传参数 参考 5.1.4 迁移注意点 cml支持的类vue语法 ,只有在文档中列出的语法才支持多端，其他没有列出的语法仅可以在web端使用，跨端没有支持，比如 v-htm class的对象语法 数组语法等 根据以上教程，我们可以迁移HelloWorld.vue和comp.vue中的模板内容了 HelloWorld.cml this is helloworld comp.cml {{item}} addTodo 触发父组件事件 5.2 JS内容迁移 5.2.1 生命周期迁移 ：和vue保持一致 5.2.2 数据的迁移 参考 5.2.3 vue项目API的迁移 API迁移包括 http请求 路由跳转 本地存储等 参考：chameleon-api的文档 假设，原有vue项目代码，如下： router.push({ path: '/pages/navigateBack/index' }) 跨多端的路由仅支持 传入path字段进行路由，不支持路由 name字段的路由 那么，使用cml语法后： import cml from 'chameleon-api' cml.redirectTo({ path: '/pages/navigateBack/index', }) 5.2.4 事件的触发机制，映射如下： vue项目 cml this.$emit(xxx,xxx) this.$cmlEmit(xxx,xxx) 事件对象参数 chameleon对web native wx各个端的事件对象进行了统一代理 参考； 对于灰度区组件(多态组件) 各个端的事件对象还是对应端的事件对象，chameleon框架不会对灰度区origin-开头的标签和第三方组件 标签上绑定的事件进行事件代理 事件冒泡 chameleon生成的weex项目默认都是开启了支持事件冒泡的机制 同时扩展了阻止事件冒泡的语法； vue语法(仅仅支持 .stop) cml语法 总结 1 由于chameleon是跨多端框架，所以在web端特有的全局变量，比如 window document history location等在chameleon中是不支持的 2 对于vue的一些全局API比如Vue.extend Vue.set以及一些文档中没有列出的指令，比如v-html v-pre等都是不支持跨多端的 根据以上教程，我们可以迁移HelloWorld.vue和comp.vue中的js内容了 HelloWorld.cml import lodash from 'lodash' class HelloWorld { methods = { handleParentClick(...args){ console.log('parentClick',...args) } } } export default new HelloWorld(); comp.cml class Comp { data = { todo:'todo1', todos:[] } methods = { addTodo(){ this.todos.push(this.todo) }, handleClick(){ this.$cmlEmit('parentClick',{ value:1 }) } } } export default new Comp(); 5.3 style内容的迁移 5.3.1 页面布局的迁移 由于chameleon应用是 跨多端web native 小程序框架，如果需要跨native，必须使用 flexbox进行样式布局，其他场景可以参考只跨web和小程序的应用 关于样式的使用教程 参考 模板上的样式语法 参考 5.3.2 样式单位的迁移 如果样式想要适配多端，需要将单位改成cpx; &#x1F449; 根据以上教程，我们可以迁移HelloWorld.vue和comp.vue中的js内容了 HelloWorld.cml .demo-com { display: flex; flex-direction: column; align-items: center; height:400cpx; justify-content: center; } .title { align-self: center; color: #61c7fc; font-size: 72cpx; margin-bottom: 20cpx; } 以上，简单的介绍了vue项目迁移到chameleon的步骤，如果还有任何疑问，欢迎随时在chameleon官方微信和官方QQ群里进行反馈，我们将随时解答你的困惑，再次感谢你对chameleon的支持~ ​ Best wishes ​ Chameleon 团队 "},"example/weex_to_chameleon.html":{"url":"example/weex_to_chameleon.html","title":"weex 项目迁移 chameleon 指引","keywords":"","body":"如何迁移一个Weex项目到chameleon 1 迁移原则： 以小逻辑块为单位，对照老代码，以cml语法重写，报错可修正 这样可避免以下问题： 1、大块逻辑迁移会导致报错无法追查 2、直接copy会导致语法隐藏bug不可控（虽然ide没有问题，但真机调试出问题） 请尽量按照cml语法或者类vue语法重写迁移，避免语法纠错浪费时间 2 项目初始化 cml init project 初始化后，cml项目如下： 依具体情况 配置构建平台 和 配置平台基础样式 可修改 chameleon.config.js 的 platforms 和 baseStyle 字段，如下： 假设有下面&#x1F447;结构的weex项目 weex-toolkit生成。 components下包含各个组件代码，router.js下是路由配置，config是weex项目的webpack构建的基本配置 3 工程层面的迁移 3.1 迁移 —— webpack配置 chameleon的工程配置具体参考 chameleon脚手架工具，提供了 dev build两种构建模式，可以对应到 weex 项目中的dev build weex项目 cml项目 npm run dev cml dev npm run build cml build chameleon内置了对于webpack和项目的构建，参考这里修改chameleon内置webpack构建 3.2 迁移 —— store weex使用vuex参考weex官网 chameleon中的store使用参考 cml项目中的store和 weex 项目中的store文件下是对应的； 假设vue项目中某个组件 import {mapState} from 'vuex'; export default { computed: mapState(['count']) } 那么在cml项目中 import store from '../path/to/store'; class Index { computed = store.mapState(['count']) } export default new Index(); 3.3 迁移 —— router 1 router-view出口的对应关系 假如weex项目中入口文件 src/index.vue 那么对应着cml项目中的src/app/app.cml,这里的会渲染成对应的某个路由； 2 路由配置的对应关系 weex项目中的路由 src/router.js import Vue from 'vue' import Router from 'vue-router' import HelloWorld from '@/components/HelloWorld' Vue.use(Router) export default new Router({ routes: [ { path: '/helloworld', name: 'HelloWorld', component: HelloWorld } ] }) cml项目中 src/router.config.json { \"mode\": \"history\", \"domain\": \"https://www.chameleon.com\", \"routes\":[ { \"url\": \"/helloworld\", \"path\": \"/pages/HelloWorld/HelloWorld\", \"name\": \"helloworld\", \"mock\": \"index.php\" } ] } 其中： url字段 对应vue中的path字段； path字段对应vue中 import Comp from '/path/to/Comp'中的组件路径 chameleon会自动引入component字段配置的组件,不需要再配置component字段； 总结 1 注意cml项目中不支持路由嵌套,如果有路由嵌套的情况需要考虑转化成组件去实现 2 在迁移路由的时候，要一个一个路由对应着去迁移 3 vue项目中的一级路由的组件都通过 cml init page去初始化这个组件 4 迁移页面/组件 假如 weex 项目中 src/components/HelloWorld.vue组件内有个子组件 comp; 首先我们修改下这两个组件，使其有一些简单的新增todolist的功能 HelloWorld.vue this is helloworld import lodash from 'lodash' import comp from './comp.vue'; export default { name: 'HelloWorld', data () { return { } }, methods:{ handleParentClick(...args){ console.log('parentClick',...args) } }, components:{ comp } } .demo-com { display: flex; flex-direction: column; align-items: center; height:400px; justify-content: center; } .title { align-self: center; color: #61c7fc; font-size: 72px; margin-bottom: 20px; } comp.vue {{item}} addTodo 触发父组件事件 export default { name: 'HelloWorld', data () { return { todo:'todo1', todos:[], } }, methods:{ addTodo(){ this.todos.push(this.todo) }, handleClick(){ console.log('click'); this.$emit('parentClick',{ value:1, }) } } } 4.1 新建页面/组件 cml init page 输入 HelloWorld 利用脚手架命令，在src/pages中生成对应的页面 Hello Chameleon! class HelloWorld { //... } export default new HelloWorld(); { \"base\": { \"usingComponents\": {} }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" }, \"alipay\": { \"defaultTitle\": \"index\", \"pullRefresh\": false, \"allowsBounceVertical\": \"YES\", \"titleBarColor\": \"#ffffff\" }, \"baidu\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"index\", \"backgroundColor\": \"#ffffff\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": false, \"onReachBottomDistance\": 50 } } cml init component 选择 Normal component 输入 comp 生成的组件如下 Hello Chameleon! class Comp { //... } export default new Comp(); { \"base\": { \"usingComponents\": {} } } 4.2 迁移组件引用 假设weex项目src/components/HelloWorld.vue中引用了其他组件 import comp from './comp.vue'; 对应到cml项目 组件需要在 usingComponents 引用，不需要在配置 components字段 修改src/pages/HelloWorld/HelloWorld.cml 页面配置，如下： { \"base\": { \"usingComponents\": { \"comp\":\"/components/comp/comp\" } } } 总结： 1 router.js中对应的组件需要通过 cml init page生成，然后在 router.config.js中配置对应路由 2 组件内部引用的子组件要通过cml init component生成，然后通过 usingComponents字段去引用 3 组件内引用的其他js库，比如import lodash from 'lodash'仍然通过import的形式引用 5 页面&&组件迁移细节 5.1 template模板迁移 这里以cml的vue 语法为例：cml类vue基础语法 5.1.1 数据绑定、条件渲染、循环、事件绑定的迁移 假设，原有vue项目代码，如下： 数据绑定 {{}} 条件渲染 v-if v-else-if v-else 循环 事件绑定 Click me! 那么，使用 cml的类vue语法后：整体基本上不用变,只需要将标签改成chameleon的内置标签即可参考 数据绑定 {{}} 条件渲染 v-if v-else-if v-else 循环 事件绑定 Click me! 5.1.2 chameleon对于语法的扩展支持 指令的扩展 c-show、c-model、c-show 参考 component is 动态组件的扩展 参考 事件绑定支持内联事件传参数 参考 5.1.3 weex的内置组件迁移 以下表格列出weex的内置组件迁移到cml项目中的对应情况，不能在视图层用 weex端特有的组件，需要通过以下标签进行替换 除非是通过多态组件调用的下层组件才可以使用。 chameleon提供的内置组件 chameleon提供的扩展组件 对于weex内置的组件，chameleon提供了大部分与之对应的可以跨端的组件，对应如下，具体使用方式请参考 weex内置组件 cml 备注 支持跨多端 支持跨多端 支持跨多端 支持跨多端 支持跨多端 支持跨多端 支持跨多端 对于轮播图组件，chameleon内置了carousel组件，如果想要用原生的slider,需要在多态组件中通过 origin-slider使用 支持跨多端 支持跨多端 支持跨多端 chameleon不支持的weex内置组件 weex内置组件 在chameleon中的替换方式 可以通过给一个 text标签绑定事件，通过 chameleon-api提供的接口打开页面 该组件不支持跨多端，仅可在多态组件中使用 该组件不支持跨端，仅可在多态组件中使用 该组件不支持跨端，仅可在多态组件中使用 根据以上教程，我们可以迁移HelloWorld.vue和comp.vue中的模板内容了 HelloWorld.cml this is helloworld comp.cml {{item}} addTodo 触发父组件事件 5.2 JS内容迁移 5.2.1 生命周期迁移 ：和vue保持一致 5.2.2 数据的迁移 参考 5.2.3 weex项目API的迁移 API迁移包括 http请求 路由跳转 本地存储等 参考：chameleon-api的文档 5.2.4 weex内置模块的迁移 不能在逻辑层用 weex端特有的内置模块，需要通过以下chameleon-api提供的进行替换 除非是通过多态组件调用的下层组件才可以直接使用。 weex cml 备注 animation chameleon-api中的 createAnimation 参考 cliboard chameleon-api中的 clipBoard 参考 dom chameleon-api中的 getRect 参考 globalEvent 暂不支持 meta chameleon-api中的 getSystemInfo 参考:可以通过这个API获取到视口的值然后给页面宽高赋值 modal chameleon-api中的showToast 参考 navigator chameleon-api中的 路由导航 参考 picker 扩展组件中的 c-picker 参考 storage chameleon-api中的数据存储 参考 stream chameleon-api中的网络请求 参考 webview 暂不支持 websockets chameleon-api中的websockets 参考 5.2.5 事件的触发机制，映射如下： vue项目 cml this.$emit(xxx,xxx) this.$cmlEmit(xxx,xxx) 事件对象参数 chameleon对web native wx各个端的事件对象进行了统一代理 参考； 对于灰度区组件(多态组件) 各个端的事件对象还是对应端的事件对象，chameleon框架不会对灰度区origin-开头的标签和第三方组件 标签上绑定的事件进行事件代理 cml支持的类vue语法 ,只有在文档中列出的语法才支持多端，其他没有列出的语法仅可以在web端使用，跨端没有支持，比如 v-htm class的对象语法 数组语法等 不支持的事件 longpress appear disappear 事件暂不支持； 事件冒泡 chameleon生成的weex项目默认都是开启了支持事件冒泡的机制 同时扩展了阻止事件冒泡的语法； vue语法(仅仅支持 .stop) cml语法 总结 1 由于chameleon是跨多端的框架，所以在weex端特有的环境变量，比如weex.config等在chameleon中是不支持的 2 对于weex的内置模块，比如animation等，在chameleon-api中基本上都有对应，参考上文weex内置模块的迁移 根据以上教程，我们可以迁移HelloWorld.vue和comp.vue中的js内容了 HelloWorld.cml this is helloworld import lodash from 'lodash' class HelloWorld { methods = { handleParentClick(...args){ console.log('parentClick',...args) } } } export default new HelloWorld(); comp.cml class Comp { data = { todo:'todo1', todos:[] } methods = { addTodo(){ this.todos.push(this.todo) }, handleClick(){ this.$cmlEmit('parentClick',{ value:1 }) } } } export default new Comp(); 5.3 style内容的迁移 weex样式官方文档 5.3.1 页面布局的迁移 使用 flexbox进行样式布局 关于样式的使用教程 参考 模板上的样式语法 参考 vue样式语法规范参考 5.3.2 样式单位的迁移 如果样式想要适配多端，需要将单位改成cpx; 根据以上教程，我们可以迁移HelloWorld.vue和comp.vue中的js内容了 HelloWorld.cml .demo-com { display: flex; flex-direction: column; align-items: center; height:400cpx; justify-content: center; } .title { align-self: center; color: #61c7fc; font-size: 72cpx; margin-bottom: 20cpx; } 以上，简单的介绍了weex项目迁移到chameleon的步骤，如果还有任何疑问，欢迎随时在chameleon官方微信和官方QQ群里进行反馈，我们将随时解答你的困惑，再次感谢你对chameleon的支持~ ​ Best wishes ​ Chameleon 团队 "},"framework/framework.html":{"url":"framework/framework.html","title":"框架","keywords":"","body":"框架(Framework) Chameleon 不仅仅是跨端解决方案，让开发者\b高效、低成本开发多端原生应用。基于优秀的前端打包工具Webpack，吸收了业内多年来积累的最有用的工程化设计，提供了前端基础开发脚手架命令工具，帮助端开发者从开发、联调、测试、上线等全流程高效的完成业务开发。 框架提供了自己的视图层描述语言 \bCML 和 CMSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。 脚手架工具 基于node开发的脚手架工具，提供简洁的命令，进行初始化与构建项目。 目录结构 \b提供规范化的项目结构，适合于企业级大型应用的开发，CML单文件组件的开发模式更有利于提高开发效率与优化文件组织结构。 视图层 视图层由 CML 与 CMSS 编写，chameleon的核心是一个标准\b响应式数据驱动视图更新的MVVM框架。 逻辑层 逻辑层由javascript编写，逻辑层将处理数据后自动更新视图，同时提供视图层的事件响应方法。 多态协议 提供了跨端时各端底层组件与接口统一的解决方案，使开发者可以自由扩展原生api与组件\b。 规范校验 为了提高开发的效率与代码的可维护性，chameleon提供了全面的代码规范与校验，\b帮助开发者能够得到更好的开发体验。 "},"quick_start/cml_cmd.html":{"url":"quick_start/cml_cmd.html","title":"脚手架工具","keywords":"","body":"脚手架工具(Scaffolding tools) chameleon-tool是chameleon的脚手架工具，请按照【快速上手】一节进行安装，该脚手架工具命令详细如下。 获取工具信息 cml -h 或cml --help 查看帮助信息 cml -v 或cml --version 查看chameleon-cli版本信息 初始化项目、页面、组件 cml init -h 查看init命令的帮助信息 cml init project 创建项目 cml init page 创建页面 cml init component 创建组件 cml init project 命令有如下参数 参数名可选值默认值功能 langcml|vuecml设置项目默认模板语法 tplhtml|smartyhtml设置chameleon.config.js中的templateType字段 demoblank|todoblank设置要初始化的项目模板 使用方式: cml init project --参数名 参数值 例如cml init project --lang vue --tpl html 开发/生产模式 cml dev 启动开发模式，默认启动所有\b端的构建，如果不启动某一端可以通过devOffPlatform配置 cml build 启动生产模式打包，默认启动所有\b端的构建，如果不启动某一端可以通过buildOffPlatform配置 web环境 cml web -h 查看web命令的帮助信息 cml web dev 执行web端开发模式构建 cml web build 执行web端打包模式构建 微信小程序环境 cml wx -h 查看wx命令的帮助信息 cml wx dev 执行微信端开发模式构建 也会构建web端，使api mock生效 cml wx build 执行微信端打包模式构建 支付宝小程序环境 cml alipay -h 查看alipay命令的帮助信息 cml alipay dev 执行支付宝端开发模式构建 也会构建web端，使api mock生效 cml alipay build 执行支付宝端打包模式构建 百度小程序环境 cml baidu -h 查看baidu命令的帮助信息 cml baidu dev 执行百度端开发模式构建 也会构建web端，使api mock生效 cml baidu build 执行百度端打包模式构建 weex环境 cml weex -h 查看weex命令的帮助信息 cml weex dev 执行weex端开发模式构建，也会构建web端，进行预览调试 cml weex build 执行weex端打包模式构建 在执行web、wx、alipay、baidu和weex构建命令时，会读取chameleon.config.js中的配置信息，具体配置参见【项目配置】一节。 "},"framework/structure.html":{"url":"framework/structure.html","title":"目录结构","keywords":"","body":"目录结构(Directory structure) 项目结构 使用cml init project 生成的项目结构如下： ├── chameleon.config.js // 项目的配置文件 ├── dist // 打包产出目录 ├── mock // 模拟数据目录 ├── node_modules // npm包依赖 ├── package.json └── src // 项目源代码 ├── app // app启动入口 ├── components // 组件文件夹 ├── pages // 页面文件夹 ├── router.config.json // 路由配置文件 └── store // 全局状态管理 文件夹和文件 文件 必须 作用 chameleon.config.js 必须 项目配置文件 dist 必须 自动生成，用户无需关注。项目编译目标目录 mock 必须 数据mock编写文件夹 node_modules 必须 自动生成，用户无需关注。npm包安装文件夹 package.json 必须 npm包配置文件 app 必须 应用启动入口根文件夹 components 必须 用户组件根文件夹 pages 必须 页面根文件夹 router.config.json 必须 路由配置文件 store 必须 数据管理文件夹 CML 文件 一个CML文件开发的组件由四块内容组成，分别是： 标签 必须 属性 作用 template 必须 lang:cml|vue 提供组件结构、事件绑定、数据绑定、样式绑定 script 必须 暂无 组件逻辑 style 必须 lang:less|stylus 组件样式表 json(使用script标签设置cml-type属性) 必须 cml-type:json 组件配置 "},"view/view.html":{"url":"view/view.html","title":"视图层","keywords":"","body":"视图层(View) 视图层由 CML 与 CMSS 编写，提供了“结构”（元素的组织构成）、“外观”（CSS）、“逻辑层的关联”（事件绑定）。 也就是将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。 如果说逻辑层是终端开发的“灵魂”，那么视图层是终端开发的“肉体”。 CMSS CMSS(Chameleon Style Sheet) 用于描述页面的样式。 CML-标准语法 CML(Chameleon Markup language) 用于描述页面的结构。 CML-类vue语法 为了降低学习成本，独立支持了vue的指令子集 CML-标准语法和CML-类vue语法严禁混用！ 基础组件 组件是组成视图的基本单位，chameleon为开发者提供了一系列的基础组件，可以更快地构建视图。 "},"view/cmss.html":{"url":"view/cmss.html","title":"CMSS","keywords":"","body":"CMSS CMSS(Chameleon Style Sheets)是一套样式语言，用于描述 CML 的组件样式。 使用 CMSS支持内联及类选择器等。 布局 采用 FlexBox 布局模型，请勿使用float方式布局。 盒模型 chameleon中盒模型box-sizing默认为border-box，即宽度包含内容、内边距盒边框。 文本 文本类组件及通用样式。 尺寸单位 为了统一多端尺寸单位，呈现效果一致，同时页面响应式，项目中统一采用cpx作为尺寸单位，规定以屏幕750px（占满屏幕）视觉稿作为标准。 禁止.cml中使用px，若要使用请使用多态协议。 颜色 基础颜色关键词及扩展颜色关键词。 样式多态 更加方便地为不同端定制样式。 一致性基础样式 统一各端基础样式，增强表现一致性。 只跨web和小程序的应用 受限于客户端的 CMSS 渲染能力，开发会有诸多限制。如果你只需要跨H5和小程序应用时，开发会变得很轻便。 "},"view/cmss/style_way.html":{"url":"view/cmss/style_way.html","title":"样式使用","keywords":"","body":"样式使用 普通写法 具体实现写在.cml的标签内。 目前支持有如下两种关联到元素上： 静态class 动态class 目前 class 不支持传入对象的形式； 简单数据绑定 {{}}之内的会被当做一个表达式去处理； class数据绑定 class Index { data () { return { prefix: 'cls' } } } export default new Index(); 三元运算符 或者将其放入计算属性 class Index { computed = { itemClass() { return open ? 'cls1 cls2' : 'cls3 cls4'; } } } export default new Index(); 内联写法 模版中写内联样式，分为静态和动态两种，静态样式指纯字符串，动态样式是有数据绑定。style也不支持对象语法和数组语法； 目前可以使用的方式如下： 静态样式： 动态样式： class Index { data = { inlineStyle: 'width: 200cpx;' } } export default new Index(); "},"view/cmss/layout.html":{"url":"view/cmss/layout.html","title":"布局","keywords":"","body":"布局 Flexbox chameleon 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 Flexbox 包含 flex 容器和 flex 成员项。如果一个 chameleon 元素可以容纳其他元素，那么它就成为 flex 容器。需要注意的是，flexbox 的老版规范相较新版有些出入，比如是否能支持 wrapping。这些都描述在 W3C 的工作草案中了，你需要注意下新老版本之间的不同。 Flex 容器 在 chameleon 中，Flexbox 是默认且唯一的布局模型，所以你不需要手动为元素添加 display: flex; 属性。 flex-direction： 定义了 flex 容器中 flex 成员项的排列方向。可选值为 row | column，默认值为 column column：从上到下排列。 row：从左到右排列。 justify-content： 定义了 flex 容器中 flex 成员项在主轴方向上如何排列以处理空白部分。可选值为 flex-start | flex-end | center | space-between，默认值为 flex-start。 flex-start：是默认值，所有的 flex 成员项都排列在容器的前部； flex-end：则意味着成员项排列在容器的后部； center：即中间对齐，成员项排列在容器中间、两边留白； space-between：表示两端对齐，空白均匀地填充到 flex 成员项之间。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items： 定义了 flex 容器中 flex 成员项在纵轴方向上如何排列以处理空白部分。可选值为 stretch | flex-start | center | flex-end，默认值为 stretch。 stretch： 是默认值，即拉伸高度至 flex 容器的大小； flex-start： 则是上对齐，所有的成员项排列在容器顶部； flex-end： 是下对齐，所有的成员项排列在容器底部； center： 是中间对齐，所有成员项都垂直地居中显示。 baseline： 项目的第一行文字的基线对齐。 flex-flow 说明: flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性, 用于设置或检索弹性盒模型对象的子元素排列方式。 flex-direction 属性规定灵活项目的方向。 flex-wrap 属性规定灵活项目是否拆行或拆列。 语法: flex-flow: flex-direction flex-wrap; Flex 成员项 flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的2倍。 flex {number}：值为 number 类型。 示例 一个简单的网格布局。 {{text}} class Index { data = { list: [ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ] } } export default new Index(); .item{ flex:1; justify-content: center; align-items:center; border-width:1; } .row{ flex-direction: row; height:80cpx; } { \"base\": {} } 定位 chameleon 支持 position 定位，用法与 CSS position 类似。为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标。 position {string}： 设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。 relative 是默认值，指的是相对定位； absolute 是绝对定位，以元素的容器作为参考系； fixed 保证元素在页面窗口中的对应位置显示； sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。 top {number}：距离上方的偏移量，默认为 0。 bottom {number}：距离下方的偏移量，默认为 0。 left {number}：距离左方的偏移量，默认为 0。 right {number}：距离右方的偏移量，默认为 0。 示例 class Index { } export default new Index(); .wrapper { position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; } .box { width: 400cpx; height: 400cpx; position: absolute; } .box1 { top: 0; left: 0; background-color: #ff0000; } .box2 { top: 150cpx; left: 150cpx; background-color: #0055dd; } .box3 { top: 300cpx; left: 300cpx; background-color: #00ff49; } { \"base\": {} } "},"view/cmss/box.html":{"url":"view/cmss/box.html","title":"盒模型","keywords":"","body":"盒模型 chameleon 盒模型基于 CSS 盒模型，每个 chameleon 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 width {length}：，默认值 0 height {length}：，默认值 0 padding {length}：内边距，内容和边框之间的距离。默认值 0 可有以下写法: - `padding-left {length}`：，默认值 0 - `padding-right {length}`：，默认值 0 - `padding-top {length}`：，默认值 0 - `padding-bottom {length}`：，默认值 0 支持简写模式：padding：{length length length length} margin： 外边距，元素和元素之间的空白距离。值类型为 length，默认值 0 可有如下写法： - `margin-left {length}`：，默认值 0 - `margin-right {length}`：，默认值 0 - `margin-top {length}`：，默认值 0 - `margin-bottom {length}`：，默认值 0 支持简写模式：margin:{length length length length} border： 设定边框，简写方式：border：1px solid #ff0000; 可有如下写法： - border-style： 设定边框样式，值类型为 string，可选值为 `solid | dashed | dotted`，默认值 solid 可有如下写法： - `border-left-style {string}`：可选值为 `solid | dashed | dotted`，默认值 solid - `border-top-style {string}`：可选值为 `solid | dashed | dotted`，默认值 solid - `border-right-style {string}`：可选值为 `solid | dashed | dotted`，默认值 solid - `border-bottom-style {string}`：可选值为 `solid | dashed | dotted`，默认值 solid - border-width {length}： 设定边框宽度，非负值, 默认值 0 可有如下写法： - `border-left-width {length}`：，非负值, 默认值 0 - `border-top-width {length}`：，非负值, 默认值 0 - `border-right-width {length}`：，非负值, 默认值 0 - `border-bottom-width {length}`：，非负值, 默认值 0 - border-color {color}： 设定边框颜色，默认值 `#000000` 可有如下写法： - `border-left-color {color}`：，默认值 #000000 - `border-top-color {color}`：，默认值 #000000 - `border-right-color {color}`：，默认值 #000000 - `border-bottom-color {color}`：，默认值 #000000 - border-radius {length}： 设定圆角，默认值 0 可有如下写法： - `border-bottom-left-radius {length}`：，非负值, 默认值 0 - `border-bottom-right-radius {length}`：，非负值, 默认值 0 - `border-top-left-radius {length}`：，非负值, 默认值 0 - `border-top-right-radius {length}`：，非负值, 默认值 0 注意 chameleon 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 目前在 组件上尚无法只定义一个或几个角的 border-radius。比如你无法在这两个组件上使用 border-top-left-radius。该约束只对 iOS 生效，Android 并不受此限制。 尽管 overflow:hidden 在 Android 上是默认行为，但只有下列条件都满足时，一个父 view 才会去 clip 它的子 view。这个限制只对 Android 生效，iOS 不受影响。 父view是div, a, cell, refresh 或 loading。 系统版本是 Android 4.3 或更高。 系统版本不是 Andorid 7.0。 父 view 没有 background-image 属性或系统版本是 Android 5.0 或更高。 示例： "},"view/cmss/text.html":{"url":"view/cmss/text.html","title":"文本","keywords":"","body":"文本样式 文本类组件共享一些通用样式, 这类组件目前包括 和。 属性 color {color}：文字颜色。 可选值为色值，支持 RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red）。 lines {number}: 指定文本行数。仅在 组件中支持。默认值是 0 代表不限制行数。 font-size {number}：文字大小。 font-style {string}：字体类别。可选值 normal | italic，默认为 normal。 font-weight {string}：字体粗细程度 可选值: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal 等同于 400, bold 等同于 700； 默认值: normal； iOS 支持 9 种 font-weight值；Android 仅支持 400 和 700, 其他值会设为 400 或 700 类似 lighter, bolder 这样的值暂时不支持 text-decoration {string}：字体装饰，可选值 none | underline | line-through，默认值为 none。 text-align {string}：对齐方式。可选值 left | center | right，默认值为 left。目前暂不支持 justify, justify-all。 font-family {string}：设置字体。 这个设置 不保证 在不同平台，设备间的一致性。如所选设置在平台上不可用，将会降级到平台默认字体。 text-overflow {string}：设置内容超长时的省略样式。可选值 clip | ellipsis 其他参考 颜色关键字列表 "},"view/cmss/unit.html":{"url":"view/cmss/unit.html","title":"单位","keywords":"","body":"单位 在chameleon项目中，我们使用cpx作为统一的长度单位。\bcpx可以根据\b\b屏幕宽度自适应，我们规定屏幕宽度为750cpx。你也可以在\b\b\b多态组件灰度层使用某一端的长度单位。 使用cpx设置元素宽度高度 使用cpx设置\b字体大小 Chameleon 使用cpx设置行高 Chameleon CSS color 单位 支持以下写法： .classA { /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray; } 注意 不支持 hsl(), hsla(), currentColor, 8个字符的十六进制颜色。 rgb(a,b,c) 或 rgba(a,b,c,d) 的性能比其他颜色格式差很多，请选择合适的颜色格式。 颜色名称可查看:颜色名称列表. CSS number 单位 仅仅一个数字。用于 opacity，lines等。 有时值必须是整数，例如：lines。 CSS percentage 单位 (暂不支持) 表示百分比值，如“50％”，“66.7％”等。 它是 CSS 标准的一部分，但 chameleon 暂不支持。 "},"view/cmss/color.html":{"url":"view/cmss/color.html","title":"颜色","keywords":"","body":"支持的颜色名称列表 基础颜色关键词： 颜色名 十六进制RGB值 black(黑) #000000 silver(银) #C0C0C0 gray(灰) #808080 white(白) #FFFFFF maroon(褐紫红) #800000 red(红) #FF0000 purple(紫) #800080 fuchsia(晚樱) #FF00FF green(绿) #008000 lime(石灰) #00FF00 olive(橄榄) #808000 yellow(黄) #FFFF00 navy(海军蓝) #000080 blue(蓝) #0000FF teal(水鸭) #008080 aqua(水蓝) #00FFFF 扩展颜色关键词： 颜色名 十六进制RGB值 aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32 "},"view/cmss/css_diff.html":{"url":"view/cmss/css_diff.html","title":"样式多态","keywords":"","body":"样式多态 cml文件中的style标签支持样式的多态，即可以针对不同的平台写不同的样式，格式如下： @media cml-type (支持的平台) { } .common { /**/ } 其中支持的平台为可以用逗号分隔多个平台，可选平台\b为web,weex,wx,alipay,baidu。\b demo示例，\bclass1在各端的差异实现。 chameleon class DemoPage { } export default new DemoPage(); @media cml-type (web) { .class1 { color: red; } } @media cml-type (weex) { .class1 { color: green; } } @media cml-type (wx,alipay,baidu) { .class1 { color: blue; } } {} 注意： 多态差异\b语法只能在cml文件中使用，不能在.css,.less等其他样式文件中使用，如果需要分文件实现，可以在多态内部分别引入文件。例如： @media cml-type (web) { @import \"./style1.less\"; } @media cml-type (weex) { @import \"./style2.less\"; } @media cml-type (wx,alipay,baidu) { @import \"./style3.less\"; } "},"view/cmss/base_style.html":{"url":"view/cmss/base_style.html","title":"一致性基础样式","keywords":"","body":"一致性基础样式 通常情况下，H5、小程序、客户端拥有各自的默认样式，各端呈现效果不一。所以，cml框架会给各端添加一致性基础样式。 基础样式包括以下方面： 类型 默认值 布局 display: flex; flex-direction: column; 盒模型 box-sizing: border-box; 定位 position: relative; 文本 display: block; font-size: 16px; white-space: pre-wrap; 针对H5端添加的基础样式如下 .cml-root { width: 100%; overflow-x: hidden; -webkit-tap-highlight-color: transparent; font-family: BlinkMacSystemFont, 'Source Sans Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif; } .cml-base { text-align: left; font-size: 0.4rem; /*15px*/ letter-spacing: 0.02rem; } .cml-base, .cml-base::before, .cml-base::after { box-sizing: border-box; text-size-adjust: none; } .cml-view { display: flex; box-sizing: border-box; position: relative; flex-direction: column; flex-shrink: 0; flex-grow: 0; flex-basis: auto; align-items: stretch; align-content: flex-start; border: 0 solid black; margin: 0; padding: 0; min-width: 0; } .cml-text { display: block; box-sizing: border-box; position: relative; white-space: pre-wrap; /* not using 'pre': support auto line feed. */ word-wrap: break-word; overflow: hidden; /* it'll be clipped if the height is not high enough. */ flex-shrink: 0; flex-grow: 0; flex-basis: auto; border: 0 solid black; margin: 0; padding: 0; min-width: 0; } 针对小程序添加的基础样式如下： .cml-base { text-align: left; font-size: 32rpx; letter-spacing: 1rpx; font-family: BlinkMacSystemFont, 'Source Sans Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif; } .cml-base, .cml-base::before, .cml-base::after { box-sizing: border-box; text-size-adjust: none; } .cml-view { display: flex; box-sizing: border-box; position: relative; flex-direction: column; flex-shrink: 0; flex-grow: 0; flex-basis: auto; align-items: stretch; align-content: flex-start; border: 0 solid black; margin: 0; padding: 0; min-width: 0; } .cml-text { display: block; box-sizing: border-box; position: relative; white-space: pre-wrap; /* not using 'pre': support auto line feed. 保留空白符序列，但是正常地进行换行 */ word-wrap: break-word; /* 在长单词或 URL 地址内部进行换行。 */ overflow: hidden; /* it'll be clipped if the height is not high enough. */ flex-shrink: 0; flex-grow: 0; flex-basis: auto; border: 0 solid black; margin: 0; padding: 0; min-width: 0; } 说明如下： class名 代表含义 .cml-root H5端 app 根节点 .cml-base 任一节点 .cml-view view元素 .cml-text text元素 "},"example/web_wx.html":{"url":"example/web_wx.html","title":"只跨 web 和小程序的应用","keywords":"","body":"只跨web和小程序的应用 背景介绍 通常情况下，cml框架会生成跨H5、小程序、客户端的应用。为了H5、小程序、客户端初始样式呈现效果一致，cml会添加一致性基础样式。在开发模式下，构建会严格校验CMSS语法，只允许书写跨H5、小程序、客户端都通用的 CMSS 规则。因此，受限于客户端的 CMSS 渲染能力，开发会有诸多限制，另一方面，当开发者只需要跨H5和小程序应用时，开发会变得很轻便。 通过下面的表格，展示 CMSS 跨端 能力差异： CSS属性 H5 小程序 weex 布局 all all flexbox 盒模型 all all 只支持display:border-box float浮动 ✅ ✅ ❌ display:inline-block|none ✅ ✅ ❌ ID选择器 ✅ ✅ ❌ 类选择器 ✅ ✅ ✅ 属性选择器 ✅ ✅ ❌ 级联选择器、派生选择器(后代、子元素、相邻兄弟) ✅ ✅ ❌ 选择器分组 ✅ ✅ ✅ 伪类(:active|:focus) ✅ ✅ ✅ 伪类(:hover|:link|:visited|:first-child|:lang) ✅ ✅ ❌ 伪元素(:first-letter|:first-line|:before|:after) ✅ ✅ ❌ 百分比定值 ✅ ✅ ❌ line-height:1 ✅ ✅ ❌ 尺寸 px|rem|em|vw|vh px|rpx px !important ✅ ✅ ❌ 项目初始化与配置 项目初始化 以merge config的方式修改项目根目录下的 chameleon.config.js，如下：cml.config.merge({ platforms: [\"web\",\"wx\",\"alipay\",\"baidu\"] }) CMSS 此时，CMSS 语法和可用属性，不再受限于客户端的渲染。CMSS 遵循 W3C 层叠样式表 (Cascading Style Sheets，缩写为 CSS）规范，在此基础上，小程序的标准样式会有一些限制。 一致性基础样式可选 如果你希望去除小程序、客户端的的一致性基础样式，修改项目根目录下的 chameleon.config.js，如下： cml.config.merge({ baseStyle: { wx: false, alipay: false, baidu: false, web: true, weex: false } }) "},"view/cml.html":{"url":"view/cml.html","title":"CML-标准语法","keywords":"","body":"CML-标准语法 CML（Chameleon Markup Language）用于描述页面的结构，我们知道HTML是有一套标准的语义化标签，例如\b文本是 \b按钮是。CML同样具有一套标准的标签，我们将标签定义为组件，CML为用户提供了一系列基础组件。同时CML中还支持模板语法，例如条件渲染、列表渲染，数据绑定等等。 基础组件 数据绑定 条件渲染 列表渲染 事件 指令 "},"view/databind.html":{"url":"view/databind.html","title":"数据绑定","keywords":"","body":"数据绑定 模板中绑定的数据来均来自于data、computed属性。 简单绑定 数据绑定使用 Mustache 语法（双大括号）, {{}}之内的可以是一些变量或者简单的表达式。 内容 {{ message }} 组件属性 运算 Hidden {{a + b}} + {{c}} + d 5}}\"> class Index { data = { a: 1, b: 2, c: 3, } } export default new Index(); view中的内容为 3 + 3 + d c-model 应用于表单元素 message:{{message}} class Comp { data = { message:'default-value' } watch = { message(){ console.log('modelTest change'); } } } export default new Comp(); { \"base\": {} } c-model元素上不支持再绑定input事件，如果对于输入值变化之后想执行一些操作，可以通过 watch对应的值来进行； 应用于父子组件之间 父组件 c-model的在组件上的使用 组件使其改变{{modelValueTest2}} class Index { data = { currentComp:'comp1', modelValueTest2:'sss' } methods = { handleClick(){ this.currentComp = (this.currentComp === 'comp1' ) ? 'comp1':'comp2' } } } export default new Index(); .scroller-wrap { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { \"comp1\":\"/components/comp1\", \"comp2\":\"/components/comp2\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" }, \"alipay\": { \"defaultTitle\": \"index\", \"pullRefresh\": false, \"allowsBounceVertical\": \"YES\", \"titleBarColor\": \"#ffffff\" }, \"baidu\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"index\", \"backgroundColor\": \"#ffffff\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": false, \"onReachBottomDistance\": 50 } } 子组件 class Comp { props = { value:{ type:String, default:'default-value' } } methods = { handleInput(e){ console.log('input',e); this.$cmlEmit('input', { value:e.detail.value }) } } } export default new Comp(); { \"base\": {} } Bug&Tips 注意 c-model的值只能是 data或者computed中的key值，不支持 modelValue.xxx 等需要二次计算的值； "},"view/condition.html":{"url":"view/condition.html","title":"条件渲染","keywords":"","body":"条件渲染 c-if 在框架中，使用 c-if=\"{{condition}}\" 来判断是否需要渲染该代码块： True 也可以用 c-else-if 和 c-else 来添加一个 else 块： 5}}\"> 1 2}}\"> 2 3 block c-if 因为 c-if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 标签将多个组件包装起来，并在上边使用 c-if 控制属性。 view1 view2 注意： 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 "},"view/iterator.html":{"url":"view/iterator.html","title":"列表渲染","keywords":"","body":"列表渲染 c-for 在组件上使用 c-for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item {{index}}: {{item.message}} 使用 c-for-item 可以指定数组当前元素的变量名， 使用 c-for-index 可以指定数组当前下标的变量名： {{idx}}: {{itemName.message}} c-for 也可以嵌套，下边是一个九九乘法表 {{i}} * {{j}} = {{i * j}} block c-for 类似 block c-if，也可以将 c-for 用在标签上，以渲染一个包含多节点的结构块。例如： {{index}}: {{item}} c-key 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 中的输入内容，的选中状态），需要使用 c-key 来指定列表中项目的唯一的标识符。 c-key 的值以两种形式提供 1.字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 2.保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如： 当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 "},"view/event.html":{"url":"view/event.html","title":"事件","keywords":"","body":"事件 Chameleon 支持一些基础的事件，保障各端效果一致运行。如果你想要使用某个端特定的事件，请从业务出发使用 组件多态或者接口多态差异化实现功能。 什么是事件 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 事件绑定 当用户点击该组件的时候会在该组件逻辑对象的methods中寻找相应的处理函数 Click me! class Index { methods = { tapName(e) { // 打印事件对象 console.log('事件对象:', e); } } } export default new Index(); 事件类型 chameleon所有元素都支持基础事件类型如下： 类型 触发条件 tap 手指触摸后马上离开 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchend 手指触摸动作结束 事件对象 当触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。它有以下属性： 名称 类型 说明 type String 事件类型 timeStamp Number 页面打开到触发事件所经过的毫秒数 target Object 触发事件的目标元素 且 target = { id, dataset } currentTarget Object 绑定事件的目标元素 且 currentTarget = { id, dataset } touches Array 触摸事件中的属性，当前停留在屏幕中的触摸点信息的数组 且 touches = [{ identifier, pageX, pageY, clientX, clientY }] changedTouches Array 触摸事件中的属性，当前变化的触摸点信息的数组 且 changedTouches = [{ identifier, pageX, pageY, clientX, clientY }] detail Object 自定义事件所携带的数据。 通过`$cmlEmit`方法触发自定义事件，可以传递自定义数据即detail。具体下面`自定义事件`。 _originEvent Object chameleon对各平台的事件对象进行统一，会把原始的事件对象放到_originEvent属性中，当需要特殊处理的可以进行访问。 target && currentTarget 事件属性 属性类型说明 idString事件源组件的id datasetObject事件源组件上由`data-`开头的自定义属性组成的集合 offsetLeftNumber事件源组件相对于窗口左侧的距离 offsetTopNumber事事件源组件相对于窗口上侧的距离 --> dataset 在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType。 示例： ```html DataSet Test class Index { methods = { bindViewTap:function(event){ event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法 event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写 } } } export default new Index(); ``` ### touches && changedTouches 事件属性 数组中的对象具有如下属性： 属性类型说明 identifierNumber触摸点的标识符 pageX, pageYNumber距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴 clientX, clientYNumber距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴 自定义事件 自定义事件用于父子组件之间的通信，父组件给子组件绑定自定义事件，子组件内部触发该事件。绑定事件的方法是以bind+事件名称=\"事件处理函数的形式给组件添加属性，规定事件名称不能存在大写字母触发事件的方法是调用this.$cmlEmit(事件名称,detail对象)。 注意：自定义事件名称不支持click、scroll 例如： 子组件 child 触发自定义事件 class Index { data: {} method: { triggerCustomEvent(e) { this.$cmlEmit('customevent', { company: 'didi', age: 18 }) } } } export default new Index(); 父组件 class Index { data = {} method = { customEventHandler(e) { console.log(e) } } } export default new Index(); 当点击child组件的按钮时，父组件中的customEventHandler方法中打印的e对象如下： { type: \"customevent\", detail: { company: \"didi\", age: 18 } } 支持的语法 事件绑定支持以下几种形式（在内联语句中，$event代表事件对象） 触发元素点击事件 触发元素点击事件（1,2,3） 触发元素点击事件（） 针对以上写法返回的事件对象如下： 写法(1)调用事件函数输出如下 'handleElementTap' [e] 写法(2)调用事件函数输出如下 'handleElementTap' [1,2,3,'messagetestEvent',e] 写法(3)调用事件函数输出如下 'handleElementTap' [] 事件冒泡 chameleon-tool@0.2.0 + 的版本 支持了事件冒泡和阻止事件冒泡 注意：对于阻止事件冒泡，在内联事件传参的情况下，需要传递 $event参数； 触发元素点击事件 触发元素点击事件 cml语法事件冒泡测试 {{rootText}} {{parentText}} {{innerText}} class Index { methods = { click: function(e) { this.innerText = 'inner bubble' console.log('this.innerText',this.innerText) }, parentClick: function(e) { this.parentText = 'parent bubble' console.log('this.parentClick',this.parentClick) }, rootClick: function(e) { this.rootText = 'root bubble' console.log('this.rootClick',this.rootClick) }, } } export default new Index(); 其他事件说明 事件绑定的写法同组件的属性，以 key、value 的形式。 key 以c-bind，然后跟上事件的类型，如c-bind:tap、c-bind:touchstart。 value 是一个字符串，需要在对应的逻辑对象中声明的methods中声明该方法。 Bug & Tips 不支持的语法 注意，事件绑定不支持直接传入一个表达式，和绑定多个内联执行函数比如 "},"view/component.html":{"url":"view/component.html","title":"动态组件","keywords":"","body":"component 动态渲染组件 component接受两个属性 属性名 说明 is 接受一个计算属性作为动态渲染的标签名 shrinkcomponents 接受 usingComponents 中的key值组成的字符串作为动态组件选择的范围 注意，为了提高微信端的渲染效率，强烈建议加上shrinkcomponents = \"comp1,comp2,...\",缩小动态渲染的查找范围，减少不必要的渲染开销 组件改变 class Index { data = { dataComp: 'comp', } computed ={ currentComp(){ return this.dataComp === 'comp' ? 'comp1' : 'comp'; } } methods = { handleElementClick (a,b) { console.log('handleElementClick',arguments,a,b) this.dataComp = (this.dataComp === 'comp') ? 'comp1' : 'comp'; }, } } export default new Index(); { \"base\": { \"usingComponents\": { \"comp\":\"./comp\", \"comp1\":\"./comp1\", \"comp2\":\"./comp2\", \"comp3\":\"./comp3\", } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" }, \"alipay\": { \"defaultTitle\": \"index\", \"pullRefresh\": false, \"allowsBounceVertical\": \"YES\", \"titleBarColor\": \"#ffffff\" }, \"baidu\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"index\", \"backgroundColor\": \"#ffffff\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": false, \"onReachBottomDistance\": 50 } } Bug&Tips 注意 : 小程序端是通过条件判断来模拟component is的效果的，所以不要在component 标签上在在写c-if c-else c-else-if等条件判断 "},"view/directive.html":{"url":"view/directive.html","title":"指令","keywords":"","body":"指令 c-if 根据表达式的真假值条件渲染元素 根据c-if的真假结果决定是否渲染 c-else 不需要表达式; 限制：前一个兄弟元素必须有 c-if 或者 c-else-if 用法 0.5}}\"> Now you see me Now you don't c-else-if 限制：前一个兄弟元素必须有 c-if 或者 c-else-if A B C Not A/B/C c-for {{idx}}: {{itemName.message}} c-model 父组件 c-model的使用 {{modelValueTest}} 组件使其改变{{modelValueTest2}} 子组件 methods = { handleInput(e){ console.log('input',e); this.$cmlEmit('input', { value: Date.now() }) } } } $cmlEmit的事件名必须是 'input',\b传入的参数需要有一个更新的value作为key,\b其属性值作为新值进行更新； c-text 不支持组件的c-text c-show 测试元素c-show 组件v-show 使用c-show的元素不支持\b同时有 style 属性 elementShow是来自data或者computed中的key值,或者true/false c-animation 传入的值必须由createAnimation返回 hello world import cml from 'cml目录'; const animation = cml.createAnimation(); class Index { data = { animationData: {} } methods = { click: function() { this.animationData = animation.opacity(0.1).step({}).export(); } } }; export default new Index(); "},"view/vue.html":{"url":"view/vue.html","title":"CML-类 vue 语法","keywords":"","body":"CML-类VUE语法 为了降低学习成本，独立支持了vue的指令子集，你可以在模板添加一个lang属性即可使用。 注意必须在组件根元素上 template上加 lang='vue' 数据绑定 条件渲染 列表渲染 事件 指令 样式语法规范 "},"view/databind-vue.html":{"url":"view/databind-vue.html","title":"数据绑定","keywords":"","body":"数据绑定 模板中绑定的数据来均来自于data、computed属性。 模板语法 数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于： 内容 {{ message }} 组件属性 或者 v-bind view v-bind:id=\"dynamicId\" v-model 应用于表单元素 message:{{message}} class Comp { data = { message:'default-value' } watch = { message(){ console.log('modelTest change'); } } } export default new Comp(); { \"base\": {} } v-model元素上不支持再绑定input事件，如果对于输入值变化之后想执行一些操作，可以通过 watch对应的值来进行； 应用于父子组件之间 父组件 c-model的在组件上的使用 组件使其改变{{modelValueTest2}} class Index { data = { currentComp:'comp1', modelValueTest2:'sss' } methods = { handleClick(){ this.currentComp = (this.currentComp === 'comp1' ) ? 'comp1':'comp2' } } } export default new Index(); .scroller-wrap { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { \"comp1\":\"/components/comp1\", \"comp2\":\"/components/comp2\" } } } 子组件 class Comp { props = { value:{ type:String, default:'default-value' } } methods = { handleInput(e){ console.log('input',e); debugger; this.$cmlEmit('input', { value:e.detail.value }) } } } export default new Comp(); { \"base\": {} } Javascript表达式 在模板内容中 {{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} 算数运算 {{a + b}} + {{c}} + d class Index { data = { a: 1, b: 2, c: 3 } } export default new Index(); view中的内容为 3 + 3 + d。 字符串运算 {{\"hello\" + name}} 特别注意：模板中的字符串都要使用双引号，不能使用单引号。 数据路径运算 {{object.key}} {{array[0]}} class Index { data = { object: { key: 'Hello ' }, array: ['MINA'] } } export default new Index(); Bug & Tip 使用component语法的时候，为了提高微信端的渲染效率，建议加上shrinkComponents = \"comp1,comp2,...\",缩小动态渲染的查找范围，减少不必要的渲染开销； 注意 v-model的值只能是 data或者computed中的key值，不支持 modelValue.xxx 等需要二次计算的值； "},"view/condition-vue.html":{"url":"view/condition-vue.html","title":"条件渲染","keywords":"","body":"条件渲染 v-if 在框架中，使用 v-if=\"condition\" 来判断是否需要渲染该代码块： True 也可以用 v-else-if 和 v-else 来添加一个 else 块： 5\"> 1 2\"> 2 3 block v-if 因为 v-if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 标签将多个组件包装起来，并在上边使用 v-if 控制属性。 view1 view2 注意：: 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 Bug & Tip 不要与 c-if c-else-if c-else混用 "},"view/iterator-vue.html":{"url":"view/iterator-vue.html","title":"列表渲染","keywords":"","body":"列表渲染 v-for 在组件上使用 v-for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 {{index}}: {{item.message}} {{index}}: {{item.message}} {{index}}: {{item.message}} block v-for 类似 block v-if，也可以将 v-for 用在标签上，以渲染一个包含多节点的结构块。例如： {{index}}: {{item}} :key 1.如果 :key=\"item.id\"，那么就是vue中正常的语法。 2.如果 :key=\"item\",那么在微信端会被渲染成 wx:key=\"this\"; 保留关键字 this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如： 当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 Bug & Tip 不要与c-for c-for-index c-for-item c-key这些语法混用 vue的v-for相关语法都可以使用，但是需要注意一点就是只支持数组形式的被遍历值 "},"view/event-vue.html":{"url":"view/event-vue.html","title":"事件","keywords":"","body":"事件 Chameleon 支持一些基础的事件，保障各端效果一致运行。如果你想要使用某个端特定的事件，请从业务出发使用 组件多态或者接口多态差异化实现功能。 主要扩展了事件的绑定：加强了符合vue语法的事件绑定； 事件绑定 主要增强了可以通过 v-on @这种形式去绑定事件； Click me! class Index { data = {} methods = { tapName() { console.log(e); } } } export default new Index(); 事件类型 事件类型列表： 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchend 手指触摸动作结束 tap 手指触摸后马上离开 事件对象 当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。chameleon将事件绑定做了一层代理，将各平台的事件对象做统一，统一后的事件对象有如下属性： 名称 类型 说明 type String 事件类型 timeStamp Number 页面打开到触发事件所经过的毫秒数 target Object 触发事件的目标元素 且 target = {id,dateset} currentTarget Object 绑定事件的目标元素 且 currentTarget = {id,dataset} changedTouches Array 触摸事件中的属性，当前变化的触摸点信息的数组 且 changedTouches = [{ identifier, pageX, pageY, clientX, clientY }] detail Object 自定义事件所携带的数据。 通过$cmlEmit方法触发自定义事件，可以传递自定义数据即detail。具体下面自定义事件 _originEvent Object chameleon对各平台的事件对象进行统一，会把原始的事件对象放到_originEvent属性中，当需要特殊处理的可以进行访问。 target && currentTarget 属性 类型 说明 id String 事件源组件的id dataset Object 事件源组件上由data-开头的自定义属性的集合 dataset 在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType。 DataSet Test class Index { methods = { bindViewTap:function(event){ event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法 event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写 } } } export default new Index(); changedTouches 事件属性 数组中的对象有如下属性： 属性 类型 说明 identifier Number 触摸点的标识符 pageXpageY Number 距离文档左上角的距离，文档的左上角为原点，横向为X轴，纵向为Y轴 clientXclientY Number 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴 自定义事件 自定义事件用于父子组件之间的通信，父组件给子组件绑定自定义事件，子组件内部触发该事件。规定事件名称不能存在大写字母触发事件的方法是调用this.$cmlEmit(事件名称,detail对象)。 注意：自定义事件名称不支持click、scroll 例如： 子组件 yyl-com 触发自定义事件 class Index { data = {} method = { triggerCustomEvent(e) { this.$cmlEmit('customevent', { company: 'didi', age: 18 }) } } } export default new Index(); 父组件 class Index { data = {} method = { customEventHandler(e) { console.log(e) } } } export default new Index(); 当点击yyl-com组件的按钮时，父组件中的customEventHandler方法中打印的e对象如下： { type: \"customevent\", detail: { company: \"didi\", age: 18 } } 支持的语法 事件绑定支持以下几种形式（在内联语句中，$event代表事件对象） 触发元素点击事件 触发元素点击事件（1,2,3） 触发元素点击事件（） 针对以上写法返回的事件对象如下： 写法(1)调用事件函数输出如下 'handleElementTap' [e] 写法(2)调用事件函数输出如下 'handleElementTap' [1,2,3,'messagetestEvent',e] 写法(3)调用事件函数输出如下 'handleElementTap' [] 事件冒泡 chameleon-tool@0.2.0 + 的版本 支持了事件冒泡和阻止事件冒泡 vue语法下仅仅扩展了 .stop; 注意：对于阻止事件冒泡，在内联事件传参的情况下，需要传递 $event参数； 触发元素点击事件 触发元素点击事件 vue语法事件冒泡测试 {{rootText}} {{parentText}} {{innerText}} class Index { methods = { click: function(e) { this.innerText = 'inner bubble' console.log('this.innerText',this.innerText) }, parentClick: function(e) { this.parentText = 'parent bubble' console.log('this.parentClick',this.parentClick) }, rootClick: function(e) { this.rootText = 'root bubble' console.log('this.rootClick',this.rootClick) }, } } export default new Index(); Bug & Tips 不支持的语法 注意，事件绑定不支持直接传入一个表达式，和绑定多个内联执行函数比如 "},"view/component-vue.html":{"url":"view/component-vue.html","title":"动态组件","keywords":"","body":"component 动态渲染组件 component接受两个属性 属性名 说明 is 接受一个计算属性作为动态渲染的标签名 shrinkcomponents 接受 usingComponents 中的key值组成的字符串作为动态组件选择的范围 组件改变 class Index { data = { dataComp:'comp', } computed ={ currentComp(){ return this.dataComp === 'comp' ? 'comp1' : 'comp'; } } methods = { handleElementClick (a,b) { console.log('handleElementClick',arguments,a,b) this.dataComp = (this.dataComp === 'comp' ? 'comp1' : 'comp') } } } export default new Index(); { \"base\": { \"usingComponents\": { \"comp\":\"./comp\", \"comp1\":\"./comp1\", \"comp2\":\"./comp2\", \"comp3\":\"./comp3\", } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" }, \"alipay\": { \"defaultTitle\": \"index\", \"pullRefresh\": false, \"allowsBounceVertical\": \"YES\", \"titleBarColor\": \"#ffffff\" }, \"baidu\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"index\", \"backgroundColor\": \"#ffffff\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": false, \"onReachBottomDistance\": 50 } } Bug&Tips 注意 : 小程序端是通过条件判断来模拟component is的效果的，所以不要在component 标签上在在写c-if c-else c-else-if等条件判断 "},"view/directive-vue.html":{"url":"view/directive-vue.html","title":"指令","keywords":"","body":"指令 v-if 根据表达式的真假值条件渲染元素 根据v-if的真假结果决定是否渲染 v-else 不需要表达式 限制：前一个兄弟元素必须有 v-if 或者 v-else-if 用法 0.5\"> Now you see me Now you don't v-else-if 限制：前一个兄弟元素必须有 v-if 或者 v-else-if A B C Not A/B/C v-for {{idx}}: {{itemName.message}} v-model 父组件 v-model的使用 {{modelValueTest}} 组件使其改变{{modelValueTest2}} 子组件 methods = { handleInput(e){ console.log('input',e); this.$cmlEmit('input', { value: Date.now() }) } } } v-text 不支持组件的v-text v-show 测试元素c-show 组件v-show 使用v-show的元素不支持\b同时有 style 属性 elementShow是来自data或者computed中的key值，或者 true/false "},"view/css-vue.html":{"url":"view/css-vue.html","title":"样式语法规范","keywords":"","body":"样式语法 class属性 如果使用class语法，支持如下写法 fafafa fafafa 简单数据绑定 class数据绑定 class Index { data() { return { prefix: 'cls' } } } export default new Index(); 三元运算符 或者将其放入计算属性 class Index { computed = { itemClass() { return open ? 'cls1 cls2' : 'cls3 cls4'; } } } export default new Index(); style语法 如果使用style语法支持如下写法，style不支持多个style,即style :style同时写 fafafa fafafa class Index { data = { inlineStyle: 'border: 1px solid red;' } computed = { computedString() { return this.$cmlStyle(inlineStyle) } } } export default new Index(); "},"view/base_component.html":{"url":"view/base_component.html","title":"基础组件","keywords":"","body":"基础组件 框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。详细介绍请参考组件文档。 什么是组件： 组件是视图层的基本组成单元。 组件自带一些功能与微信风格一致的样式。 一个组件通常包括 开始标签 和 结束标签，属性 用来修饰这个组件，内容 在两个标签之内。Content goes here ... 注意：所有组件属性都是小写，以连字符-连接。 属性类型 类型 描述 注解 String 字符串 `\"string\"` Number 数字 `1, 1.5` Boolean 布尔值 `true，false` Array 数组 `[1, 'string']` Object 对象 `{key: value}` EventHandler 事件处理函数名 `handlerName`是组件中定义的事件处理函数名 公共属性 所有组件都有以下属性 属性名 类型 描述 注解 id String 组件唯一标示 保证整个页面唯一 class String 组件样式类名 在cmss中定义的样式类 style String 组件内联样式 可动态设置内联样式 c-bind EventHandler 组件事件 特殊属性 chameleon提供了内置组件及扩展组件，根据组件特殊性几乎每个组件都有自己的特殊属性，详细属性请查看组件文档。 "},"logic/logic.html":{"url":"logic/logic.html","title":"逻辑层","keywords":"","body":"逻辑层(Logic) 逻辑层负责反馈用户对界面操作的处理中心。 逻辑层是终端开发的“灵魂”。 而 VM 对象 是逻辑层规范的输入口 VM 对象 字段名类型说明 propsObject 声明当前组件可接收数据属性 props = { type, default } type为数据类型，default为数据默认值 dataObjectCML模板可直接使用的响应数据，是连接视图层的枢纽 methodsObject处理业务逻辑与交互逻辑的方法 watchObject侦听属性，监听数据的变化，触发相应操作 computedObjectCML模板可直接使用的计算属性数据,也是连接视图层的枢纽 beforeCreateFunction例初始化之后，数据和方法挂在到实例之前 一个页面只会返回一次 createdFunction数据及方法挂载完成 beforeMountFunction开始挂载已经编译完成的cml到对应的节点时 mountedFunctioncml模板编译完成,且渲染到dom中完成 beforeDestroyFunction实例销毁之前 destroyedFunction实例销毁后 响应式数据绑定系统 响应式数据绑定意味着开发者只需关心逻辑处理，通过数据绑定的形式，当数据变化时视图自动更新。 生命周期 每个 Chameleon 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 \b节点 并在数据变化时更新 \b节点 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给开发者在不同阶段添加自己的代码的机会。 计算属性 computed 对于模板内任何复杂逻辑，你都应当使用计算属性 侦听属性 watch 提供了一种更通用的方式来观察和响应实例上的数据变动 API 调用各端原生能力的入口 \b数据管理 \b利用这种数据管理模式在组件外部集中管理状态，可方便构建一个中大型单页应用 "},"logic/data_bind.html":{"url":"logic/data_bind.html","title":"响应式数据绑定系统","keywords":"","body":"响应式数据绑定系统(Data binding) 当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。 通过这个简单的例子来看： Hello {{name}}! Click me! class Index { data = { name: 'Chameleon' } methods = { changeName: function(e) { // sent data change to view this.name = 'CML'; } } }; export default new Index(); 框架首先将逻辑层数据中的 name 与视图层的 name 进行了绑定，所以打开页面的时候会显示 Hello Chameleon!； 当点击按钮的时候，视图层会发送 changeName 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数； 回调函数触发后，逻辑层执行数据赋值的操作，将 data 中的 name 从 Chameleon 变为 CML，因为该数据和视图层已经绑定了，从而视图层会自动改变为 Hello CML!。 "},"logic/lifecycle.html":{"url":"logic/lifecycle.html","title":"生命周期","keywords":"","body":"生命周期 chameleon 为组件和 页面 提供了一系列生命周期事件，保障应用有序执行。 如果你想使用某个端特定的生命周期，请从业务出发使用 接口多态 接收特定的生命周期事件回调。 钩子 执行时机 详细 beforeCreate 实例初始化之后，数据和方法挂在到实例之前 一个页面只会返回一次 在该生命周期回调函数中会返回传入当前页面的参数对象 created 数据及方法挂载完成 在该生命周期回调函数中会返回传入当前页面的参数对象 beforeMount 开始挂载已经编译完成的cml到对应的节点时 在该生命周期回调函数中会返回传入当前页面的参数对象 mounted cml模板编译完成,且渲染到dom中完成 beforeDestroy 实例销毁之前 destroyed 实例销毁后 生命周期回调函数 beforeCreate(Object res) 参数说明 名称 类型 说明 res Object 在该生命周期回调函数中会 返回对象res: res = { query } query 是打开当前页面路径中的参数 created(Object res) 参数说明 名称 类型 说明 res Object 在该生命周期回调函数中会 返回对象res: res = { query } query 是打开当前页面路径中的参数 beforeMount(Object res) 参数说明 名称 类型 说明 res Object 在该生命周期回调函数中会 返回对象res: res = { query } query 是打开当前页面路径中的参数 钩子示例 class Index { beforeCreate(query) { // data数据挂载到this根节点上之前，以及methods所有方法挂载到实例根节点之前 // 注意：只用页面的 beforeCreate钩子 会返回页面query console.log('App beforeCreate: 打开当前页面路径中的参数是 ', query) } created() { // data,methods里面的这些events挂载完成 console.log('App created') } beforeMount() { // 开始挂载已经编译完成的cml到对应的节点时 console.log('App beforeMount') } mounted() { // cml模板编译完成,且渲染到dom中完成,在整个生命周期中只执行一次 console.log('App mounted') } beforeDestroy() { // 实例销毁前 console.log('App beforeDestroy') } destroyed() { // 实例销毁后 console.log('App destroyed') } }; export default new Index(); 生命周期多态 cml 在 *.[web|weex|wx].cml 文件中支持生命周期的多态，可以针对不同的平台添加专属钩子函数。 假设有一个页面home.cml，需要使用小程序页面生命周期微信端onHide、支付宝端onHide、百度端onHide，可以如下实现： 项目根目录执行 cml init component，选择 multimode-interface 多态接口，输入interface name: lifecycleInterface，自动生成src/components/lifecycleInterface 在src/components/lifecycleInterface/lifecycleInterface.cml多态接口中，添加如下代码： interface LifecycleInterfaceInterface { onHide(): void; } class Method implements LifecycleInterfaceInterface { onHide() { console.log('web hide') } } export default new Method(); class Method implements LifecycleInterfaceInterface { onHide() { console.log('weex hide') } } export default new Method(); class Method implements LifecycleInterfaceInterface { onHide() { console.log('wx hide') } } export default new Method(); class Method implements LifecycleInterfaceInterface { onHide() { console.log('alipay hide') } } export default new Method(); class Method implements LifecycleInterfaceInterface { onHide() { console.log('baidu hide') } } export default new Method(); 在 home.cml 文件，使methods合并lifecycleInterface多态方法 home页面 import lifecycleInterface from '../../components/lifecycleInterface/lifecycleInterface' class Home { data = {} computed = {} watch = {} methods = { ...lifecycleInterface } beforeCreate(res) {} created() {} } export default new Home() "},"logic/computed.html":{"url":"logic/computed.html","title":"计算属性 computed","keywords":"","body":"计算属性 computed 示例 Original message: \"{{ message }}\" Computed reversed message: \"{{ reversedMessage }}\" class Index { data = { message: 'Hello' } computed = { // 计算属性的 getter reversedMessage: function () { return this.message.split('').reverse().join('') } } }; export default new Index(); 结果： Original message: \"Hello\" Computed reversed message: \"olleH\" 这里我们声明了一个计算属性 reversedMessage。 我们提供的函数将用作属性 reversedMessage 的 getter 函数，当 message 发生改变时，reversedMessage 也会更新 "},"logic/watch.html":{"url":"logic/watch.html","title":"侦听属性 watch","keywords":"","body":"侦听属性 watch 示例 fullName is : \"{{ fullName }}\" class Index { data = { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' } watch = { firstName: function (newV, oldV) { this.fullName = newV + ' ' + this.lastName }, lastName: function (newV, oldV) { this.fullName = this.firstName + ' ' + newV } } }; export default new Index(); 除了 watch 选项之外，你还可以使用命令式的 this.$watch API。 但是，上面代码是命令式且重复的。将它与计算属性的版本进行比较： class Index { data = { firstName: 'Foo', lastName: 'Bar' } computed = { fullName: function () { return this.firstName + ' ' + this.lastName } } } 所以，不要滥用 watch ~ "},"logic/API.html":{"url":"logic/API.html","title":"API","keywords":"","body":"API chameleon 框架提供了丰富的多态接口，可以调起各端提供的原生能力，如系统信息、元素节点信息、动画效果、本地存储、网络请求、地理位置等。请参考 API 文档。 代码示例 import cml from 'chameleon-api' cml.showToast({ message: 'Hello world!', duration: 1000 }) 通常，在 chameleon API 有以下几种类型： 通用 API 大多数 API 都是异步 API，如 cml.get 等。这类 API 接口通常都接受一个 Object 类型的参数，返回 Promise ，对应请求成功和失败回调，支持 then 链式调用。 代码示例 cml.get({ url: 'https://cml.com/api/user/1' }).then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }) 运行时相关 API 提供模块 导入\\导出 能力，详细介绍 代码示例 import a from 'a.js' export {a} 数据管理store API 提供多端应用集中式管理状态数据的能力 详细介绍 代码示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state, mutations, actions, getters, modules }) export default store "},"logic/store.html":{"url":"logic/store.html","title":"数据管理","keywords":"","body":"数据管理 chameleon-store 提供集中管理数据的能力。 这是一个简单的例子： 目录结构 简单介绍 类似 Vuex 数据理念和语法规范，chameleon-store 主要有以下核心概念： state getters mutation action 子模块 通过 chameleon-store 创建的Store实例,有以下方法： ChameleonStore.createStore(options: Object): Object Store构造器。详细介绍 ChameleonStore.Store 实例方法 Store.commit(type: string, payload?: any) 提交 mutation。详细介绍 Store.dispatch(type: string, payload?: any) 分发 action。详细介绍 Store.mapState(map: Array | Object): Object 为组件创建计算属性以返回 store 中的状态。详细介绍 Store.mapGetters(map: Array | Object): Object 为组件创建计算属性以返回 getter 的返回值。详细介绍 Store.mapMutations(map: Array | Object): Object 创建组件方法提交 mutation。详细介绍 Store.mapActions(map: Array | Object): Object 创建组件方法分发 action。详细介绍 Store.registerModule(path: String, module: Module) 注册一个动态模块。详细介绍 "},"logic/store/start.html":{"url":"logic/store/start.html","title":"开始","keywords":"","body":"开始 “store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。store 和单纯的全局对象有以下两点不同： store 的状态存储是响应式的。当 chameleon 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。 最简单的store 创建 store，并且提供一个初始 state 对象和一些 mutation： import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store 通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更： store.commit('increment') console.log(store.state.count) // -> 1 再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。 由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation。 接下来，我们将会更深入地探讨一些核心概念。让我们先从 State 概念开始。 "},"logic/store/state.html":{"url":"logic/store/state.html","title":"state","keywords":"","body":"State 单一状态树 chameleon-store 用一个对象就包含了全部的应用层级状态。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 单状态树和模块化并不冲突——在后面的章节里我们会讨论如何将状态和状态变更事件分布到各个子模块中。 在 chameleon 组件中获得 store 状态 那么我们如何在 chameleon 组件中展示状态呢？由于 chameleon内置的store 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： import store from '../store' // 创建一个 Counter 组件 const Counter = { computed: { count () { return store.state.count } } } 每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。 mapState辅助函数 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 chameleon内置的store.mapState import store from '../store' class Index { // ... computed = store.mapState({ // 箭头函数可使代码更简练 count: state => state.count, // 传字符串参数 'count' 等同于 `state => state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } export default new Index(); 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 import store from '../store'; class Index { computed = store.mapState([ // 映射 this.count 为 store.state.count 'count' ]) } export default new Index(); 对象展开运算符 mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符（现处于 ECMASCript 提案 stage-3 阶段），我们可以极大地简化写法： import store from '../store' class Index { computed = { localComputed() { /* ... */ }, // 使用对象展开运算符将此对象混入到外部对象中 ...store.mapState({ // ... }) } } export default new Index(); 组件仍然保有局部状态 使用 chameleon内置的store 并不意味着你需要将所有的状态放入store。虽然将所有的状态放到 chameleon内置的store 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。 "},"logic/store/getters.html":{"url":"logic/store/getters.html","title":"getters","keywords":"","body":"Getter 有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： computed: { doneTodosCount () { return store.state.todos.filter(todo => todo.done).length } } 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。 chameleon内置store 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数： import createStore from 'chameleon-store' const store = createStore({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos: state => { return state.todos.filter(todo => todo.done) } } }) export default store Getter 会暴露为 store.getters 对象： store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }] Getter 也可以接受其他 getter 作为第二个参数, rootState作为第三个参数： getters: { // ... doneTodosCount: (state, getters, rootState) => { return getters.doneTodos.length } } store.getters.doneTodosCount // -> 1 我们可以很容易地在任何组件中使用它： computed: { doneTodosCount () { return store.getters.doneTodosCount } } 你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。 getters: { // ... getTodoById: (state) => (id) => { return state.todos.find(todo => todo.id === id) } } store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false } mapGetters辅助函数 mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： import store from '../store' class Index { // ... computed = { // 使用对象展开运算符将 getter 混入 computed 对象中 ...store.mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) } }; export default new Index(); 如果你想将一个 getter 属性另取一个名字，使用对象形式： store.mapGetters({ // 映射 `this.doneCount` 为 `store.getters.doneTodosCount` doneCount: 'doneTodosCount' }) "},"logic/store/mutation.html":{"url":"logic/store/mutation.html","title":"mutation","keywords":"","body":"Mutation 更改 chameleon内置store 的 store 中的状态的唯一方法是提交 mutation。chameleon内置store 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： import createStore from 'chameleon-store' const store = createStore({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) export default store 你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法： store.commit('increment') 提交载荷（Payload） 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）： // ... mutations: { increment (state, n) { state.count += n } } store.commit('increment', 10) 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： // ... mutations: { increment (state, payload) { state.count += payload.amount } } store.commit('increment', { amount: 10 }) Mutation 需遵守 Chameleon 的响应规则 既然 chameleon内置store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Chameleon 组件也会自动更新。这也意味着 chameleon内置store 中的 mutation 也需要与使用 Chameleon 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写： state.obj = { ...state.obj, newProp: 123 } 使用常量替代 Mutation 事件类型 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： // mutation-types.js export const SOME_MUTATION = 'SOME_MUTATION' // store.js import createStore from 'chameleon-store' import { SOME_MUTATION } from './mutation-types' const store = createStore({ state: { ... }, mutations: { // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) { // mutate state } } }) export default store 用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。 Mutation 必须是同步函数 一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子： mutations: { someMutation (state) { api.callAsyncMethod(() => { state.count++ }) } } 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 在组件中提交Mutation 你可以在组件中使用 store.commit('xxx') 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用。 import store from '../store' createComponent({ // ... methods: { ...store.mapMutations([ 'increment', // 将 `this.increment()` 映射为 `store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `store.commit('incrementBy', amount)` ]), ...store.mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `store.commit('increment')` }) } }) 下一步：Action 在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 chameleon内置store 中，mutation 都是同步事务： store.commit('increment') // 任何由 \"increment\" 导致的状态变更都应该在此刻完成。 为了处理异步操作，让我们来看一看 Action。 "},"logic/store/action.html":{"url":"logic/store/action.html","title":"action","keywords":"","body":"Action Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 让我们来注册一个简单的 action： import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') }, increment2({rootState, state, getters, dispatch, commit}) { } } }) export default store Action 函数接受一个 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.rootState、context.state 和 context.getters 来获取全局state、局部state 和 全局 getters。 实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）： actions: { increment ({ commit }) { commit('increment') } } 分发 Action Action 通过 store.dispatch 方法触发： store.dispatch('increment') 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作： actions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) } } Actions 支持同样的载荷方式进行分发： // 以载荷形式分发 store.dispatch('incrementAsync', { amount: 10 }) 来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation： actions: { checkout ({ commit, state }, products) { // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () => commit(types.CHECKOUT_SUCCESS), // 失败操作 () => commit(types.CHECKOUT_FAILURE, savedCartItems) ) } } 注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。 在组件中分发Action 你在组件中使用 store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用： import store from '../store' class Index { methods = { ...store.mapActions([ 'increment', // 将 `this.increment()` 映射为 `store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `store.dispatch('incrementBy', amount)` ]), ...store.mapActions({ add: 'increment' // 将 `this.add()` 映射为 `store.dispatch('increment')` }) } }; export default new Index(); 组合 Action Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： actions: { actionA ({ commit }) { return new Promise((resolve, reject) => { setTimeout(() => { commit('someMutation') resolve() }, 1000) }) } } 现在你可以： store.dispatch('actionA').then(() => { // ... }) 在另外一个 action 中也可以： actions: { // ... actionB ({ dispatch, commit }) { return dispatch('actionA').then(() => { commit('someOtherMutation') }) } } 最后，如果我们利用 async / await，我们可以如下组合 action： // 假设 getData() 和 getOtherData() 返回的是 Promise actions: { async actionA ({ commit }) { commit('gotData', await getData()) }, async actionB ({ dispatch, commit }) { await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) } } 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 "},"logic/store/module.html":{"url":"logic/store/module.html","title":"子模块","keywords":"","body":"Module 当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，chameleon内置store 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： import createStore from 'chameleon-store' const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = createStore({ modules: { a: moduleA, b: moduleB } }) store.state.a // -> moduleA 的状态 store.state.b // -> moduleB 的状态 模块的局部状态 对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。 const moduleA = { state: { count: 0 }, mutations: { increment (state) { // 这里的 `state` 对象是模块的局部状态 state.count++ } }, getters: { doubleCount (state) { return state.count * 2 } } } 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState： const moduleA = { // ... actions: { incrementIfOddOnRootSum ({ state, commit, rootState }) { if ((state.count + rootState.count) % 2 === 1) { commit('increment') } } } } 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来： const moduleA = { // ... getters: { sumWithRootCount (state, getters, rootState) { return state.count + rootState.count } } } 模块动态注册 在 store 创建之后，你可以使用 store.registerModule 方法注册模块： // 注册模块 `myModule` store.registerModule('myModule', { // ... }) 之后就可以通过 store.state.myModule 访问模块的状态。 "},"logic/store/structure.html":{"url":"logic/store/structure.html","title":"目录结构","keywords":"","body":"项目结构 Chameleon内置store 并不限制你的代码结构。但是，它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。 对于大型应用，我们会希望把 Chameleon 相关代码分割到模块中。下面是项目结构示例： ├── app ├── assets ├── pages # 页面 │ └── ... ├── components # 组件 │ ├── c-todoitem │ └── ... └── store ├── action-types.js # 定义 actions 的类型 ├── actions.js # 根级别的 actions ├── getter-types.js # 定义 getters 的类型 ├── getters.js # 根级别的 getters ├── index.js # 我们组装模块并导出 store 的地方 ├── mutation-types.js # 定义 mutations 的类型 ├── mutations.js # 根级别的 mutation ├── state.js # 组件初始状态数据 └── modules # 子模块 ├── ... "},"framework/custom-component/custom-component.html":{"url":"framework/custom-component/custom-component.html","title":"自定义组件","keywords":"","body":"自定义组件 cml支持简洁的组件化编程。 开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。 创建自定义组件 类似页面，自定义组件由 4部分组成。 要编写一个自定义组件，可以在 json 中进行自定义组件声明（将 component 字段设为 true，这是可选操作，因为cml会在引用这个文件时自动识别自定义组件）： { \"component\": true } 接下来，在 中编写组件模板，在 中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 组件模板和样式 。 代码示例： {{innerText}} /* 这里的样式只应用于这个自定义组件 */ .inner { color: red; } 注意：在组件CMSS中不应使用ID选择器、属性选择器和标签名选择器。 组件的属性值和内部数据将被用于组件 CML 的渲染，其中，属性值是可由组件外部传入的。更多细节参见 组件VM 。 代码示例： class CustomCom { props = { title: String, innerText: { type: String }, content: { type:Object, default: {} }, list: { type: Array, default: [] } } data = {} computed = {} watch = {} methods = {} beforeCreate() {} created() {} beforeMount() {} mounted() {} beforeDestroy() {} destroyed() {} } export default new CustomCom(); 使用自定义组件 使用已注册的自定义组件前，首先要在页面的 中进行引用声明。 此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径(相对路径或者绝对路径)： { \"usingComponents\": { \"component-tag-name\": \"path/to/the/custom/component\" } } 这样，在页面的 CML 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。 代码示例： 自定义组件的 CML 节点结构在与数据结合之后，将被插入到引用位置内。 细节注意事项 一些需要注意的细节： 因为 CML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 usingComponents 字段）。 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。 注意，是否在页面文件中使用 usingComponents 会使得页面的 this 对象的原型稍有差异，包括： 使用 usingComponents 时会多一些方法，如 selectComponent 。 如果页面比较复杂，新增或删除 usingComponents 定义段时建议重新测试一下。 "},"framework/custom-component/cml-cmss.html":{"url":"framework/custom-component/cml-cmss.html","title":"组件模板和样式","keywords":"","body":"组件模板和样式 类似于页面，自定义组件拥有自己的 模板和 样式。 首先我们通过 cml init project 生成一个 cml项目，然后按照以下操作指引，看下如何使用cml的组件 cml init component 选择普通组件 输入 component-tag-namecomponent-tag-name 在 src/pages/index/index.cml中引入这个组件 \"usingComponents\": { \"component-tag-name\":\"/components/component-tag-name/component-tag-name\" } 组件模板 组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。 在组件模板中可以提供一个 节点，用于承载组件引用时提供的子节点。 代码示例： 这里是组件的内部节点 的位置上 --> 这里是插入到组件slot中的内容 模板数据绑定 可以使用数据绑定，这样就可以向子组件的属性传递动态数据。 代码示例： 的位置上 --> 这里是插入到组件slot中的内容 在以上例子中，组件的属性 propA 和 propB 将收到页面传递的数据。页面可以通过 this.dataFieldA、this.dataFieldB 来改变绑定的数据字段。 注意：这样的数据绑定只能传递 JSON 兼容数据。 组件的slot 在组件的中可以包含 slot 节点，用于承载组件使用者提供的cml结构。 支持通过具名插槽的方式在模板中使用多个slot 组件模板的slot 然后在父页面 src/pages/index/index.cml中 this is from index this is before from index this is after from index this is from index aaaa 组件样式 组件对应 style 标签内的样式，只对当前节点生效。编写组件样式时，需要注意以下几点： 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。 继承样式，如 font 、 color ，会从组件外继承到组件内。 元素选择器不支持 #a { } /* 在组件中不能使用 */ [a] { } /* 在组件中不能使用 */ button { } /* 在组件中不能使用 */ .a > .b { } /* 除非 .a 是 view 组件节点，否则不一定会生效 */ view{ }/* 不支持元素选择器 */ 样式多态 chameleon扩展了多态样式，用于针对对于不同端有不同的样式需求的情况 参考 引用外部样式 参考 "},"framework/custom-component/comp-vm.html":{"url":"framework/custom-component/comp-vm.html","title":"组件 VM","keywords":"","body":"组件 VM 在.cml 文件 代码块export default的对象实例，可用于定义组件，指定组件的属性、数据、方法等。 cml init component 选择普通组件 输入 component-tag-name 定义如下： 字段名 类型 说明 props Object 声明当前组件可接收数据属性 props = { type, default } type为数据类型，default为数据默认值 data Object CML模板可直接使用的响应数据，是连接视图层的枢纽 methods Object 处理业务逻辑与交互逻辑的方法 watch Object 侦听属性，监听数据的变化，触发相应操作 computed Object CML模板可直接使用的计算属性数据,也是连接视图层的枢纽 beforeCreate Function 例初始化之后，数据和方法挂在到实例之前 一个页面只会返回一次 created Function 数据及方法挂载完成 beforeMount Function 开始挂载已经编译完成的cml到对应的节点时 mounted Function cml模板编译完成,且渲染到dom中完成 beforeDestroy Function 实例销毁之前 destroyed Function 实例销毁后 组件间的通信 组件间的通信方式有以下几种： 父组件 -> 子组件： props传递 代码示例 class Index { data = { parent:{msg:'this is parent message'} } } export default new Index(); {{parentProp.msg}} class ComponentTagName { props = { parentProp:{ type:Object, default:{} } } } export default new ComponentTagName(); 子组件 -> 父组件：事件通讯 参考 代码示例 class Index { methods = { handleParentEvent(...args){ console.log(...args) } } } export default new Index(); class ComponentTagName { methods = { handleClick(){ this.$emit('parentevent',{ value:'this is from child' }) } } } export default new ComponentTagName(); "},"framework/settings.html":{"url":"framework/settings.html","title":"配置","keywords":"","body":"配置(Configure) 针对项目、组件、路由等的特定配置，以满足各种方式的需求。 组件配置 组件基础配置及各端差异配置，包括组件引入等。 路由配置 项目统一路由配置。 工程配置 不同端、不同模式的差异化构建配置。 "},"framework/json.html":{"url":"framework/json.html","title":"组件配置","keywords":"","body":"组件配置 组件的配置以json对象的格式配置在.cml文件中，结构如下： { \"base\":{ \"usingComponents\": { \"navi\": \"/components/navi/navi\", \"c-cell\": \"/components/c-cell/c-cell\", \"c-list\": \"/components/c-list/c-list\", \"navi-npm\": \"cml-test-ui/navi/navi\" } }, \"wx\": { }, \"alipay\": { }, \"baidu\": { }, \"web\": { }, \"weex\": { } } base 对象为各端共用的配置对象。 wx、web、weex分别对应三端特有的配置对象，base的配置会应用到每一端的配置，内部做的merge。 usingComponents字段是目前最重要的配置，各端都会使用，小程序规定页面的json文件中配置使用到的组件。web和weex端的构建时也是根据该字段去找到相应的组件进行自动化的注册。所以用到组件必须进行配置 usingComponents中组件的引用地址。 支持引用src和node_modules下的组件，地址禁止包含后缀扩展名： src下可以写相对路径，也可以写相对于src的绝对路径，例如/components/**, node_modules下的组件，不需要写node_modules，直接从npm的包名称开始写例如cml-test-ui/navi/navi。 引用的组件类型支持： .cml扩展名跨端组件 .vue扩展名的vue、weex组件，仅在多态组件可用 小程序组件文件夹路径，仅在多态组件可用 .js扩展名的react组件，仅在多态组件可用 \b小程序端所需要的一些配置，写在各自的特有配置对象中 "},"framework/router.html":{"url":"framework/router.html","title":"路由配置","keywords":"","body":"路由管理 chameleon项目内置了一套各端统一的路由管理方式。 路由配置文件 src/router.config.json是路由的配置文件,内容如下： { \"mode\": \"history\", \"domain\": \"https://www.chameleon.com\", \"routes\":[ { \"url\": \"/cml/h5/index\", \"path\": \"/pages/index/index\", \"mock\": \"index.php\" } ] } mode 为web端路由模式，分为hash或history。 domain 为web端地址的域名。 routes 为路由配置 path为路由对应的cml文件的路径,以src目录下开始的绝对路径，以/开头。 url为web端的访问路径 mock为该路由对应的mock文件(仅模拟模板下发需要) 小程序端，构建时会将router.config.json的内容，插入到app.json的pages字段，实现小程序端的路由。 使用路由场景 应用内路由 跨应用路由 "},"framework/config.html":{"url":"framework/config.html","title":"工程配置","keywords":"","body":"项目配置 本文档描述了项目配置的全部参数及使用方法。 配置一览表 项目全局配置 字段名 类型 可选值 说明 备注 templateType String html[默认]、smarty web端构建出的页面文件类型 projectName String - web端构建出的页面文件名称 templateLang String cml[默认]、vue 视图层模版语法 两种语法不可混用 platforms Array[String] ['web','weex','wx','alipay','baidu'] 当前项目支持端配置 devOffPlatform Array[String] ['web','weex','wx','alipay','baidu'] dev模式下关闭部分端构建 buildOffPlatform Array[String] ['web','weex','wx','alipay','baidu'] build模式下关闭部分端构建 enableLinter Boolean true[默认]、false 是否开启chameleon的语法检查 check Object - 多态校验控制 check.enable Boolean true[默认]、false 是否开启多态语法校验 check.enableTypes Array[String] ['Object','Array','Nullable'] Object表示多态协议中传递数据为对象时不校验内部具体数据，Array表示多态协议中传递数据为数组时不校验内部具体数据，Nullable表示某些参数不是必传 谨慎使用，确定的输入数据结构会提高代码维护性！ enableGlobalCheck Boolean true、false 是否开启全局变量校验 globalCheckWhiteList Array[String|RegExp] - 文件校验白名单，配置后可不校验改文件 devPort Number 8000[默认] dev模式启动的web服务端口，默认从8000开始查找空闲端口 excludeBablePath Array[String|RegExp] - 配置babel-loader不处理文件 babelPath Array[String|RegExp] - 配置babel-loader处理文件 cmss Object - cml相关配置，仅web端有效 cmss.rem Boolean true[默认]、false 样式单位是否编译为rem cmss.scale Number 0.5[默认] cmss.rem为false时有效，尺寸换算规则 cpx * cmss.scale = px baseStyle Object - 禁用基础样式 baseStyle[platform] Boolean true、false 禁用该端基础样式，platfrom为：web|weex|wx|alipay|baidu baseStyle.web为false时不插入web端基础样式，其他端同理 cmlComponents Array[String] ['cml-ui'] 全局自动引入组件库 当设置该项之后可以直接使用改库下所有组件，无需手动引入 平台内构建配置 平台内构建配置是针对某一端执行命令构建时的特殊配置 字段名 类型 可选值 说明 备注 publicPath String - 静态资源发布路径 设置该字段执行构建时静态资源地址将改为该地址 apiPrefix String - 接口请求地址地址 设置该字段调用请求时如果请求路径不是全路径则拼接该地址 hash Boolean true[build默认]、false[dev默认] 构建出的文件名是否带hash 用于更新浏览器缓存 minimize Boolean true[build默认]、false[dev默认] 构建出的文件是否进行代码压缩 hot Boolean true[默认]、false 控制是否开启热更新 web端有效 analysis Boolean true[默认]、false 是否\b打开webpack打包分析工具 console Boolean false[默认]、true 控制是否打开页面上的调试窗口 web端有效 definePlugin Object - 定义运行时内部变量 moduleIdType String number、hash、name 设置webpack打包模块的id类型 babelPolyfill Boolean 默认 false 是否添加polyfill web、weex端@babel/polyfill 小程序端miniapp_polyfill 配置文件 chameleon的构建过程是配置化的，项目的根目录下提供一个chameleon.config.js文件，在该文件中可以使用全局对象cml的api去操作配置对象。例如： // 设置静态资源的线上路径 const publicPath = '//www.static.chameleon.com/static'; // 设置api请求前缀 const apiPrefix = 'https://api.chameleon.com'; // 合并配置 cml.config.merge({ templateType: 'html', projectName: 'Chameleon', base: { dev: { domain1: 'localhost', domain2: 'localhost' }, build: { domain1: 'http://www.cml1.com', domain1: 'http://www.cml2.com', } }, web: { dev: { hot: true, console: true }, build: { publicPath: `${publicPath}/web`, apiPrefix } } }) 配置api cml.config.merge(obj) merge方式修改配置。 cml.config.assign(obj) assign方式修改配置 cml.config.get() 获取config配置 配置对象结构 配置对象的第一级为全局配置，例如projectName,全局配置中有各平台内的配置对象，例如web、wx、weex等。其中base对象用于配置各个平台对象的公共部分。 平台对象内部分为各media的配置对象，例如dev、build。 配置详解 下面就详细介绍配置中的功能。 web端页面文件\b类型 templateType, String 类型。该字段控制web端构建\b出的页面文件类型。 templateType: 'html' 构建出.html文件，纯前端模板 templateType: 'smarty' 构建出.tpl文件 例如： cml.config.merge({ templateType: 'html' }); web端页面文件名称 projectName, String 类型。 该字段控制web端构建\b出的模板文件名称，默认是当前项目的根目录文件夹名称。 例如： cml.config.merge({ projectName: '\btest_cml', templateType: 'html' }) web端构建出 test_cml.html文件 模板语法 templateLang, String 类型。chameleon的视图层支持两种模板语法，通过在template\b\b上的lang属性做区分，如果不写默认是cml语法。该字段控制init page 和init component\b 时生成的cml文件的template模板上的lang属性。例如： cml.config.merge({ templateLang: '\bcml' }); 支持端配置 platforms, Array[String]类型。 \b配置当前项目支持的\b端，该配置决定cml dev和cml build命令启动构建的端，决定cml init命令初始化多态接口和多态组件时只生成相应端代码。 例如： cml.config.merge({ platforms: ['web','wx'], }); cml dev和cml build只启动web和wx端的构建。 关闭某一端构建 devOffPlatform和buildOffPlatform, Array[String] 类型。 \b当我们执行cml dev 和 cml build 时会自动构建输出\b所有平台的代码，可以通过这两个字段控制不需要构建的平台，目前支持取值[\"web\",\"wx\",\"weex\"]。 例如： cml.config.merge({ devOffPlatform: ['wx'], buildOffPlatform: ['wx'] }); 语法检查 enableLinter, Boolean \b类型。 默认为 true，是否开启chameleon的语法检查，会在命令行提示语法错误。 例如： cml.config.merge({ enableLinter: false }) 多态校验控制 check, Object 类型。 chameleon提供了接口多态与组件多态的写法，同时为了保证代码的质量提供了多态校验的方法，可以通过check字段进行校验的控制。 check.enable, Boolean 类型。 控制是否开启多态校验，默认true。 check.enableTypes, Array[String] 类型。 \b可取值[\"Object\",\"Array\",\"Nullable\"],控制校验中是否可以定义直接定义Object和Array类型，和\b是否可以定义可为空类型,默认值为[]。 例如： cml.config.merge({ check: { enable: true, enableTypes: [\"Object\",\"Array\",\"Nullable\"] } }); 全局变量校验 enableGlobalCheck, Boolean 类型。默认是false,(chameleon-tool 0.2.0版本及之后默认为true)，控制是否进行全局变量的检验。 例如： cml.config.merge({ enableGlobalCheck: true }); 全局变量校验白名单 globalCheckWhiteList, Array[String|RegExp] 类型。 chameleon内置了全局变量校验的功能 可以设置白名单不校验某些文件。以文件绝对路径进行匹配，可以是正则表达式径，也可以是字符串的endWiths。 例如： cml.config.merge({ globalCheckWhiteList: ['jquery.js',/node_modules/] }); 则所有以 jquery.js 结尾的文件以及 正则匹配 /node_modules/ 的不做校验； dev服务端口 devPort, Number 类型。 dev模式启动的web服务端口，默认是从8000开始寻找空闲端口，避免了启动多个项目时的端口冲突问题。如果想指定端口可以使用该参数进行配置。 例如： cml.config.merge({ devPort: 8080 }); 配置babel-loader不处理的文件 excludeBablePath, Array[String|RegExp] 类型。 const path = require('path'); cml.config.merge({ excludeBablePath:[/test-exclude/,path.resolve(__dirname,'./src/excludes')], }) 这个配置的结果会作为webpack模块配置中 Rule.exclude的值； 配置babel-loader处理的文件 babelPath, Array[String|RegExp] 类型。 默认开发者引入的node_modules中的文件不经过babel，如有文件需要babel，设置该参数。 const path = require('path'); cml.config.merge({ babelPath:[path.resolve(__dirname,'node_modules/test/')], }) 这个配置的结果会作为webpack模块配置中 Rule.include的值； cmss处理 cmss，Object类型。 仅用于web端。其中包含rem及scale属性，web端构建时默认将cpx\b转为rem，当不需要时转为rem时，将rem置为false，则scale参数生效，scale为像素缩放倍数，默认为1，会将cpx按照scale的设置进行缩放为px。例如： cml.config.merge({ cmss: { rem: false, scale: 0.5 } }); 该设置web端cpx不转为rem，而缩小1倍转为px，例如10cpx转为5px。 禁用基础样式 baseStyle， Object类型。 chameleon为了让各端样式统一，默认会在全局插入一些基础样式，如果开发者的跨端不需要这些基础样式，可以通过该参数进行设置。key值为端名称，value为Boolean值，是否插入\b基础样式。例如： cml.config.merge({ baseStyle: { web: false, wx: false, weex: false }, }); 该设置web、wx、weex端均不插入基础样式。 全局引用npm组件库 cmlComponents, Array[String] 类型。 当我们想把npm组件库中的组件全部自动引入，而不需要单独引入时，可以通过该字段配置npm包名称。例如 cml-ui是我们提供的一个npm组件库，可以进行如下配置： cml.config.merge({ cmlComponents: ['cml-ui'] }); npm组件库的package.json\b中的main字段可以指定路径，否则就会查找\bnpm包中的所有cml文件自动引入，自动引入的组件名称为cml文件名称。 构建结果信息 buildInfo, Object 类型。 buildInfo.wxAppId,String 类型。微信的appId。 当执行完cml build后会生成一个config.json\b文件，该文件存储构建后各平台的页面信息。可以通过这个json文件做页面的动态下发，页面降级等等。 例如： cml.config.merge({ buildInfo: { wxAppId: '123456' } }); cml build 后生成\b在dist/config.json { \"wx\": { \"appId\": \"123456\", \"path\": \"/pages/index/index\" }, \"web\": { \"url\": \"https://api.chameleon.com/cml/h5/index\" }, \"weex\": { \"url\": \"https://static.chameleon.com/pinche/hkcml/weex/hybridkits_pageone_e86b77ae05a015a3a546.js\", \"query\": { \"path\": \"/pages/index/index\" } } } config.json中微信小程序的appId是\b通过buildInfo配置生成，其他的页面信息是根据router.config.json中的配置生成。 例如： cml.config.merge({ enableLinter: false }); 构建入口与页面\b 默认的入口与页面集成在脚手架中，对于有特殊\b需求的开发者，chameleon提供了可以自定义web端构建入口与页面，weex端构建入口的功能。 entry, Object \b类型。 entry.template, String 类型。 页面文件的绝对路径。 entry.web, String 类型。 web端入口文件的\b绝对路径。 entry.weex, String 类型。 wewx端入口文件的\b绝对路径。 例如： var path = require('path'); cml.config.merge({ entry: { template: path.resolve('./src/index.html') web: path.resolve('./src/mian.web.js') weex: path.resolve('./src/main.weex.js') } }) 平台内配置 \b每一个平台的构建会需要不同的配置，所以针对每一个平台会有一个平台配置对象，平台配置对象中又有多个media配置对象，例如dev或者build的配置。\b下面讲述的配置项都是放在media对象中。例如： wx web weex是平台对象，里面的dev和build是media对象。 cml.config.merge({ wx: { dev: {}, build: {} }, web: { dev: {}, build: {} }, weex: { dev: {}, build: {} } }); 文件指纹 文件指纹是文件的唯一标识，以文件的内容生成hash值作为文件名称的一部分。在开启强缓存的情况下，如果文件的 URL 不发生变化，无法刷新浏览器缓存。文件指纹\b\b用于更新浏览器的缓存。小程序端不需要文件指纹。 默认图片资源\b开启hash，build模式开启hash。\b通过hash字段配置。 hash, Boolean 类型。 \b控制打包出的js和css文件是否带hash后缀，图片字体等静态资源自动带hash，其小程序端不支持hash参数。 例如： cml.config.merge({ web: { dev: { hash: true } } }) 下图为web端开启文件指纹的打包结果。 代码压缩 为了减少资源网络传输的大小，通过压缩器对 js、css、图片进行压缩是一直以来前端工程优化的选择。在chameleon中只需要\b配置minimize参数。 minimize, Boolean 类型。 \b\b控制打包出的文件是否进行压缩。 例如： cml.config.merge({ web: { dev: { minimize: true } } }); 资源发布路径 publicPath, String 类型。 \b\b控制代码中静态资源的引用路径，\b线上发布需要用到，media为dev时默认 小程序端是本地路径，web和weex端是当前dev服务的\b路径。 例如： cml.config.merge({ web: { build: { publicPath: \"http://www.chameleon.com/static\" } } }); 热更新与自动刷新 热更新与自动刷新都是提高本地开发效率的手段，当项目中的源代码发生改变时，\b能够自动的在页面看到改变，其中热更新不需要重新刷新预览的页面。目前只有web端的开发支持热更新，通过hot参数配置。 dev模式默认自动刷新，web端可以选择开启热更新。 hot, Boolean 类型。 控制是否开启热更新，只在web端生效，开启热更新时，css代码不会单独分离出来，如果进行线上js代理本地js调试问题时，请关闭热更新。 例如： cml.config.merge({ web: { dev: { hot: true } } }); 打包资源分析 analysis, Boolean类型。 控制是否\b打开webpack打包分析工具， 内部使用的webpack-bundle-analyzer插件。 例如： cml.config.merge({ web: { dev: { analysis: true } } }); 调试窗口 console, Boolean类型。 控制是否打开页面上的调试窗口，只在web端有效，方便在真机上进行调试。 例如： cml.config.merge({ web: { dev: { console: true } } }) \b\b内置变量 definePlugin, Object类型，内部使用webpack.DefinePlugin实现，定义运行时的内置变量。 例如： cml.config.merge({ web: { dev: { definePlugin: { 'process.env.TEST': JSON.stringify('CML_TEST') } } } }) \b\bapi请求前缀 apiPrefix, String类型。 这个配置与网络请求相关，在wx和weex项目中，ajax的请求不能像web端一样只写相对路径，而是要写带有域名的绝对路径，chameleon-api 这个基础库，提供了网络请求的api，get、post、request方法，该方法会在运行时将请求的相对路径上添加配置的apiPrefix。media是dev时 默认为当前dev服务的地址,不需要配置。 例如： chameleon.config.js // 设置api请求前缀 const apiPrefix = 'http://api.chameleon.com'; cml.config.merge({ wx: { dev: { }, build: { apiPrefix } } }) import cml from 'chameleon-api' class Index { methods = { sendGet() { cml.get({ url: '/api/driver/getList', data: { name: 'cml', age: 18 } }).then(res=>{ console.log(res) }).catch(e=>{ console.log(e) }) } } }; export default new Index(); 在执行cml wx dev命令构建的结果中，cml.get方法发送的请求是http://172.22.137.29:8000/api/driver/getList 在执行cml wx build命令构建的结果中，cml.get方法发送的请求是http://api.chameleon.com/api/driver/getList 模块标识类型 moduleIdType,String类型。 设置webpack打包模块的id类型。 number 顺序排列的数组下标。 hash 利用 webpack.HashedModuleIdsPlugin() 模块的id类型为模块内容的hash值。 name 利用webpack.NamedModulesPlugin() 模块的id类型为文件的路径。 chameleon 用于build模式，模块的id类型为模块内容的hash，并且最终文件的hash\b也经过优化处理，根据文件内容绝对hash值。 默认media为dev时 取值\b为name 方便开发调试， media为build时取值为chameleon 保证hash值由文件内容决定，更好的做缓存持久化。 例如： cml.config.merge({ web: { dev: { moduleIdType: \"number\" } } }) babelPolyfill chameleon-tool@0.0.15开始支持 web端 chameleon-tool@0.3.0-alpha.1 开始支持weex 各小程序端 babelPolyfill, Boolean 类型, 默认 false。 一些es6+的语法，babel不会转义，例如Object.sssign、Object.entries等方法, 如果客户端运行环境不支持这些语法就会出错。其中web和weex端使用的是@babel/polyfill, 小程序端使用的是自写的一些方法的polyfill，参见miniapp_polyfill。 注意添加polyfill后会增加一些文件体积。 例如： cml.config.merge({ base: { dev: { babelPolyfill: true }, build: { babelPolyfill: true } } }) domain 多域名请求前缀 chameleon-tool@0.2.0-alpha.0 chameleon-api@0.3.0-alpha.4 开始支持 domain, Object 类型。 一般配置在base对象中，作为所有平台的公共配置，dev模式中配置的localhost会替换成当前dev模式启动的web服务ip+端口。 具体使用文档参见api多域名mock 例如： cml.config.merge({ base: { dev: { domain: { domain1: \"localhost\", domain2: \"localhost\" }, }, build: { domain: { domain1: \"http://api.cml.com\", domain2: \"http://api2.cml.com\" }, } }, }) 自定义构建配置 如果我们需要多套构建配置，可以自定义一个media，比如设置weex.custom 对象，然后执行cml weex custom即可使用你设置的custom配置进行构建，但是不会启动dev服务和watch。 例如： cml.config.merge({ weex: { custom: { minimize: true, moduleIdType: \"number\" } } }) 组件导出配置 组件导出相关的配置请参见组件导出介绍。 修改webpack配置 在chameleon.config.js中可以通过api获取到构建之前的webpack配置并对其进行修改。使用方式： cml.utils.plugin('webpackConfig', function({ type, media, webpackConfig }, cb) { // cb函数用于设置修改后的配置 cb({ type, media, webpackConfig }); }); "},"component/component.html":{"url":"component/component.html","title":"组件","keywords":"","body":"组件(Component) 框架 提供了大量内置组件和扩展组件，抹平多端差异，便于开发者通过组合这些组件，创建出强大的应用程序。 内置组件 扩展组件 "},"component/base/base.html":{"url":"component/base/base.html","title":"内置组件","keywords":"","body":"内置组件(Built-in components) 内置组件不需要额外引入，框架会依据使用的组件按需加载。 基础内容 布局容器 表单组件 媒体组件 注：内置组件会整合各端组件共有属性，如需要使用某一端特有组件，请从业务出发使用 组件多态差异化实现功能。 "},"component/base/content/view.html":{"url":"component/base/content/view.html","title":"基础内容","keywords":"","body":"view 视图容器。 类似web端的div块级元素标签。 示例 class View { }; export default new View(); .flex-item { width: 200cpx; height: 300cpx; background-color: #81c0c0; } { \"base\": {} } wx web native Bug & Tip 如果需要使用滚动视图，请使用 scroller 包裹 查看完整示例 "},"component/base/content/cover-view.html":{"url":"component/base/content/cover-view.html","title":"cover-view","keywords":"","body":"cover-view 覆盖在原生组件之上的文本视图。 cover-view 标签在各端的映射如下 cml web weex wx alipay baidu cover-view div div cover-view cover-view cover-view 示例 web/weex端渲染结果 微信/支付宝/百度渲染结果 "},"component/base/content/text.html":{"url":"component/base/content/text.html","title":"text","keywords":"","body":"text 文本容器。 按照指定的样式渲染文本内容。 示例 Original message: {{ message }} Computed reversed message: {{ reversedMessage }} class Text { data = { message: 'Hello' } computed = { reversedMessage: function () { return this.message.split('').reverse().join('') } } }; export default new Text(); { \"base\": {} } Bug & Tip 会保留文本头尾空白（空格、换行符等），若发现文本内容位置不符合预期，大概率是写成下面格式了： 我是有空格和换行符的文本 不支持子组件。 只能包含文本值，使用 双花括号 标记可以将变量值作为文本内容 查看完整示例 "},"component/base/content/page.html":{"url":"component/base/content/page.html","title":"page","keywords":"","body":"page 含titleBar基础页面容器 内置了weex端titleBar以及多端修改页面标题方法，titleBar为固定高度88cpx。 属性 属性名 类型 必填 默认值 说明 title String 是 titleBar所显示标题内容 c-bind:back EventHandle 否 点击返回时触发 slot 插槽名 作用 —— 页面内容 titlebar 自定义titlebar，自定义时需保证高度为88cpx，仅weex端可用 menu 自定义菜单，仅weex端可用 示例 这是页面内容 import cml from 'chameleon-api' class Page { methods = { goback() { cml.showToast({ message: 'goback' }) } } } export default new Page(); .main { color: red; } { \"base\": {} } Bug & Tip 组件为页面级基础容器组件，只能在页面组件中使用，在普通组件中使用不能保证正确显示，使用时需位于页面组件根结点位置。 组件在weex端titlebar高度为88cpx，在使用定位时注意兼容。 组件内置weex端titlebar仅能满足常规使用，若需要复杂的titlebar则可通过titlebar插槽实现。 由于android和ios页面渲染差异，android端是从状态栏以下开始渲染，而ios是从状态栏开始渲染页面，所以在ios端需要考虑状态栏高度 查看更多示例 "},"component/base/content/block.html":{"url":"component/base/content/block.html","title":"block","keywords":"","body":"block 包装容器 内置组件是一个包装容器，只接受控制属性，不会渲染在页面中 示例 chameleon block class Block { data = { show: true } methods = { clickHandle() { this.show = !this.show; } } } export default new Block(); .container { align-items: center; } { \"base\": {} } "},"component/base/content/cell.html":{"url":"component/base/content/cell.html","title":"cell","keywords":"","body":"cell 子列表项容器。 类似 web端的 li 元素标签，作为列表容器的子列表项。 示例 1 class Cell { } export default new Cell(); { \"base\": {} } Bug & Tip 的宽度等于父组件 的宽度，并且 高度会自适应，指定 margin 样式无效 查看完整示例 "},"component/base/layout/scroller.html":{"url":"component/base/layout/scroller.html","title":"布局容器","keywords":"","body":"scroller 可滚动视图区域。 可容纳排成一列的子组件的滚动器。 属性 属性名 类型 必填 默认值 说明 cstyle String 否 自定义组件内联样式 height Number scroll-direction为`vertical`时必传 无 定义纵向滚动区域的高度 注意： 1、 height=\"{{100}}\" /> 这样传值才是Number类型 2、height为-1时，的可滚动区域高度为scroller放置点至页面底部 width Number scroll-direction为`horizontal`时必传 无 定义横向滚动区域的宽度 注意： height为-1时，填充页面剩余宽度 scroll-direction String 否 vertical 定义滚动的方向。可选为 horizontal 或者 vertical bottom-offset Number 否 0 距底部/右边多远时（单位cpx），触发 onBottom 事件 scroll-top Number 否 0 scroll-direction为`vertical`时，设置滚动到的位置，（单位cpx） scroll-left Number 否 0 scroll-direction为`horizontal`时，设置滚动到的位置，（单位cpx） bounce Boolean 否 true 上拉下拉是否回弹(仅支持web) c-bind:scrolltobottom EventHandle 否 滚动到底部，会触发 scrolltobottom 事件 返回事件对象： event.type= \"scrolltobottom\" event.detail = { direction } c-bind:onscroll EventHandle 否 滚动时触发， 返回事件对象： event.type = 'scroll' event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 限制 不允许相同方向的 或者 互相嵌套，换句话说就是嵌套的 / 必须是不同的方向。 举个例子，不允许一个垂直方向的 嵌套的一个垂直方向的 中，但是一个垂直方向的 是可以嵌套的一个水平方向的 或者 中的。 示例 {{item.label}} class Scroller { data = { /** * scroller 配置 */ bottomOffset: 20, scrollDirection: 'vertical', panels: [ ], rows: [] } methods = { change (e) { let target = e.currentTarget let dataset = target.dataset let i = dataset.idx const item = this.panels[i] if (item) { item.height = item.height === 200 ? 400 : 200 item.width = item.width === 330 ? 730 : 330 item.computedStyle = this.$cmlStyle(`height:${item.height}cpx;width:${item.width}cpx;background-color:${item.bgc};opacity:${item.opacity}`) } }, randomfn () { let ary = []; for(let i = 1; i .container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .title { text-align: center; flex-direction: row; justify-content: center; } .panel { display: flex; margin: 10cpx; top:10cpx; align-items: center; justify-content: center; text-align: center; border: 1px solid #666; border-radius: 10cpx; transition-property: width,height; transition-duration: 0.5s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); } .cell{ display: flex; background-color:white; flex-direction: row; } .text { font-size: 60cpx; color: white; } { \"base\": {} } wx web native Bug & Tip 使用竖向滚动时，需要有一个固定高度。 如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 可以当作根元素或者嵌套元素使用。 中不可以使用 、 组件。 中不建议在上面加class改变样式，可以通过cstyle属性传入内联样式。 的子组件定位无效。 "},"component/base/layout/list.html":{"url":"component/base/layout/list.html","title":"list","keywords":"","body":"list 可滚动长列表。 标签内可包含多条 ，适合用于长列表的展示。 使用文档 cell。 属性 属性名 类型 必填 默认值 说明 cstyle String 否 自定义组件内联样式 height Number 必传 无 定义滚动区域的高度 注意： 1、 height=\"{{100}}\" /> 这样传值才是Number类型 2、height为-1时， 的可滚动区域高度为list放置点至页面底部 bottom-offset Number 否 0 距底部/右边多远时（单位cpx），触发 onBottom 事件 to-element String 否 滚动到的元素，仅支持ref(web、weex端) bounce Boolean 否 true 上拉下拉是否回弹(仅支持web) c-bind:scrolltobottom EventHandle 否 滚动到底部，会触发 scrolltobottom 事件 返回事件对象： event.type= \"scrolltobottom\" event.detail = { direction } c-bind:onscroll EventHandle 否 滚动时触发， 返回事件对象： event.type = 'scroll' event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 限制 不允许相同方向的 或者 互相嵌套，换句话说就是嵌套的 / 必须是不同的方向。 举个例子，不允许一个垂直方向的 嵌套的一个垂直方向的 中，但是一个垂直方向的 是可以嵌套的一个水平方向的 list 或者 中的。 示例 {{item}} import cml from 'chameleon-api' const LOADMORE_COUNT = 4 class List { data = { /** * list 配置 子元素必须是 cell 标签 */ bottomOffset: 20, lists: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] } methods = { onBottom(e) { cml.showToast({ message: \"loadmore\", duration: 1000 }); setTimeout(() => { const length = this.lists.length for (let i = length; i .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .panel { display: flex; width: 600cpx; height: 300cpx; margin-left: 75cpx; margin-top: 35cpx; margin-bottom: 35cpx; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); } .text { font-size: 88cpx; text-align: center; color: #41B883; } { \"base\": {} } wx web native Bug & Tip 组件的父容器必须为可定位元素， 内容的布局由父容器决定。 中不可以使用 、 组件。 中不建议在上加class改变样式，可以通过cstyle属性传入内联样式。 的子组件定位无效。 "},"component/base/layout/container.html":{"url":"component/base/layout/container.html","title":"container","keywords":"","body":"container 属性 属性名 类型 必填 默认值 说明 direction String 否 'row' container内布局组件的排列方式，默认是水平（row),可取值为 \b'row'或者 'column' main 属性名 类型 必填 默认值 说明 main-style String 否 '' 容器的样式 head 属性名 类型 必填 默认值 说明 head-style String 否 '' 容器的样式 foot 属性名 类型 必填 默认值 说明 foot-style String 否 '' 容器的样式 aside 属性名 类型 必填 默认值 说明 aside-style String 否 '' 容器的样式 示例 header main header main footer aside main header aside main header aside main foot aside header main aside header main footer class CLayout { } export default new CLayout(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/layout/row.html":{"url":"component/base/layout/row.html","title":"row","keywords":"","body":"row 横向flex布局容器 是提供横向flex布局的容器，与 组件（提供纵向flex布局）结合使用，可快速构建整洁干净的flex布局效果。 row属性 属性名 类型 必填 默认值 说明 justify String 否 center 横向对齐方式，可选值包括：start/end/center/space-around/space-between align String 否 middle 纵向对齐方式，可选值包括：top/middle/bottom height Number 否 0 容器高度，值为0时容器高度由内部元素高度决定 wrap Boolean 否 false 是否支持换行 margin Number 否 0 容器上下间隔（单位cpx） 示例 class Row { } export default new Row(); { \"base\": {} } wx web native 查看完整示例 Bug & Tip 组件内部不一定要使用组件，可使用任何需要布局的容器或组件。 如果 组件内部不使用组件，需要自行设置内部的宽高等属性。 如果 组件内部使用组件，需要将组件设置为 组件的直接子节点。 和 组件组合使用类似栅格布局， 和 组件只能相互嵌套。 建议使用高度属性设置组件高度，而非使用css控制，否则垂直居中的样式可能会受到影响。 "},"component/base/layout/col.html":{"url":"component/base/layout/col.html","title":"col","keywords":"","body":"col 纵向flex布局容器 与 组件结合使用，可快速构建整洁干净的flex布局。 属性 属性名 类型 必填 默认值 说明 width Number 否 0 容器宽度，值为0时容器宽度由内部元素宽度决定 height Number 否 0 容器高度，值为0时容器高度由内部元素高度决定 background-color String 否 容器背景色 margin Number 否 0 容器左右间隔（单位cpx） 示例 class Col { } export default new Col(); .col-item { background: #aaa; width:200cpx; height:100cpx; } { \"base\": {} } wx web native 查看完整示例 "},"component/base/layout/carousel.html":{"url":"component/base/layout/carousel.html","title":"carousel","keywords":"","body":"carousel 轮播图。 标签内可包含多条 ，适合轮播图展示。 属性 属性名 类型 默认值 说明 autoplay Boolean false 是否自动切换 current Number 0 当前所在滑块的索引值 interval Number 5000 自动切换的时间间隔 circular Boolean false 是否采用衔接滑动 indicator-dots Boolean false 是否显示面板指示点 indicator-color Color #cccccc 指示点颜色 indicator-active-color Color #000000 当前选中的指示点颜色 change EventHandle current 改变时会触发 change 事件，event.detail = {current: activeIndex} 示例 carousel class Carousel {} export default new Carousel(); .container { height: 300cpx; } .carousel-item { height: 300cpx; width: 750cpx; } { \"base\": { \"usingComponents\": {} } } wx web native Bug & Tip 如需兼容安卓端，carousel需要有一个固定高度。 如果希望修改current值时轮播滚动到对应carousel-item，则需要通过change事件同步current，以保证修改current的值与当前的值是不同的。 "},"component/base/layout/carousel-item.html":{"url":"component/base/layout/carousel-item.html","title":"carousel-item","keywords":"","body":"carousel-item 轮播图子容器 仅可放置在组件中使用，使用文档请查看 carousel。 属性 无 "},"component/base/form/button.html":{"url":"component/base/form/button.html","title":"表单组件","keywords":"","body":"button 按钮 属性 属性名 类型 必填 默认值 说明 text String 否 无 按钮文案，优先级高于 slot 属性，注意：默认button内容为空 size String 否 stretch 按钮尺寸,可选值：stretch、auto、full、big、medium、small，注：stretch 代表依据父容器全撑开、auto 代表依据button内容宽度自适应 width Number 否 无 自定义按钮宽度，单位为 cpx，优先级高于 size 属性 注意：类型是 Number type String 否 \"blue\" 按钮颜色,可选值：red、orange、blue、white、green disabled Boolean 否 false 是否禁用 btn-style String 否 自定义button的样式，如 \"background-color:blue;height:100cpx;\" text-style String 否 自定义按钮text的样式，如 \"color:red;text-align:center;\" disabled-style String 否 定义button disabled的样式，如 \"background-color:grew;\" text-style-disabled String 否 定义button disabled时text的样式，如 \"color:white;\" btn-hover-style String 否 指定按钮按下去的效果样式，如 \"background-color:pink;\" text-hover-style String 否 指定按钮按下去的text样式，如 \"color:pink;\" slot 否 置于button里的插槽，可自由定义 c-bind:onclick EventHandle 否 button 点击事件 返回事件对象： event.type= \"onclick\" event.detail = { type, disabled } open-type String 否 微信开放能力，只支持wx端 lang String 否 \"en\" 指定返回用户信息的语言，有效值：zh_CN 简体中文，zh_TW 繁体中文，en 英文 open-type=\"getUserInfo\"时生效 c-bind:getuserinfo Handler 否 用户点击该按钮时，会返回获取到的用户信息 open-type=\"getUserInfo\"时生效 session-from String 否 会话来源 open-type=\"contact\"时生效 send-message-title String 否 \"当前标题\" 会话内消息卡片标题 open-type=\"contact\"时生效 send-message-path String 否 \"当前分享路径\" 会话内消息卡片点击跳转小程序路径 open-type=\"contact\"时生效 send-message-img String 否 截图 会话内消息卡片图片 open-type=\"contact\"时生效 show-message-card Boolean 否 false 是否显示会话内消息卡片 open-type=\"contact\"时生效 c-bind:contact Handler 否 客服消息回调 open-type=\"contact\"时生效 c-bind:getphonenumber Handler 否 获取用户手机号回调 open-type=\"getPhoneNumber\"时生效 app-parameter String 否 打开APP时，向APP传递的参数 open-type=\"launchApp\"时生效 c-bind:error Handler 否 当使用开放能力时，发生错误的回调 open-type=\"launchApp\"时生效 c-bind:opensetting Handler 否 在打开授权设置页后回调 open-type=\"openSetting\"时生效 --> 值 说明 contact 打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 c-bind:contact 回调中获取到用户所点消息的页面路径 path 和对应的参数 query share 触发用户转发 getUserInfo 获取用户信息，可以从c-bind:getuserinfo回调中获取到用户信息 getPhoneNumber 获取用户手机号，可以从c-bind:getphonenumber回调中获取到微信服务器返回的加密数据 launchApp 打开APP，可以通过app-parameter属性设定向APP传的参数，通过 c-bind:error 可以监听打开 APP 的错误事件 openSetting 打开授权设置页 feedback 打开“意见反馈”页面 --> 示例 import cml from 'chameleon-api' class Button { methods = { testclick(e) { let type = e.detail.type cml.showToast({ message: type + ' button' }) } } } export default new Button(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/form/input.html":{"url":"component/base/form/input.html","title":"input","keywords":"","body":"input 输入框 属性 属性名 类型 必填 默认值 说明 cstyle String 否 自定义样式,如 \"color:red;text-align:center;\" value String 否 输入框的初始内容 type String 否 \"text\" 输入框的类型 placeholder String 否 提示用户输入的内容 disabled Boolean 否 false 是否禁用 focus Boolean 否 false 获取焦点（web端不支持） maxlength Number 否 140 最大输入长度 return-key-type String 否 \"done\" 设置键盘右下角按钮的文字（web端不支持） placer-holder-color String 否 \"#bebebe\" 指定placeholder的颜色（web端不支持） maxValue Number 否 Infinity 最大值 仅对type=\"number\"生效 minValue Number 否 -Infinity 最小值 仅对type=\"number\"生效 c-bind:input EventHandle 否 键盘输入时触发 返回事件对象： event.type=\"input\", event.detail={value} c-bind:confirm EventHandle 否 点击完成按钮时触发 返回事件对象： event.type=\"confirm\", event.detail c-bind:focus EventHandle 否 输入框获取焦点时触发 返回事件对象： event.type=\"focus\", event.detail c-bind:blur EventHandle 否 输入框失去焦点时触发 返回事件对象： event.type=\"blur\" event.detail type 的有效值： 值 说明 text 文本类型的输入 password 密码类型的输入 number 数字类型的输入 return-key-type 的有效值： 值 说明 done 右下角按钮为“完成” search 右下角按钮为“搜索” next 右下角按钮为“下一个” go 右下角按钮为“前往” 示例 class Input { data = { isfocus: false } computed = {} watch = {} methods = { bindblurevent() { console.log('blur'); this.isfocus = false; } } mounted = function(res) { setTimeout(() => { this.isfocus = true; }, 300); } }; export default new Input(); { \"base\": {} } wx web native 查看完整示例 Bug & Tip web端不支持自动focus return-key-type字段web端不支持 "},"component/base/form/textarea.html":{"url":"component/base/form/textarea.html","title":"textarea","keywords":"","body":"textarea 多行输入框 属性 属性名 类型 必填 默认值 说明 cstyle String 否 自定义样式,如 \"color:red;text-align:center;\" value String 否 多行输入框的初始内容 type String 否 \"text\" 多行输入框的类型 placeholder String 否 提示用户输入的内容 disabled Boolean 否 false 是否禁用 focus Boolean 否 false 获取焦点（web端不支持） maxlength Number 否 140 最大输入长度 return-key-type String 否 \"done\" 设置键盘右下角按钮的文字（web端不支持） placer-holder-color String 否 “#666” 指定placeholder的颜色（web端不支持） rows Number 否 2 text-area行数，weex、web端生效 c-bind:input EventHandle 否 键盘输入时触发 返回事件对象： event.type=\"input\", event.detail={value} c-bind:confirm EventHandle 否 点击完成按钮时触发 返回事件对象： event.type=\"confirm\", event.detail c-bind:focus EventHandle 否 输入框获取焦点时触发 返回事件对象： event.type=\"focus\", event.detail c-bind:blur EventHandle 否 输入框失去焦点时触发 返回事件对象： event.type=\"blur\", event.detail type 的有效值： 值 说明 text 文本类型的输入 password 密码类型的输入 number 数字类型的输入 return-key-type 的有效值： 值 说明 done 右下角按钮为“完成” search 右下角按钮为“搜索” next 右下角按钮为“下一个” go 右下角按钮为“前往” 示例 class Textarea { data = { isfocus: false } methods = { bindblurevent() { console.log('blur') this.isfocus = false; } } mounted = function(res) { setTimeout(() => { this.isfocus = true; }, 300); } }; export default new Textarea(); { \"base\": {} } wx web native 查看完整示例 Bug & Tip wx端不能包裹在里面 web端不支持自动focus return-key-type字段web端不支持 "},"component/base/form/switch.html":{"url":"component/base/form/switch.html","title":"switch","keywords":"","body":"switch 开关 属性 属性名 类型 必填 默认值 说明 checked Boolean 否 关闭 是否开启switch按钮 label String 否 按钮文案 disabled Boolean 否 false 是否禁用 opencolor String 否 定义选中的颜色，如 '#000' c-bind:change EventHandle 否 点击按钮触发 返回事件对象： event.detail 返回值： event.detail.value 示例 class Switch { data = { switchValue: false } methods = { switchChange (e) { this.switchValue = e.detail.value } } }; export default new Switch(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/form/radio.html":{"url":"component/base/form/radio.html","title":"radio","keywords":"","body":"radio 单选框 属性 属性名 类型 必填 默认值 说明 checked Boolean 否 关闭 是否开启 label String 否 单选框文案 disabled Boolean 否 false 是否禁用 position String 否 left 单选框相对于文案的位置，可选值包括：left、right group-index Number 否 -1 表示在radio-group中的索引 c-bind:change EventHandle 否 点击单选框触发 返回事件对象： event.detail 返回值： event.detail.value 示例 class Index { data = { radioValue: false } methods = { valueChange (e) { this.radioValue = e.detail.value; } } } export default new Index(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/form/checkbox.html":{"url":"component/base/form/checkbox.html","title":"checkbox","keywords":"","body":"checkbox 复选框 属性 属性名 类型 必填 默认值 说明 checked Boolean 否 关闭 是否开启 label String 否 复选框文案 disabled Boolean 否 false 是否禁用 position String 否 left 复选框相对于文案的位置，可选值包括：left、right group-index Number 否 -1 表示在checkbox-group中的索引 c-bind:change EventHandle 否 点击复选框触发 返回事件对象： event.detail 返回值： event.detail.value 示例 class Checkbox { data = { checkboxValue: true } methods = { valueChange (e) { this.checkboxValue = e.detail.value } } }; export default new Checkbox(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/media/image.html":{"url":"component/base/media/image.html","title":"媒体组件","keywords":"","body":"image 图片 属性 属性名 类型 必填 默认值 说明 src String 否 图片资源地址，支持本地路径和网络图片资源 cstyle String 否 自定义image的样式，如 \"height:100cpx;width:100cpx;\" c-bind:error EventHandle 否 当错误发生时触发，event.detail = {errMsg} c-bind:load EventHandle 否 当图片载入完毕时触发，event.detail = {height, width} --> 示例 class Image { data = { imageSrc: require('../../../assets/images/chameleon.jpg') } methods = { imageLoad(e){}, imageError(e){} } } export default new Image(); .container { display: flex; flex-direction: column; align-items: center; } { \"base\": {} } wx web native 查看完整示例 "},"component/base/media/video.html":{"url":"component/base/media/video.html","title":"video","keywords":"","body":"video 视频播放器 属性 属性名 类型 必填 默认值 说明 src String 否 要播放视频的资源地址 cstyle String 否 自定义image的样式，如 \"height:100cpx;width:100cpx;\" autoplay Boolean 否 false 是否自动播放 controls Boolean 否 false 是否显示默认播放控件（播放/暂停按钮、播放进度、时间）（只对wx有效） c-bind:start EventHandle 否 当开始/继续播放时触发start事件 c-bind:pause EventHandle 否 当暂停播放时触发 pause 事件 c-bind:finish EventHandle 否 当播放到末尾时触发 finish 事件 c-bind:fail EventHandle 否 视频播放出错时触发 fail 示例 import cml from 'chameleon-api' class Video { data = { videoSrc: 'http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400', state: '----', } } export default new Video(); .video { width: 720cpx; height: 350cpx; margin-top: 60cpx; } { \"base\": {} } wx web native Bug & Tip 是唯一合法的子组件。 查看完整示例 "},"component/expand/expand.html":{"url":"component/expand/expand.html","title":"扩展组件","keywords":"","body":"扩展组件(Extended components) 扩展组件需要额外引入。如： { \"base\": { \"usingComponents\": { \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\" } } } 分类 说明 多态组件 使用基于多态协议扩展的最底层组件 复合组件 普通业务功能的聚合，调用多态组件或者复合组件进行功能封装 扩展原生组件 native 原生解析渲染，灵活定制、跨端兼容 * [多态组件](/component/expand/polymorphism/polymorphism.html) * [复合组件](/component/expand/compound/compound.html) * [扩展原生组件](/component/expand/native/native.html) --> 资料：cml-ui chameleon 扩展组件库。 "},"component/expand/compound/c-toast.html":{"url":"component/expand/compound/c-toast.html","title":"c-toast","keywords":"","body":"c-toast 提示框 属性 属性名 类型 必填 默认值 说明 message String 是 提示框提示的内容 duration Number 否 3000 提示的延迟时间，单位为毫秒 type String 否 “loading” 提示框的类型，有效值：loading/success/warn mask Boolean 否 false 是否显示透明蒙层 show Boolean 否 false 是否显示 need-icon Boolean 否 true 是否显示图标 示例 class C_toast { } export default new C_toast(); { \"base\": { \"usingComponents\": { \"c-toast\": \"cml-ui/components/c-toast/c-toast\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-loading.html":{"url":"component/expand/compound/c-loading.html","title":"c-loading","keywords":"","body":"c-loading 加载中 属性 属性名 类型 必填 默认值 说明 tip String 否 'loading...' 描述文案 loading Boolean 否 true 是否为加载中状态 示例1 注： 使用此模式时，请将c-loading组件放在所有元素的最后，如使用router-view，请放在router-view后面 { \"base\": { \"usingComponents\": { \"c-loading\": \"cml-ui/components/c-loading/c-loading\" } } } wx web native 示例2 class CLoading { } export default new CLoading(); { \"base\": { \"usingComponents\": { \"c-loading\": \"cml-ui/components/c-loading/c-loading\" } } } wx web native "},"component/expand/compound/c-dialog.html":{"url":"component/expand/compound/c-dialog.html","title":"c-dialog","keywords":"","body":"c-dialog 对话框 属性 属性名 类型 必填 默认值 说明 title String 是 对话框提示的标题 content String 是 对话框提示的内容 type String 否 alert 对话框的类型，有效值：alert/confirm cancel-text String 否 “取消” 取消按钮的文字 cancel-style Object 否 自定义取消按钮的文案样式 如 {'color':'red','text-align':'center'} confirm-text String 否 “确定” 确认按钮的文字 confirm-style Object 否 自定义确认按钮的文案样式 如 {'color':'red','text-align':'center'} icon-type String 否 “warn” 图标，有效值success/warn icon-url String 否 图标地址 icon-style Object 否 图标的样式 mask Boolean 否 true 是否显示透明蒙层 show Boolean 否 false 开启打开alert类型对话框 show-close Boolean 否 false 是否显示close关闭图标 c-bind:show EventHandle 否 开启alert类型对话框时触发返回事件对象：event.type=\"changeShow\",e.detail={value} c-bind:cancel EventHandle 否 用户点击cancel时触发返回事件对象：event.type=\"cancelEvent\" c-bind:confirm EventHandle 否 用户点击confirm时触发返回事件对象：event.type=\"confirmEvent\" c-bind:close EventHandle 否 点击close图标时触发返回事件对象： event.type=\"closeEvent\" 示例 class C_dialog { } export default new C_dialog(); { \"base\": { \"usingComponents\": { \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-popup.html":{"url":"component/expand/compound/c-popup.html","title":"c-popup","keywords":"","body":"c-popup 蒙层 属性 属性名 类型 必填 默认值 说明 mask Boolean 否 true 是否显示透明蒙层 show Boolean 是 false 开启打开popup center Boolean 否 true 内容是否垂直水平居中 position String 否 内容展示位置，优先级比center高，可选值left/top/right/bottom c-bind:close EventHandle 否 点击蒙层时触发 示例 class C_popup { } export default new C_popup(); { \"base\": { \"usingComponents\": { \"c-popup\": \"cml-ui/components/c-popup/c-popup\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-tip.html":{"url":"component/expand/compound/c-tip.html","title":"c-tip","keywords":"","body":"c-tip 提示 属性 属性名 类型 必填 默认值 说明 show Boolean 否 false 提示框是否显示 direction String 否 top 提示框所在位置，可选值top/right/bottom/left offset-left Number 否 小三角之Tip左边距离 offset-top Number 否 小三角之Tip顶部距离 offset-right Number 否 小三角之Tip右边距离 offset-bottom Number 否 小三角之Tip底部距离 c-bind:close EventHandle 点击关闭按钮触发 注意：Tip小三角默认是居中显示的，当direction值为top或bottom时，如果offset-left或offset-right有值且不是NaN，则小三角的距离为传入值 示例 Tip Awesome! class CTip { } export default new CTip(); { \"base\": { \"usingComponents\": { \"c-tip\": \"cml-ui/components/c-tip/c-tip\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-actionsheet.html":{"url":"component/expand/compound/c-actionsheet.html","title":"c-actionsheet","keywords":"","body":"c-actionsheet 操作列表 属性 属性名 类型 必填 默认值 说明 title String 否 标题 操作列表标题 list Array 是 [] 操作列表数据，如['action1', 'action2'] active Number 当前选中元素索引，从0开始 show Boolean 否 false 操作列表是否显示 cancel-txt String 否 取消 取消按钮文本 header-style String 否 标题自定义样式 cancel-style String 否 取消按钮自定义样式 content-style String 否 普通操作样式 active-style String 否 当前选中操作样式 c-bind:select EventHandle 否 点击操作时触发，event.detail = { index, value } c-bind:cancel EventHandle 否 点击取消或蒙层时触发 示例 class C_actionsheet { data = { list: [\"高铁\", \"火车\", \"飞机\", \"打车\", \"地铁\"], title: \"出行方式\" } } export default new C_actionsheet(); { \"base\": { \"usingComponents\": { \"c-actionsheet\": \"cml-ui/components/c-actionsheet/c-actionsheet\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-tab.html":{"url":"component/expand/compound/c-tab.html","title":"c-tab","keywords":"","body":"c-tab 属性 属性名 类型 必填 默认值 说明 tabs Array 是 [] tabs显示内容数组，tabs中数组中具体的值请看tabs详情 active-label String 是 tabs数组中的某一个label的值 注意必须和tabs数组中某一个label的值相等 inline Boolean 否 true 代表每一个tab栏的 \b前置icon + tab内容 + 后置icon 的排列方向，默认水平排列 line-style String 否 '' 标识tab栏的下划标志线的样式 active-label-style String 否 \"color:#FC9153\" 标识tab栏激活后的文案的样式 has-underline Boolean 否 true 是否需要下划线 active-icon-style String 否 '' label前缀icon或者后缀icon激活后的样式 事件 事件名 描述 事件参数中detail对象 tabclick 点击每个tab时候出发的事件名称 label:表示激活tab的文案,activeIndex:表示激活tab的索引 tabs数组具体属性详情 属性名 类型 必填 默认值 说明 label String 是 tabs数组中的某一个label的值 注意必须和tabs数组中某一个label的值相等 labelStyle String 否 外部传入控制每一个tab栏的文案样式 prefixStyle String 否 外部传入控制每一个tab栏的前缀样式 suffixStyle String 否 外部传入控制每一个tab栏的后缀样式 c-tab-pane 属性 属性名 类型 必填 默认值 说明 tabs Array 是 [] tabs显示内容数组，tabs中数组中具体的值请看tabs详情 active-label String 是 tabs数组中的某一个label的值 注意必须和tabs数组中某一个label的值相等 注意，如果c-tab-pane组件配合c-tabs组件使用，那么二者的tabs和active-label属性必须引用同一个值；每个c-tab-pane组件下，同时对应一个c-tab-pane-item组件； c-tab-pane-item 用于提供一个可以容纳每个pane的容器,宽度 750cpx; 示例 单tab案例 tab+pane案例 {{item.label}} --> 1 2 3 4 { \"base\": { \"usingComponents\": { \"c-tab\": \"cml-ui/components/c-tab/c-tab\", \"c-tab-pane\": \"cml-ui/components/c-tab-pane/c-tab-pane\", \"c-tab-pane-item\": \"cml-ui/components/c-tab-pane-item/c-tab-pane-item\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-picker.html":{"url":"component/expand/compound/c-picker.html","title":"c-picker","keywords":"","body":"c-picker 底部弹起的滚动选择器 属性 属性名 类型 必填 默认值 说明 show Boolean 是 false 是否点击打开滚动选择器 title String 否 \"请选择\" 滚动选择器的标题 header-height Number 是 100 滚动选择器标题栏的高度 data-height Number 是 400 滚动选择器数据栏的高度 list Array 是 滚动选择器滚动的数据,注意：，在新版内置组件，data 属性名已废弃 default-index Number 是 0 滚动选择器默认的数据索引 text-align String 是 \"center\" 滚动选择器的文本样式:\"居中\" item-style String 否 自定义每一项item的样式，如 \"color:blue;text-align:center;\" cancel-btn-style String 否 自定义取消按钮的样式，如 \"color:red;text-align:center;\" confirm-btn-style String 否 自定义确定按钮的样式,如 \"color:red;text-align:center;\" c-bind:cancel EventHandle 否 用户点击\"取消\"时触发:返回事件对象:event.type=\"cancel\" c-bind:confirm EventHandle 否 用户点击\"确定\"时触发:返回事件对象:event.type=\"confirm\" c-bind:selectchange EventHandle 是 选择器滚动时触发: 返回事件对象: event.type=\"selectchange\" event.detail = {index} 示例 点击选择：{{provins[provinsIndex]}} class CPicker { data = { provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0, pickerShow: false } computed = {} watch = {} methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; }, showClick() { this.pickerShow = true; }, cancel() { this.pickerShow = false; }, confirm() { this.pickerShow = false; } } beforeCreate() {} created() {} beforeMount() {} mounted() {} beforeDestroy() {} destroyed() {} } export default new CPicker(); .container { background: #f8f8f8; } .page-demo { background: #fafafa; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .picker-item { background: #fff; border-top: 1px solid #d9d9d9; border-bottom: 1px solid #d9d9d9; display: flex; flex-direction: row; } .picker-text-left { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; width: 300cpx; } .picker-text-right { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; flex: 1; text-align: center; } .select-text { font-size: 32cpx; text-align: center; display: flex; justify-content: center; align-items: center; } { \"base\": { \"usingComponents\": { \"c-picker\": \"cml-ui/components/c-picker/c-picker\" } } } wx web native "},"component/expand/polymorphism/c-picker-panel.html":{"url":"component/expand/polymorphism/c-picker-panel.html","title":"c-picker-panel","keywords":"","body":"c-picker-panel 从底部弹起的控制板。 属性 属性名 类型 必填 默认值 说明 show Boolean 是 false 是否点击打开底部控制板 title String 否 \"请选择\" 控制板的标题 header-height Number 是 100 底部控制板标题栏的高度 cancel-btn-style String 否 自定义取消按钮的样式，如 \"color:red;text-align:center;\" confirm-btn-style String 否 自定义确定按钮的样式,如 \"color:red;text-align:center;\" c-bind:cancel EventHandle 否 用户点击\"取消\"时触发:返回事件对象:event.type=\"cancel\" c-bind:confirm EventHandle 否 用户点击\"确定\"时触发:返回事件对象:event.type=\"confirm\" 示例 c-picker-panel 点击选择：{{provins[provinsIndex]}} import { provins } from \"./data\"; class CPickerPanel { data = { provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0, panelShow: false } computed = {} watch = {} methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; }, showClick() { this.panelShow = true; }, cancel() { this.panelShow = false; }, confirm() { this.panelShow = false; } } beforeCreate() {} created() {} beforeMount() {} mounted() {} beforeDestroy() {} destroyed() {} } export default new CPickerPanel(); .container { background: #f8f8f8; position: absolute; top: 88cpx; bottom: 0; left: 0; right: 0; } .page-demo { background: #fafafa; position: absolute; top: 0; bottom: 0; left: 0; right: 0; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .picker-item { background: #fff; border-top: 1px solid #d9d9d9; border-bottom: 1px solid #d9d9d9; display: flex; flex-direction: row; } .picker-text-left { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; width: 300cpx; } .picker-text-right { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; flex: 1; text-align: center; } .select-text { font-size: 32cpx; text-align: center; display: flex; justify-content: center; align-items: center; } { \"base\": { \"usingComponents\": { \"c-picker-panel\": \"cml-ui/components/c-picker-panel/c-picker-panel\", \"c-picker-item\": \"cml-ui/components/c-picker-item/c-picker-item\" } } } wx web native "},"component/expand/polymorphism/c-picker-item.html":{"url":"component/expand/polymorphism/c-picker-item.html","title":"c-picker-item","keywords":"","body":"c-picker-item 滚动选择器 属性 属性名 类型 必填 默认值 说明 list Array 是 [''] 滚动选择器滚动的数据，注意：data 属性名已废弃 default-index Number 是 0 滚动选择器默认的数据索引 height Number 是 400 滚动选择器的高度 text-align String 是 \"center\" 滚动选择器的文本样式:\"居中\" c-bind:selectchange EventHandle 是 选择器滚动时触发: 返回事件对象: event.type=\"selectchange\" event.detail = {index} 示例 选择的值：{{provins[provinsIndex]}} import { provins } from \"./data\"; class CPickerItem { data = { provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0 } computed = {} watch = {} methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; } } beforeCreate() {} created() {} beforeMount() {} mounted() {} beforeDestroy() {} destroyed() {} } export default new CPickerItem(); .container { background: #f8f8f8; } .page-demo { background: #fafafa; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .picker-item { background: #fff; border-top: 1px solid #d9d9d9; border-bottom: 1px solid #d9d9d9; display: flex; flex-direction: row; } .picker-text-left { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; width: 300cpx; } .picker-text-right { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; flex: 1; text-align: center; } .select-text { font-size: 32cpx; text-align: center; display: flex; justify-content: center; align-items: center; } { \"base\": { \"usingComponents\": { \"c-picker-item\": \"cml-ui/components/c-picker-item/c-picker-item\" } } } wx web native "},"component/expand/compound/c-checkbox-group.html":{"url":"component/expand/compound/c-checkbox-group.html","title":"c-checkbox-group","keywords":"","body":"c-checkbox-group 复选框列表 属性 属性名 类型 必填 默认值 说明 option Array 是 [] 选项数组 horizontal Boolean 否 false 单选框排列方向，默认纵向排列 position String 否 left 按钮相对于文案的位置，可选值包括：left、right c-bind:groupchange EventHandle 否 点击按钮出发 返回事件对象： event.detail 返回值： event.detail.value - 修改后的选项数组 event.detail.index - 修改的复选框索引 event.detail.selected - 选中的项目文案数组 示例 class CCheckbox { data = { checkboxGroupOption: [{ checked: true, label: 'one', disabled: true }, { checked: false, label: 'two' }, { checked: false, label: 'three' }], selected: 'one', } methods = { groupChangeHandler (e) { this.checkboxGroupOption = e.detail.value this.selected = e.detail.selected.join(', ') } } } export default new CCheckbox(); { \"base\": { \"usingComponents\": { \"c-checkbox-group\": \"cml-ui/components/c-checkbox-group/c-checkbox-group\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-radio-group.html":{"url":"component/expand/compound/c-radio-group.html","title":"c-radio-group","keywords":"","body":"c-radio-group 单选框列表 属性 属性名 类型 必填 默认值 说明 option Array 是 [] 选项数组 horizontal Boolean 否 false 单选框排列方向，默认纵向排列 position String 否 left 按钮相对于文案的位置，可选值包括：left、right c-bind:groupchange EventHandle 否 点击按钮出发 返回事件对象： event.detail 返回值： event.detail.value - 修改后的选项数组 event.detail.index - 修改的单选框索引 示例 class CRadio { data = { radioGroupOption: [ { checked: false, label: 'Option1', }, { checked: false, label: 'Option2' }, { checked: false, label: 'Option3', disabled: true } ], radioSelect: '' } methods = { groupChangeHandler (e) { this.radioSelect = this.radioGroupOption[e.detail.index].label } } } export default new CRadio(); { \"base\": { \"usingComponents\": { \"c-radio-group\": \"cml-ui/components/c-radio-group/c-radio-group\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-tabbar.html":{"url":"component/expand/compound/c-tabbar.html","title":"c-tabbar","keywords":"","body":"c-tabbar tabbar组件 注意需要升级最新的cml-ui,在项目根目录执行npm i cml-ui@latest -S 属性 属性名 类型 必填 默认值 说明 c-bind:onclick EventHandle 是 tab被点击的时候会触发该事件，参数详情中`detail.compName`是tabbar.list配置中的compName c-model String 是 当 使用 component 动态组件的时候，更方便的和动态组件要渲染的组件名有个对应,具体使用方式参考下面案例中的 currentComp tabbar Object 是 {} 详情见下表 tabbar 详情 属性名 类型 必填 默认值 说明 useFixedLayout Boolean 否 false 用于决定是否使用position:fixed 这种布局方式去布局tabbar组件 position String 否 'bottom' 仅在useFixedLayout 为true的时候生效 tabbarStyle String 否 '' tabbar样式支持自定义 tabLineStyle String 否 'background-color:#FC9153;height:2cpx;' tabbar的下划线自定义样式，仅在 position 设置为top的时候有效 textStyle String 否 'color:#000000' tabbar文案默认的样式 selectedTextStyle String 否 'color:#61c7fc' tabbar文案被选中的时候的样式 list Array 是 [] 配置tabbar的icon，文案等，详情见下表 list 中数组每一项的配置详情 属性名 类型 必填 默认值 说明 text String 是 '' tab的文案 icon 网络图片地址或者`require(path/to/image)` 否 tab的icon selectedIcon 网络图片地址或者`require(path/to/image)` 否 tab被选中时显示的icon iconStyle String 否 默认的icon的宽高是40cpx; 设置icon的样式 selectedIconStyle String 否 设置icon被选中的时候的样式 compName String 是 选择'usingComponents'中的组件进行对应，需要结合component动态组件进行渲染 示例 import cml from \"chameleon-api\"; class Index { data = { viewPortHeight:0, currentComp:'comp1', tabbar:{ \"tabbarStyle\":\"height:120cpx;background-color:#BAF6E8\",//tabbar最外层的样式支持自定义 \"tabLineStyle\":\"background-color:#069ADC;height:2cpx;\",//自定义tabline的高度和背景色 \"textStyle\":\"color:#3b3b3b\", //文案默认style ,可以这里控制文案的大小，样式等 \"selectedTextStyle\":\"color:#3baaff\",//文案被选择style // \"position\":\"top\", //tabbar的位置 top/bottom \"useFixedLayout\":true, //是否通过fixed布局进行tabbar的布局 \"list\":[ { \"compName\":\"comp1\", \"text\": \"detail\", \"icon\": require(\"../../assets/images/chameleon.png\"), }, { \"compName\":\"comp2\", \"text\": \"home\", \"icon\": require(\"../../assets/images/chameleon.png\"), } ] }, } methods = { handleTabbarClick(args){ console.log('tabbar-info',args) } } created(res){ cml.getSystemInfo().then(info => { //这里要减去tabbar的高度，默认是120cpx,如果tabbarStyle中设置了其他高度，则要减去对应的值； this.viewPortHeight = Number(info.viewportHeight) - 120; }); if(res.comp){ //这里可以在传递的query中获取到想要激活的组件,具体使用方式参见文末的demo链接 this.currentComp = res.comp; } } } export default new Index(); { \"base\": { \"usingComponents\": { \"c-tabbar\":\"cml-ui/components/c-tabbar/c-tabbar\", \"comp1\":\"/components/demo-com/comp1\", \"comp2\":\"/components/demo-com/comp2\" } } } wx web native 查看完整示例 "},"api/api.html":{"url":"api/api.html","title":"API","keywords":"","body":"API chameleon 支持大量基础API，对外提供统一的接口，以模块的方式引入chameleon-api进行使用。 例如: import cml from 'chameleon-api' cml.showToast({ message: 'Hello world!', duration: 1000 }) 注意： 接口均以promise形式进行返回，所以你可以结合异步流程控制如async、await进行操作。 API模块为按需加载模块，可有效减少包体积。 \b\b失败回调的返回格式为{errMsg:string}，如果是自己扩展的方法也建议按照此结构进行构造。 你还可以利用接口多态来实现跨端的接口或差异化实现特定端接口。 相关链接 运行时相关 网络请求 路由导航 数据存储 地理位置 系统信息 启动参数 元素属性 单位转换 交互反馈 设置title 打开/关闭应用页面 获取照片 剪贴板 WebSocket 计时器 canIUse 异步流程控制 异常和错误处理 动画关键帧 动画 Store "},"api/runtime/runtime.html":{"url":"api/runtime/runtime.html","title":"运行时相关","keywords":"","body":"runtime Module 加载接口 export&import @import "},"api/runtime/module.html":{"url":"api/runtime/module.html","title":"export&import","keywords":"","body":"export & import chameleon框架的编译时加载方案是在ES6的module能力基础上扩展的，主要由两个命令构成：export和import。 export 命令 export命令用于规定模块的对外接口。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。 // profile.js const name = 'Mike'; const gender = 'male'; const age = 24; export {name, gender, age}; import 命令 import命令用于输入其他模块提供的功能。 使用export命令定义了模块的对外接口以后，通过import命令加载这些模块。 导入规范如下表所示： 当前文件后缀 仅限导入的类型 示例 .cml .js、.json import a from 'a.js'; import b from 'b.json'; *.[web|weex|wx|alipay|baidu].cml .interface、.js、.json import a from 'a.js'; import b from 'b.json'; import c from 'c.interface'; .js .interface、.js、.json import a from 'a.js'; import b from 'b.json'; import c from 'c.interface'; .interface .js、.json import a from 'a.js'; import b from 'b.json'; 如果没有加后缀名，会依次查找后缀为.interface, .js的文件 // 会依次查找 profile.interface profile.js import {name, gender, age} from './profile'; // 最后找到 profile.js function setName(human) { human.textContent = name + ' ' + gender + ' ' + age; } "},"api/runtime/@import.html":{"url":"api/runtime/@import.html","title":"@import","keywords":"","body":"@import 指定导入的外部样式表及目标媒体。支持导入.css、.less、.stylus类型文件。 该规则必须在样式表头部最先声明。并且其后的分号是必需的，如果省略了此分号，外部样式表将无法正确导入，并会生成错误信息。 @import './base.css'; @import './base.less'; @import './base.stylus'; "},"api/request.html":{"url":"api/request.html","title":"网络请求","keywords":"","body":"网络请求 get 发送get请求 参数 参数 类型 必需 默认值 说明 url String 是 网络请求地址，如果项目中配置了apiPrefix并且setting中的apiPrefix为true，则添加配置的前缀 data Object 否 要传的参数，会拼接在请求的url中 header Object 否 设置http请求的header resDataType String 否 json 设置response的数据类型, 为json时, 会尝试对返回值进行JSON.parse(), 若不希望parse, 则传入'text'即可 setting Object 否 {jsonp: false(仅web端有效), apiPrefix: Boolean(根据传入url决定), credentials: 'include'(仅web端有效)} 自定义了设置，apiPrefix为是否添加chameleon.config.js中设置的apiPrefix (以http://或https://或//开头的url默认不会拼接, 其他情况均会自动拼接); jsonp 为 true 时会发起一个 jsonp 请求; credentials可选值'omit'/'same-origin'/'include', 对应fetch的credentials domain String 是 网络请求的域名前缀（chameleon-api@0.3.0-alpha.4 开始支持）具体参见api多域名mock 返回值 返回promise，对应的请求成功和失败回调 举例 cml.get({ url: 'https://cml.com/api/user/1' }).then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }) post 发送post请求 参数 参数 类型 必需 默认值 说明 url String 是 网络请求地址，如果项目中配置了apiPrefix并且setting中的apiPrefix为true，则添加配置的前缀 data Object 否 要传的参数，会拼接在请求的url中 header Object 否 设置http请求的header contentType String 否 form 取值：form或json，决定body中data的格式，对应header中content-type为application/x-www-form-urlencoded或application/json resDataType String 否 json 设置response的数据类型, 为json时, 会尝试对返回值进行JSON.parse(), 若不希望parse, 则传入'text'即可 setting Object 否 {jsonp: false(仅web端有效), apiPrefix: Boolean(根据传入url决定), credentials: 'include'(仅web端有效)} 自定义了设置，apiPrefix为是否添加chameleon.config.js中设置的apiPrefix (以http://或https://或//开头的url默认不会拼接, 其他情况均会自动拼接); jsonp 为 true 时会发起一个 jsonp 请求; credentials可选值'omit'/'same-origin'/'include', 对应fetch的credentials 返回值 返回promise，对应的请求成功和失败回调 举例 cml.post({ url: 'https://cml.com/api/user/update', data: { a: 1 } }).then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }) request 发送request请求 参数 参数 类型 必需 默认值 说明 url String 是 网络请求地址，如果项目中配置了apiPrefix并且setting中的apiPrefix为true，则添加配置的前缀 data Object 否 要传的参数，会拼接在请求的url中 method Object 否 若cml.get()/cml.post()无法满足需求,如需使用DELETE/PUT时,可调用此方法 header Object 否 设置http请求的header contentType String 否 form 取值：form或json，决定body中data的格式，对应header中content-type为application/x-www-form-urlencoded或application/json resDataType String 否 json 设置response的数据类型, 为json时, 会尝试对返回值进行JSON.parse(), 若不希望parse, 则传入'text'即可 setting Object 否 {jsonp: false(仅web端有效), apiPrefix: Boolean(根据传入url决定), credentials: 'include'(仅web端有效)} 自定义了设置，apiPrefix为是否添加chameleon.config.js中设置的apiPrefix (以http://或https://或//开头的url默认不会拼接, 其他情况均会自动拼接); jsonp 为 true 时会发起一个 jsonp 请求; credentials可选值'omit'/'same-origin'/'include', 对应fetch的credentials 返回值 返回promise，对应的请求成功和失败回调 举例 cml.request({ url: 'https://cml.com/api/user/1', data: { a: 1 }, method: 'PUT' }).then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }) "},"api/navigate.html":{"url":"api/navigate.html","title":"路由导航","keywords":"","body":"路由导航 navigateTo 保留当前页面，跳转到应用内的某个页面。 参数 参数名 类型 必填 默认值 说明 path String 是 无 应用内页面的路径， 路由里面的path值 query Object 否 无 要传递的参数，可在将进入页面的beforeCreate里面获取 返回值 无 举例 cml.navigateTo({ path: '/pages/navigateBack/index', query: { a: 1, b: 'test' } }) redirectTo 关闭当前页面，跳转到应用内的某个页面 参数 参数名 类型 必填 默认值 说明 path String 是 无 应用内页面的路径， 即路由里面的path值 query Object 否 无 要传递给将进入页面参数，可在将进入页面的beforeCreate里面获取 返回值 无 举例 cml.redirectTo({ path: '/pages/navigateBack/index', query: { a: 1, b: 'test' } }) navigateBack 关闭当前页面，返回上一页面 \b参数 参数名 类型 必填 默认值 说明 backPageNum Number[负数] 否 -1 要返回的页面级数, 为负数, 默认返回上一页 举例 cml.navigateBack(-1); "},"api/storage.html":{"url":"api/storage.html","title":"数据存储","keywords":"","body":"数据存储 setStorage 该方法通过键值对的形式将数据存储到本地。同时也可以通过该方法更新已有的数据。 参数 参数 类型 说明 key String 要存储的键 value String/Number/Object/Array 储存的值 返回值 返回promise 举例 cml.setStorage('name', 'Hanks').then(()=>{ },function(err){ }) getStorage \b获取本地存储的对应键名的键值 参数 参数 类型 说明 key String 存储的键名 返回值 返回promise 返回值 类型 说明 value String 存储的键名对应的键值 举例 cml.getStorage('name').then((value)=>{ // 处理获取到的键值 },function(err){ }) removeStorage 删除本地存储中对应键值对应的数据 参数 参数 类型 说明 key String 存储的键名 返回值 返回promise 举例 cml.removeStorage('name').then(()=>{ },function(err){ }) "},"api/location.html":{"url":"api/location.html","title":"地理位置","keywords":"","body":"获取地理位置 注： 在weex端，接入chameleon客户端sdk之后才可以使用该方法 getLocationInfo 参数 无 返回值 参数 类型 说明 lng Number 经度 lat Number 纬度 举例 cml.getLocationInfo().then(res => { // res: { lng[number]: 40.33, lat[number]: 154.33 } cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }) "},"api/system.html":{"url":"api/system.html","title":"系统信息","keywords":"","body":"获取系统信息 get\bSystemInfo 获取系统信息，至少返回系统类型，如ios或android。 参数 无 返回值 返回值 类型 说明 os String 系统类型，ios或android。注意是小写。 env String 所处环境，web，weex，wx（微信小程序），alipay(支付宝小程序)，baidu（百度小程序） viewportWidth Number \b视口宽度 viewportHeight Number \b视口高度 extraParams Object 包含端内bridge或小程序api返回的所有信息 举例 cml.getSystemInfo().then(info => { }) "},"api/launchOptions.html":{"url":"api/launchOptions.html","title":"启动参数","keywords":"","body":"启动参数信息 getLaunchOptionsSync() 获取程序启动时的参数信息（同步方法） 参数 无 返回值 参数 类型 说明 query Object 小程序，web或者native中启动时的query信息 path String 启动小程序的路径 scene Number 启动小程序的场景值 其他 Any 小程序中并列返回的其他参数 举例 let obj = getLaunchOptionsSync(); cml.showToast({ message: JSON.stringify(obj) }) "},"api/getRect.html":{"url":"api/getRect.html","title":"元素属性","keywords":"","body":"元素属性 getRect 获取某个节点的部分属性 参数 参数名 类型 必填 默认值 说明 ref String 是 无 页面上标记了ref属性的节点 context context 是 无 由于小程序端限制, 组件内获取元素属性需要指定组件的上下文, 通常传this即可 返回值 \bPromise成功回调返回值: 返回值 类型 说明 width number 节点的宽度 height number 节点的高度 left number 节点的左边界坐标 right number 节点的右边界坐标 top number 节点的上边界坐标 bottom number 节点的下边界坐标 举例 // 'refTest'为\btemplate中某个节点的ref属性所对应的值 cml.getRect('refTest', this).then(res => { cml.showToast({ message: JSON.stringify(res) }) }) "},"api/px.html":{"url":"api/px.html","title":"单位转换","keywords":"","body":"单位转换 尺寸单位 cpx: chemeleon体系中的尺寸单位，可以根据屏幕宽度进行自适应，规定屏幕的\b宽度为750cpx。例如在iPhone6上，屏幕宽度为375px(css像素)，则750cpx = 375px,即1cpx = 0.5px px2cpx px转cpx，输入一个px值得到当前设备上对应的cpx值 参数 参数 类型 说明 px Number 要转换为cpx的px值 返回值 返回对应的cpx值 举例 const cpx = cml.px2cpx(100); cpx2px cpx转px，输入一个cpx值得到当前设备上对应的px值 参数 参数 类型 说明 cpx Number 要转换为px的cpx值 返回值 返回对应的px值 举例 const px = cml.cpx2px(100); "},"api/modal.html":{"url":"api/modal.html","title":"交互反馈","keywords":"","body":"交互反馈 showToast 显示消息的提示框 参数 showToast方法传入一个对象，\b对象中包含如下参数： 参数名 类型 必填 默认值 说明 message String 否 无 展示的内容 duration number 否 2000 展示的持续时间(以毫秒为单位) 举例 cml.showToast({ message: \"Hello World\", duration: 1000 }) alert 用于确保用户可以得到某些消息的警示框。当警示框出现后，用户需要点击确定按钮才能继续进行操作。 参数说明 alert方法传入一个对象，对象中包含如下参数： 参数名 类型 必填 默认值 说明 message String 否 无 \b警示框内显示的文本信息 confirmTitle String 否 确定 确认按钮上显示的文字信息 返回值 调用alert之后返回一个Promise对象 举例 cml.alert({ message:'This is alert! ', confirmTitle:\"ok\" }).then(function(){ cml.showToast({ message:'success!', duration:1000 }) }) confirm 用于使用户可以接受或验证某些信息的确认框。当确认框出现后，用户需要点击确认或取消按钮才能继续进行操作。 参数说明 confirm方法传入一个对象，对象中包含如下参数: 参数名 类型 必填 默认值 说明 message String 否 无 确认框内显示的文字信息 confirmTitle String 否 确定 确认按钮上显示的文字信息，默认是\"确认\" cancelTitle String 否 取消 取消按钮上显示的文字信息，默认是“取消” 返回值 调用confrim之后返回一个Promise对象，其成功回调返回值为： \b返回值 类型 说明 value String 所点击按钮上的文本信息 举例 cml.confirm({ message:'Do you confirm?', confirmTitle:\"ok\", cancelTitle: \"cancel\" }).then(function(value){ cml.showToast({ message: \"用户点击了\"+value, duration:1000 }) }) "},"api/title.html":{"url":"api/title.html","title":"设置 title","keywords":"","body":"设置title setTitle 设置当前页面的title（在weex端请使用page组件的title属性来设置title） 参数 \b参数 类型 说明 title String 标题内容 返回值 无 举例 cml.setTitle('我是标题') "},"api/open.html":{"url":"api/open.html","title":"打开/关闭应用页面","keywords":"","body":"打开新的应用页面 打开新的应用页面 open 参数 参数名 类型 必填 默认值 说明 url String 是 无 chameleon地址带参数 commonPatchParams Object 否 无 额外传入的需要同时添加到各个端的参数\b，可用于业务代码自定义添加 extraOptions Object 否 无 额外传入的配置，\bcloseCurrent: true 会关闭当前页面后再打开新页面 返回值 无 举例 cml.open( 'https://url?cml_addr=xxx29134e8fa.js&weixin_appid=123456&baidu_appid=123456&alipay_appid=123456&path=page/a/b/c&envVersion=release', { wd: 'chameleon', time: new Date() }, { closeCurrent: false } ); 关闭当前页面 这个方法设计的初衷是关闭当前“单页面应用”。如果是你要在页面应用中返回上个页面，请使用navigate api来后退。 注意：在浏览器端，该功能\b属于部分支持。 注： 在weex端，接入chameleon客户端sdk之后才可以使用该方法 close 参数 无 返回值 无 举例 cml.close() "},"api/chooseImage.html":{"url":"api/chooseImage.html","title":"获取照片","keywords":"","body":"选取照片 通过拍照，相册，拍照相册二选一3种方式选择照片数据 注： 在weex端，接入chameleon客户端sdk之后才可以使用该方法 chooseImage 参数 参数 类型 必填 说明 params.type String 是 类型camera(相机)，album(相册)，choice(菜单选择) 注意web在端外使用js方式，故默认使用拍照相册二选一方式 callbackSuccess Function 是 获取返回的数据回调，返回参数包含 \bweb和weex使用返回的base64数据, 小程序使用返回的tempFilePaths字段 callbackFail Function 否 调用发生失败信息 示例 // choice方式选择图片 cml.chooseImage({ type: 'choice' }).then((res) => { const myImageData = res.base64; // 微信小程序中使用返回的 res.tempFilePaths[0] // 接下来可以进行上传到服务器等操作 }) "},"api/clipBoard.html":{"url":"api/clipBoard.html","title":"剪贴板","keywords":"","body":"剪贴板 setClipBoardData 传进setClipBoardData方法中的内容(text)将会自动复制到系统剪贴板。 返回值promise的回调中会告知你此操作是否成功 参数 参数名 类型 必填 默认值 说明 data string 是 无 无 举例 cml.setClipBoardData('你所需要复制的文本内容').then(res=>{ cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }).catch(reason=>{ cml.showToast({ message: JSON.stringify(reason), duration: 2000 }) }) getClipBoardData 获取系统剪贴板中的内容(text)注意： 出于安全考虑和平台限制，只支持获取在本页中复制的内容。 如果你当前没有在本页面发生过copy操作，而触发了此方法，则会返回fail。 参数 无 返回值 Promise 返回值类型为: 返回值 类型 说明 \bres string 当前系统剪贴板中的内容 举例 cml.getClipBoardData().then(res=>{ cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }) "},"api/socket.html":{"url":"api/socket.html","title":"WebSocket","keywords":"","body":"WebSocket 注： 在weex端，接入chameleon客户端sdk之后才可以使用该方法 initSocket 该方法传入一个url，返回一个WebSocket实例 参数 参数 类型 说明 url String 开发者服务器 ws 接口地址 返回值 返回WebSocket实例 举例 假设将调用cml.initSocket返回的WebSocket实例命名为ws，则ws上具有的方法如下： ws.send(data): 通过WebSocket连接向服务端发送数据,data支持字符串和对象 ws.close(): 关闭WebSocket连接 ws.onopen(): 监听WebSocket连接打开事件 ws.onclose(): 监听WebSocket连接关闭事件 ws.onmessage(): 监听WebSocket接收到服务器的消息事件 ws.onerror(): 监听WebSocket错误事件 let ws = cml.initSocket('ws://172.22.137.223:3333'); ws.onopen(() => { cml.showToast({ message: 'socket connected...', duration: 1000 }); setTimeout(() => { ws.send('hello cml socket'); }, 2000); }); ws.onmessage(res => { cml.showToast({ message: 'receive from server: ' + res.data, duration: 1000 }) ws.send({ keyword:'socket传递复杂类型', content: 'hello cml socket', arr: ['test1', 12, {}] }) }); ws.onerror(err => { console.error(err) }); ws.onclose(() => { cml.showToast({ message: 'socket closed...' }) }); setTimeout(() => { ws.close(); }, 20000); "},"api/timer.html":{"url":"api/timer.html","title":"计时器","keywords":"","body":"计时器 setTimeout 设定一个定时器，在定时到期以后执行注册的回调函数 参数 参数 类型 说明 callback Function 回调函数 delay Number 延迟时间，单位ms 返回值 返回值 类型 说明 ID Number \b计时器id 举例 setTimeout(()=>{ // do something after 3000ms }, 3000) clearTimeout 取消由 setTimeout() 方法设置的定时器 参数 参数 类型 说明 ID Number \b计时器id 返回值 无 举例 var timer = setTimeout(()=>{ // do something after 3000ms }, 3000); clearTimeout(timer) setInterval 设定一个定时器，按照指定的周期（以毫秒计）来执行注册的回调函数 参数 参数 类型 说明 callback Function 回调函数 delay Number 延迟时间，单位ms 返回值 返回值 类型 说明 ID Number \b计时器id 举例 setInterval(()=>{ // do something every 3000ms }, 3000) clearInterval 取消由 setInterval() 方法设置的定时器\b。 参数 参数 类型 说明 ID Number \b计时器id 返回值 无 举例 var timer = setInterval(()=>{ // do something after 3000ms }, 3000); clearInterval(timer) "},"api/caniuse.html":{"url":"api/caniuse.html","title":"canIUse","keywords":"","body":"canIUse 用来查询某个方法chameleon是否支持。调用此方法，并传入你想知道是否支持的方法名。 使用示例 cml.canIUse('showToast').then(() => { // 支持 }, () => { // 不支持 }; "},"api/async.html":{"url":"api/async.html","title":"异步流程控制","keywords":"","body":"异步控制 你可以使用Promise，async、await来更好的进行异步流\b的控制。 Promise((resolve, reject) => {}) 参数 resolve：成功回调 reject：\b失败回调 const promise = new Promise((resolve, reject) => { // 异步操作的代码 if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); async，await const sleep = function (time) { return new Promise((resolve, reject) => { setTimeout(() => { resolve('ok'); }, time); }) }; const start = async function () { let result = await sleep(3000); console.log(result); } start(); "},"api/error_control.html":{"url":"api/error_control.html","title":"异常和错误处理","keywords":"","body":"错误处理 在跨端的代码的书写中，你可以使用try catch，Promise.catch()来进行错误的处理，但不可以在小程序和weex端的代码里出现window.onerror方法\b。 promise.then().catch((e) => {}) 举例 var promise = new Promise(function(resolve, reject) { resolve('Success'); }); promise.then(function(value) { console.log(value); // \"Success!\" throw 'oh, no!'; }).catch(function(e) { console.log(e); // \"oh, no!\" }) try catch 你可以使用try catch finally来捕获和处理异常错误。\b 举例 try { throw \"myException\"; // generates an exception } catch (e) { // statements to handle any exceptions logMyErrors(e); // pass exception object to error handler } "},"api/animationFrame.html":{"url":"api/animationFrame.html","title":"动画关键帧","keywords":"","body":"动画关键帧 requestAnimationFrame (callback: function) 方法告诉客户在下一次重绘之前需要调用的函数。（回调次数：web端通常是每秒60次，大多数浏览器通常匹配 W3C 所建议的刷新频率，其它端为60次） 参数 参数名 类型 必填 说明 callback function 是 该函数在下次重绘前调用。只有一个参数，即开始触发回调的时间（performance.now() 的返回值） cancelAnimationFrame (id: number) 取消由 requestAnimationFrame方法设置的关键帧 参数 参数名 类型 必填 说明 ID number 是 要取消的定时器ID "},"api/createAnimation/main.html":{"url":"api/createAnimation/main.html","title":"动画","keywords":"","body":"动画 动画模块用来在目标元素上执行动画 可执行一系列简单的变换 (位置、大小、旋转角度、背景颜色和透明度等) "},"api/createAnimation/createAnimation.html":{"url":"api/createAnimation/createAnimation.html","title":"cml.createAnimation","keywords":"","body":"cml.createAnimation() 返回一个动画实例 animation。调用实例的方法来描述动画。最后通过实例的 export 方法导出动画数据传递给目标组件的c-animation属性。 参数 参数名 类型 必填 默认值 说明 object.duration number 否 400 动画持续时间，单位 ms object.delay number 否 0 动画延迟时间，单位 ms object.timingFunction string 否 'linear' 回调函数 object.transformOrigin string 否 '50% 50%' 定义变化过程的中心点 object.cb number function 无 回调函数 timingFunction 的合法值 值 说明 'linear' 动画从头到尾的速度是相同的 'ease' 动画以低速开始，然后加快，在结束前变慢 'ease-in' 动画以低速开始 'ease-in-out' 动画以低速开始和结束 'ease-out' 动画以低速结束 返回值 \b返回值 类型 说明 animation animation 动画实例 "},"api/createAnimation/animation/main.html":{"url":"api/createAnimation/animation/main.html","title":"Animation","keywords":"","body":"animation 动画实例 animation.export() 导出动画队列 animation.step(object Object) 表示一组动画完成。可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画 animation.rotate(number | number angle) 从原点顺时针旋转一个角度 animation.rotateX(number | number angle) 从 X 轴顺时针旋转一个角度 animation.rotateY(number | number angle) 从 Y 轴顺时针旋转一个角度 animation.rotateZ(number | number angle) 从 Z 轴顺时针旋转一个角度 animation.scale(number sx, number sy) 缩放 animation.scaleX(number scale) 缩放 X 轴 animation.scaleY(number scale) 缩放 Y 轴 animation.translate(number, number) 平移变换 animation.translateX(number) 对 X 轴平移 animation.translateY(number) 对 Y 轴平移 animation.opacity(number) 设置透明度 animation.backgroundColor(string value) 设置背景色 （目前只支持16进制） animation.width(number) 设置宽度 animation.height(number) 设置高度 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .translateX(200).step({duration: 1000}) .translateY(200).step({duration: 1000}) .width(100).step({duration: 1000}) .height(100).step({duration: 1000}) .backgroundColor('#000000').step({duration: 1000}) .opacity(0.1).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } wx web native 查看完整示例 "},"api/createAnimation/animation/step.html":{"url":"api/createAnimation/animation/step.html","title":".step","keywords":"","body":"animation.step(object Object) 表示一个动画动作的结束 参数 参数名 类型 必填 默认值 说明 duration number 否 400 动画持续时间，单位 ms delay number 否 0 动画延迟时间，单位 ms transformOrigin string 否 '50% 50%' 定义变化过程的中心点 cb number function 无 回调函数 timingFunction 的合法值 值 说明 'linear' 动画从头到尾的速度是相同的 'ease' 动画以低速开始，然后加快，在结束前变慢 'ease-in' 动画以低速开始 'ease-in-out' 动画以低速开始和结束 'ease-out' 动画以低速结束 返回值 返回值 \b返回值 类型 说明 animation animation 动画实例 "},"api/createAnimation/animation/rotate.html":{"url":"api/createAnimation/animation/rotate.html","title":".rotate","keywords":"","body":"animation.rotate() 从原点顺时针旋转一个角度 参数 参数 类型 说明 number number angle 旋转的角度 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .rotate(90).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/rotateX.html":{"url":"api/createAnimation/animation/rotateX.html","title":".rotateX","keywords":"","body":"animation.rotateX() 从 X 轴顺时针旋转一个角度 参数 参数 类型 说明 number number angle 旋转的角度 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .rotateX(90).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/rotateY.html":{"url":"api/createAnimation/animation/rotateY.html","title":".rotateY","keywords":"","body":"animation.rotateY() 从 Y 轴顺时针旋转一个角度 参数 参数 类型 说明 number number angle 旋转的角度 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .rotateY(90).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/rotateZ.html":{"url":"api/createAnimation/animation/rotateZ.html","title":".rotateZ","keywords":"","body":"animation.rotateZ() 从 Z 轴顺时针旋转一个角度 参数 参数 类型 说明 number number angle 旋转的角度 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .rotateZ(90).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/scale.html":{"url":"api/createAnimation/animation/scale.html","title":".scale","keywords":"","body":"animation.scale() 缩放 参数 参数 类型 说明 number sx number 当仅有 sx 参数时，表示在 X 轴、Y 轴同时缩放sx倍数 number sy number 在 Y 轴缩放 sy 倍数 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .scale(2, 2).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/scaleX.html":{"url":"api/createAnimation/animation/scaleX.html","title":".scaleX","keywords":"","body":"animation.scaleX() 缩放 X 轴 参数 参数 类型 说明 number sx number X 轴的缩放倍数 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .scaleX(2).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/scaleY.html":{"url":"api/createAnimation/animation/scaleY.html","title":".scaleY","keywords":"","body":"animation.scaleY() 缩放 Y 轴 参数 参数 类型 说明 number sx number Y 轴的缩放倍数 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .scaleY(2).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/translate.html":{"url":"api/createAnimation/animation/translate.html","title":".translate","keywords":"","body":"animation.translate() 对 X 轴坐标进行倾斜 参数 参数 类型 说明 number tx number 在 X 轴平移的距离 number ty number 在 Y 轴平移的距离 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .translate(100, 100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/translateX.html":{"url":"api/createAnimation/animation/translateX.html","title":".translateX","keywords":"","body":"animation.translateX() 在 X 轴平移 参数 参数 类型 说明 number tx number 在 X 轴平移的距离 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .translateX(100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/translateY.html":{"url":"api/createAnimation/animation/translateY.html","title":".translateY","keywords":"","body":"animation.translateY() 在 Y 轴平移 参数 参数 类型 说明 number ty number 在 Y 轴平移的距离 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .translateY(100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/opacity.html":{"url":"api/createAnimation/animation/opacity.html","title":".opacity","keywords":"","body":"animation.opacity() 设置透明度 参数 \b返回值 类型 说明 number value number 高度值 返回值 \b返回值 类型 说明 animation animation 动画实例 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .opacity(0.1).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/backgroundColor.html":{"url":"api/createAnimation/animation/backgroundColor.html","title":".backgroundColor","keywords":"","body":"animation.backgroundColor() 设置背景色 参数 \b参数名 类型 说明 string value string 颜色值（目前只支持16进制） 返回值 \b返回值 类型 说明 animation animation 动画实例 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .backgroundColor('#000000').step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/width.html":{"url":"api/createAnimation/animation/width.html","title":".width","keywords":"","body":"animation.width() 设置宽度 参数 \b参数名 类型 说明 number value Number 长度值 返回值 \b返回值 类型 说明 animation animation 动画实例 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .height(100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/height.html":{"url":"api/createAnimation/animation/height.html","title":".height","keywords":"","body":"animation.height() 设置高度 参数 \b参数名 类型 说明 number value number 长度值 返回值 \b返回值 类型 说明 animation animation 动画实例 示例 请点击我 import { createAnimation } from \"chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .height(100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/export.html":{"url":"api/createAnimation/animation/export.html","title":".export","keywords":"","body":"animation.export() 导出动画队列。export 方法每次调用后会清掉之前的动画操作，但会保留transtorm族和transformOrigin。 参数 无 返回值 \b返回值 类型 说明 animationData object 已生成的动画数据 "},"api/store/store.html":{"url":"api/store/store.html","title":"Store","keywords":"","body":"Store 通过 chameleon-store 创建的Store实例,有以下方法： ChameleonStore.createStore(options: Object): Object Store构造器。详细介绍 ChameleonStore.Store 实例方法 Store.commit(type: string, payload?: any) 提交 mutation。详细介绍 Store.dispatch(type: string, payload?: any) 分发 action。详细介绍 Store.mapState(map: Array | Object): Object 为组件创建计算属性以返回 store 中的状态。详细介绍 Store.mapGetters(map: Array | Object): Object 为组件创建计算属性以返回 getter 的返回值。详细介绍 Store.mapMutations(map: Array | Object): Object 创建组件方法提交 mutation。详细介绍 Store.mapActions(map: Array | Object): Object 创建组件方法分发 action。详细介绍 Store.registerModule(path: String, module: Module) 注册一个动态模块。详细介绍 "},"api/store/createStore.html":{"url":"api/store/createStore.html","title":"Store.createStore","keywords":"","body":"ChameleonStore.createStore // store.js import createStore from 'chameleon-store' const store = createStore({ ...options }) export default store createStore 构造器选项 state 类型: Object chameleon store 实例的根 state 对象。详细介绍 mutations 类型: { [type: string]: Function } 在 store 上注册 mutation，处理函数总是接受 state 作为第一个参数（如果定义在模块中，则为模块的局部状态），payload 作为第二个参数（可选）。 详细介绍 actions 类型: { [type: string]: Function } 在 store 上注册 action。处理函数总是接受 context 作为第一个参数，payload 作为第二个参数（可选）。 context 对象包含以下属性： { state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中 } 同时如果有第二个参数 payload 的话也能够接收。 详细介绍 getters 类型: { [key: string]: Function } 在 store 上注册 getter，getter 方法接受以下参数： state, // 如果在模块中定义则为模块的局部状态 getters, // 等同于 store.getters 当定义在一个模块里时会特别一些： state, // 如果在模块中定义则为模块的局部状态 getters, // 等同于 store.getters rootState // 等同于 store.state rootGetters // 所有 getters 注册的 getter 暴露为 store.getters。 详细介绍 modules 类型: Object 包含了子模块的对象，会被合并到 store，大概长这样： { key: { state, namespaced?, mutations, actions?, getters?, modules? }, ... } 与根模块的选项一样，每个模块也包含 state 和 mutations 选项。模块的状态使用 key 关联到 store 的根状态。模块的 mutation 和 getter 只会接收 module 的局部状态作为第一个参数，而不是根状态，并且模块 action 的 context.state 同样指向局部状态。 "},"api/store/commit.html":{"url":"api/store/commit.html","title":"Store.commit","keywords":"","body":"Store.commit 提交 mutation。 详细介绍 参数说明 参数 类型 必填 说明 type String 是 类型 payload any 否 载荷,传入的额外参数 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store // app.js store.commit('increment') "},"api/store/dispatch.html":{"url":"api/store/dispatch.html","title":"Store.dispatch","keywords":"","body":"Store.dispatch 分发 action。返回一个解析所有被触发的 action 处理器的 Promise。详细介绍 参数说明 参数 类型 必填 说明 type String 是 类型 payload any 否 载荷,传入的额外参数 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) } } }) export default store // app.js store.dispatch('incrementAsync') "},"api/store/mapState.html":{"url":"api/store/mapState.html","title":"Store.mapState","keywords":"","body":"Store.mapState 为组件创建计算属性以返回 chameleon store 中的状态。详细介绍 参数说明 参数 类型 必填 说明 map Array | Object 是 如果是对象形式，成员可以是一个函数。function(state: any) 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store // app.js import store from './store.js' class Index { // ... computed = store.mapState({ // 箭头函数可使代码更简练 count: state => state.count, // 传字符串参数 'count' 等同于 `state => state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) }; export default new Index(); "},"api/store/mapGetters.html":{"url":"api/store/mapGetters.html","title":"Store.mapGetters","keywords":"","body":"Store.mapGetters 为组件创建计算属性以返回 getter 的返回值。详细介绍 参数说明 参数 类型 必填 说明 map Array | Object 是 如果是对象形式，成员可以是一个函数。function(state: any) 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos: state => { return state.todos.filter(todo => todo.done) } } }) export default store // app.js import store from './store.js' class Index { // ... computed = { // 使用对象展开运算符将 getter 混入 computed 对象中 ...store.mapGetters([ 'doneTodosCount', //'anotherGetter' ]) } }; export default new Index(); "},"api/store/mapMutations.html":{"url":"api/store/mapMutations.html","title":"Store.mapMutations","keywords":"","body":"Store.mapMutations 创建组件方法提交 mutation。详细介绍 参数说明 参数 类型 必填 说明 map Array | Object 是 如果是对象形式，成员可以是一个函数。function(commit: function, ...args: any[]) 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store // app.js import store from './store.js' class Index { // ... methods = { ...store.mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` ]), ...store.mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) } }; export default new Index(); "},"api/store/mapActions.html":{"url":"api/store/mapActions.html","title":"Store.mapActions","keywords":"","body":"Store.mapActions 创建组件方法分发 action。详细介绍 参数说明 参数 类型 必填 说明 map Array | Object 是 如果是对象形式，成员可以是一个函数。function(dispatch: function, ...args: any[]) 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') } } }) export default store // app.js import store from './store.js' class Index { // ... methods = { ...store.mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` ]), ...store.mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } }; export default new Index(); "},"api/store/registerModule.html":{"url":"api/store/registerModule.html","title":"Store.registerModule","keywords":"","body":"Store.registerModule 注册一个动态模块。详细介绍 参数说明 参数 类型 必填 说明 path String 是 模块注册路径名 module Module 是 模块 示例 // 注册模块 `myModule` store.registerModule('myModule', { // ... }) "},"extend/advanced_use.html":{"url":"extend/advanced_use.html","title":"高级使用","keywords":"","body":"高级使用(Advanced) 多态协议 工程化 导入与导出 Native渲染能力接入 定制扩展端 "},"framework/polymorphism/intro.html":{"url":"framework/polymorphism/intro.html","title":"多态协议","keywords":"","body":"多态协议(Polymorphic protocol) 定义标准接口(interface)，各端模块各自独立实现，编译时和运行时对实现的接口输入输出做检查。 主要2个目标： 保障多端可维护性 编译时拆分多端代码 Chameleon的是多端的上层应用语言，在这样的目标下，用户扩展功能时，保障业务代码和各端通信一致性变得特别重要。 用户也许只实现一个API跨2端，保障一致很简单，在一个超过5万行代码的复杂应用里，用户扩展了100个接口呢，如果你觉得还很简单，那跨6个端呢，在应用持续高速迭代中让用户人肉保障多端一致性实在太艰难，即使能做到，可维护性也会极差，跨端也会失去意义。 以上，跨端很美好，最大风险是可维护性问题。多态协议是Chameleon业务层代码和各端底层组件和接口的分界点，Chameleon会严格“管制”输入输出值的类型和结构，同时会严格检查业务层JS代码，避免直接使用某端特有的接口，不允许在公共代码处使用某个端特定的方法，即使这段代码不会执行，例如禁止使用window、wx、my、swan、weex等方法。 统一多态协议设计的灵感来自于Apache Thrift - 可伸缩的跨语言服务开发框架，本质上跨端也属于跨语言。 它能让Chameleon开发者快速接入各个客户端底层功能，且不会因为各端接口差异、产品需求差异导致正常业务代码被打散，变得可读性差、难以维护，避免结果适得其反，具体Case；各个客户端底层功能实现可以一部分来自Chameleon提供的基础组件和基础api库，一部分来自chameleon开发者，一部分来自各端生态开源库（Chameleon拥抱开源社区，你可以直接安装某个端的组件在使用多态协议扩展到某个端使用）。 相关链接 接口多态 组件多态 "},"framework/polymorphism/api.html":{"url":"framework/polymorphism/api.html","title":"接口多态","keywords":"","body":"接口多态(Polymorphic function) 初始化多态接口 项目根目录下执行cml init component，选择Polymorphic function，输入文件名称，例如utils，生成如下文件结构 ├── components └──utils └── utils.interface 初始化文件内容如下： interface UtilsInterface { getMsg(msg: string): void; } class Method implements UtilsInterface { getMsg(msg) { return 'web:' + msg; } } export default new Method(); class Method implements UtilsInterface { getMsg(msg) { return 'weex:' + msg; } } export default new Method(); class Method implements UtilsInterface { getMsg(msg) { return 'wx:' + msg; } } export default new Method(); class Method implements UtilsInterface { getMsg(msg) { return 'alipay:' + msg; } } export default new Method(); class Method implements UtilsInterface { getMsg(msg) { return 'baidu:' + msg; } } export default new Method(); 文件中利用标签将各端代码进行物理隔离，利用cml-type属性指定平台。 cml-type=\"interface\"为接口定义部分，利用接口校验语法定义这个接口的方法及方法的参数与返回值。 cml-type=\"web|wx|weex|alipay|baidu\"为各端实现部分，按照interface接口的定义进行方法的实现输入输出。注意要以export default的形式导出对象。 cml-type=\"web\" 可以调用web端任意方法和全局变量 cml-type=\"wx\" 可以调用微信小程序端任意方法和全局变量 cml-type=\"alipay\" 可以调用支付宝小程序端任意方法和全局变量 cml-type=\"baidu\" 可以调用百度小程序端任意方法和全局变量 cml-type=\"weex\" 可以调用weex端任意方法和全局变量 调用多态接口 在需要使用多态接口的组件中引入，例如src/pages/index/index.cml中引用，代码如下： import utils from '../../components/utils/utils.interface' let message = utils.getMsg(); 场景举例 手把手教你系列- 实现多态API 扩展阅读 什么时候用到接口多态？ 接口多态适用于因为端的不同而进行不同接口的调用或者不同业务逻辑处理的场景。 例如:我们的页面现在需要一个本地存储功能的需求，我们已知各端的接口调用方法 web端接口是localStorage.setItem 微信小程序端的接口是wx.setStorageSync weex端的接口是storage.setItem 如果不使用接口多态我们只能根据不同环境去调用各自的接口 if(process.env.platform === 'web') { localStorage.setItem(key, value, function(e) { }); } else if(process.env.platform === 'wx') { wx.setStorageSync(key, value); } else if(process.env.platform === 'alipay') { my.setStorageSync(key, value); } else if(process.env.platform === 'baidu') { swan.setStorageSync(key, value); } else if(process.env.platform === 'weex') { storage.setItem(key, value, function(e) { }); } 这样的代码有如下\b\b待解决问题： 增加代码复杂度，难以维护 各端接口的参数不一致，\b写多种逻辑 各端接口耦合在一起，bug风险极高 没有做到各端代码的分离，增大代码体积 利用了接口多态之后的使用方式如下： import utils from 'utils.interface'; utils.setStorage(key, value,cb) utils.interface对setStorage进行了封装,文件内容如下： // 定义一个传参为string类型，返回值为undefine的函数类型 type Callback = (state: string) => undefined; // 定义模块的interface interface UtilsInterface { // 定义setStorage方法 参数个数及返回值类型 setStorage(key: string, value: string, cb: Callback ): undefined; } // web端\b接口实现 class Method \bimplements UtilsInterface { setStorage(key, value, cb) { try { localStorage.setItem(key, value); cb('success'); } cache(e) { cb('fail'); } } } export default new Method(); // weex端\b接口实现 class Method \bimplements UtilsInterface { setStorage(key, value, cb) { storage.setItem(key, value, function(e) { if (e.result == \"success\") { cb('success'); } else { cb('fail'); } }); } } export default new Method(); // wx端\b接口实现 class Method \bimplements UtilsInterface { setStorage(key, value, cb) { \btry { wx.setStorageSync(key, value); cb('success'); } catch(e) { cb('fail'); } } } export default new Method(); // alipay端\b接口实现 class Method \bimplements UtilsInterface { setStorage(key, value, cb) { \btry { my.setStorageSync(key, value); cb('success'); } catch(e) { cb('fail'); } } } export default new Method(); // baidu端\b接口实现 class Method \bimplements UtilsInterface { setStorage(key, value, cb) { \btry { swan.setStorageSync(key, value); cb('success'); } catch(e) { cb('fail'); } } } export default new Method(); 接口多态的优势 保证接口一致性 chameleon的目标是跨多端，接口多态的作用就是屏蔽各端差异，调用多态接口的代码运行在多端，如果保证不了一致性，很可能出现某一端的需求引起的接口改动影响到其他端的功能，导致线上问题。 我们\b设计了cml-type=\"interface\"接口定义部分，目的就是做一致性的校验，各端模块的构造函数要实现该接口，我们在开发环境运行时提供了接口的校验。 代码独立性 \b\b接口多态中利用标签对各端代码进行物理隔离，独立实现，每一端的编译只编译该端的代码，不会有任何影响。 \b充分扩展性 在独立性的基础上，就可以在各端的代码中完全使用各端的接口，以及引用各自端的第三方npm包。 "},"framework/polymorphism/component.html":{"url":"framework/polymorphism/component.html","title":"组件多态","keywords":"","body":"组件多态(Polymorphic component) chameleon在跨端的统一性上做了很多的工作，但即使是做到了99%的统一，仍然存在着1%的差异，基于代码可维护性的考量，chameleon引入了多态协议。 组件多态的使用 项目根目录下执行cml init component，选择Polymorphic component，输入组件名称，例如c-list，生成如下文件结构 ├── components │ ├── c-list │ │ ├── c-list.interface │ │ ├── c-list.web.cml │ │ ├── c-list.weex.cml │ │ ├── c-list.wx.cml │ │ ├── c-list.alipay.cml │ │ ├── c-list.baidu.cml │ │ └── ... interface 文件 .interface文件利用接口校验语法对组件的属性和事件进行类型定义，\b保证各端的组件和事件一致，框架在开发环境的运行时做校验。例如c-list.interface type eventType = 'change'; type eventDetail = { value: string } type changeEvent = (a: eventType, detail: eventDetail) => void; export default Interface Clist { name: string, age: number, changeEvent: changeEvent } *.[web|weex|wx|alipay|baidu].cml c-list.web.cml、c-list.weex.cml、c-list.wx.cml、c-list.alipay.cml、c-list.baidu.cml、... 文件是灰度区，它是唯一可以调用下层端组件的CML文件，分别是web、weex、wx、alipay、baidu五个端的调用入口。建议这一块代码尽量薄，只是用来调用下层端代码，不要编写过于重的代码。 在灰度区的template模板中： 调用下层全局组件或者引入的下层组件时，该组件传入的属性是各自下层端的语法，绑定的函数回调事件对象也是原始对象 引入的下层组件通过可以直接调用，传递各端下层属性语法 下层全局组件需添加origin-前缀，例如改成，传递各端下层语法，查看示例 调用普通CML内置组件或者引入的cml组件时，正常使用cml模板属性语法 在灰度区的script逻辑代码中： 可以调用下层端的全局变量和任意方法，以及下层端的生命周期。 也可以正常使用普通cml逻辑代码。 在灰度区的style样式代码中： 可以使用下层端css语法。 也可以正常调用cmss语法。 在灰度区的json配置代码中： *web.cml：base.usingComponents可以引入任意.vue扩展名的普通vue组件文件，路径规则见组件配置 *wx.cml：base.usingComponents可以引入普通微信小程序组件，路径规则见组件配置 *alipay.cml：base.usingComponents可以引入普通支付宝小程序组件，路径规则见组件配置 *baidu.cml：base.usingComponents可以引入普通百度小程序组件，路径规则见组件配置 *weex.cml：base.usingComponents可以引入支持.vue扩展名的普通weex组件文件，路径规则见组件配置 使用举例 手把手教你系列- 实现多态 echart 扩展阅读 什么时候用到组件多态？ chameleon中的组件是采用单文件格式的cml文件，其中包括了一个组件所拥有的视图层、逻辑层及配置信息。考虑以下两种场景： 场景一：当某个功能组件需要调用各端的原生组件，各端原生组件的属性不一致，或者一端有原生组件，其他端需要组合实现等。 场景二：产品在需求上导致某一个组件在各端的结构表现不同。 为什么要引入多态协议 以场景一为例，先看一个最容易理解的跨端组件实现： {{item.name}} // 假设wx-list 是微信小程序原生的组件 // 假设alipay-list 是微信小程序原生的组件 // 假设baidu-list 是微信小程序原生的组件 // 假设list 是weex端原生的组件 上面的代码块是一个简单的列表实现，wx和weex都是使用了各自的原生组件，这样的实现方法其实是把三端或者N端的模版放在了同一个文件中，当然，这里只是展示了模版的复杂，假设在js代码块中也存在着端的判断，那代码的复杂可想而知。 总结下来，这样的代码有如下\b\b待解决问题： 增加代码复杂度，难以维护 各端组件的属性和事件定义可能不一致 各端组件耦合在一起，bug风险极高 没有做到各端代码的分离，增大体积 而利用了组件多态之后的使用方式如下： 可以看到我们只引用了一个c-list组件，该组件提供了统一的属性。 "},"framework/polymorphism/api_extend.html":{"url":"framework/polymorphism/api_extend.html","title":"接口多态扩展","keywords":"","body":"接口多态的扩展 (chameleon-tool@0.4.0-mvvm.3开始支持) 接口多态一节讲解了接口多态的使用，这一节讲解接口多态的一些扩展语法，更适用于扩展新端使用。 1 扩展语法 1.1 include标签 当前interface文件用标签可以引入其他.interface文件，代表采用该文件的接口定义和实现。然后还可以再当前文件中去实现引入的接口定义，可以覆写引入的某一端实现，也可以去扩展新端的实现。 语法是，有如下规则： src属性指向的文件路径不支持webpack别名，只能是相对路径或者npm包名开始。 src指向的.interface文件中必须有接口定义部分。 使用了语法后，当前文件中不能有接口定义部分。 文件中只能出现一个标签 例如扩展新端API（以头条小程序为例，假设端扩展标识为：toutiao）: // 引入官方标准interface文件 // 扩展实现新端（以头条小程序为例，假设端扩展标识为：toutiao） class Method implements uiInterface { alert(opt, successCallBack, failCallBack) { // 根据头条小程序实现alert弹窗 let { message, confirmTitle} = opt; tt.showModal({ showCancel: false, title: '', content: message, confirmText: confirmTitle, success() { successCallBack(confirmTitle); }, fail() { failCallBack(confirmTitle); } }); } } export default new Method(); // 想覆写某已有端的方法实现（以微信小程序为例） class Method implements uiInterface { alert(opt, successCallBack, failCallBack) { // 按你的想法重新实现 } } export default new Method(); 1.2 script src属性 标签可以通过指定src的方式引用外部js文件为某一平台或某几个的实现或者接口定义。 有如下规则： src属性指向的文件路径不支持webpack别名，只能是相对路径或者npm包名开始。 cml-type属性为字符串，如果多个端可以用英文逗号 , 进行分割，例如 cml-type=\"web,wx\". 例如： interface FirstInterface { getMsg(msg: String): String; } web.js文件内容如下： class Method implements FirstInterface { getMsg(msg) { return 'web:' + msg; } } export default new Method(); 2 多态API查找优先级 没有扩展语法之前，每个端的实现都在同一个文件中，没有优先级的问题，但是有了扩展语法之后，就会有优先级问题。查找优先级如下： 文件内部的定义, 包括采用src的形式指定其他文件 src属性指向的interface文件中继续查找该部分 注意文件内的interface定义部分不能和include同时存在 例如有如下两个interface文件： ├── first │ └── first.interface └── second └── second.interface first.interface 包括接口定义，web和weex端的实现，内容如下： interface FirstInterface { getMsg(msg: String): String; } class Method implements FirstInterface { getMsg(msg) { return 'first web:' + msg; } } export default new Method(); class Method implements FirstInterface { getMsg(msg) { return 'first weex:' + msg; } } export default new Method(); second.interface 包括对first.interface的include weex端和wx端的实现，内容如下： class Method implements FirstInterface { getMsg(msg) { return 'second weex:' + msg; } } export default new Method(); class Method implements FirstInterface { getMsg(msg) { return 'second wx:' + msg; } } export default new Method(); 当外部引用second.interface文件并调用getMsg方法时 各端编译获取方法如下： web端，因为second.interface中没有web端实现 所以查找到first.interface中web端getMsg方法 weex端，因为second.interface中有weex端实现 所以使用second.interface中weex端getMsg方法 wx端，因为second.interface中有wx端实现 所以使用second.interface中wx端getMsg方法 "},"framework/polymorphism/component_extend.html":{"url":"framework/polymorphism/component_extend.html","title":"组件多态扩展","keywords":"","body":"组件多态的扩展 (chameleon-tool@0.4.0-mvvm.3开始支持) 组件多态一节讲解了组件多态的使用，这一节讲解组件多态的一些扩展语法，更适用于扩展新端使用。 1 扩展语法 1.1 include标签 多态组件的.interface文件内部可以用标签引入其他多态组件的.interface文件，代表采用该文件的接口定义和对应的各端实现。 语法是，有如下规则： src属性指向的文件路径不支持webpack别名，只能是相对路径或者npm包名开始。 src指向的.interface文件中必须有接口定义部分。 使用了语法后，当前文件中不能有接口定义部分。 文件中只能出现一个标签 例如扩展新端组件（以头条小程序为例，假设端扩展标识为：toutiao）: 编写 my-ui-builtin/button/button.interface // 引入官方标准interface文件 再编写 my-ui-builtin/button/button.toutiao.cml // 扩展实现新端（以头条小程序为例，假设端扩展标识为：toutiao），具体代码可参考在其他端的实现如：chameleon-ui-builtin/components/button/button.wx.cml {{text}} // js实现部分 // 样式部分 // json配置 这样在引用my-ui-builtin/button/button这个多态组件时，就会有chameleon-ui-builtin中button支持的端和自己扩展的端。 1.2 script src属性 标签可以通过指定src的方式引用cml文件作为某一平台或某几个平台的实现或者接口定义。 有如下规则： src属性指向的文件路径不支持webpack别名，只能是相对路径或者npm包名开始。 cml-type属性为字符串，如果多个端可以用英文逗号 , 进行分割，例如 cml-type=\"web,wx\"。 例如上面扩展button的例子可以写成 下面的形式 编写 my-ui-builtin/button/button.interface // 引入官方标准interface文件 再编写 my-ui-builtin/button/mybutton.cml // 扩展实现新端（以头条小程序为例，假设端扩展标识为：toutiao），具体代码可参考在其他端的实现如：chameleon-ui-builtin/components/button/button.wx.cml {{text}} // js实现部分 // 样式部分 // json配置 多态组件查找优先级 没有扩展语法之前，采用的是各端的实现和.interface文件保持同名的方式，各端有各自的端标识后缀，有了扩展语法之后这种约定同名的方式被打破。 多态组件的查找从interface作为入口进行查找，多态组件的查找，包含在组件的查找内，所以这里直接讲组件的查找优先级。 以一个例子进行说明 组件引用 { \"usingComponents\": { \"demo-com\": \"/componnets/button/button\" } } 文件结构 ├── components ├── button └── button.interface └── custombutton.cml └── button.toutiao.cml └── button.cml button.interface内容如下： // 引入官方标准interface文件 当前端标识为toutiao查找优先级如下： 1 找/componnets/button/button.interface文件，如果里面的cmltype等于当前端标识toutiao,则找到的src属性指向的cml文件。本例子中是custombutton.cml 2 找/componnets/button/button.interface文件 对应同名的带有当前端标识的cml文件，本例子中是button.toutiao.cml 3 找/componnets/button/button.interface文件，里面的标签的src指向的.interface文件，以该文件进行递归执行1，2步的查找。 3 找非多态组件/componnets/button/button.cml文件 4 找各平台的原生组件例如/componnets/button/button.vue,/componnets/button/button.wxml ，还有扩展新端中用户可以自定义查找 "},"framework/engineering.html":{"url":"framework/engineering.html","title":"工程化","keywords":"","body":"工程化(Engineering) 工程化是使用软件工程的技术和方法对项目的开发、上线和维护进行管理。chameleon的工程化包含如下几个大方面： 1 模块化，项目中的文件统一以模块化的方式引入，包括.css,.js以及定义的interface文件，这样做有如下好处避免变量污染与命名冲突，提高代码的复用率，提高代码的可维护性。 2 组件化，chameleon定义了.cml文件，以组件为单位，将一个组件需要的视图、逻辑、样式、配置采用单文件的形式进行开发，提高了代码的可读性。 3 本地开发解决方案，chameleon提供了大量的工程化方法，解决本地开发时的各种痛点，包括 提供dev服务，mock数据等能力，达到不依赖后端实现开发的前后端分离。 提供\b热更新，自动刷新，调试窗口，线上资源代理等能力，提高本地开发时的效率。 4 线上部署解决方案，chameleon的构建是完全配置化的，内置线上线下两种构建模式，线上工程化相关功能包括 线上静态资源的路径指定 \b基于文件内容的文件指纹 减少文件体积的代码压缩 5 渐进式使用，chameleon提供了两种渐进式使用的方式，一种是将chameleon的组件导出成各端的原生组件，第二种方式是引用插件在webpack项目中使用chameleon组件与接口。 相关链接 数据mock 资源定位 文件指纹 代码压缩 热更新与自动刷新 代理调试 Chameleon URL 规范与校验 "},"framework/mock.html":{"url":"framework/mock.html","title":"数据 mock","keywords":"","body":"数据mock 如何mock api请求 如果需要mock多个域名的api请参见api多域名mock。 1、 使用内置网络请求接口发起网络请求。例如： import cml from \"chameleon-api\"; cml.get({ url: '/api/getdriver' }) .then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }); 调用方法的参数url中只需要写api的路径。那么本地dev开发模式如何mock这个api请求以及build线上模式如何请求线上地址，就需要在配置文件中配置apiPrefix。 2、 配置apiPrefix dev开发模式和build模式配置的apiPrefix会拼接到网络请求的url前，dev模式不配置时，默认为当前启动web服务的ip+端口。上面的例子中如果本地ip为198.168.1.1 启动端口为8000。dev模式发起的网络请求为198.168.1.1:8000/api/getdriver, build模式发起的网络请求为http://api.chameleon.com/api/getdriver。 // 设置api请求前缀 const apiPrefix = 'http://api.chameleon.com'; cml.config.merge({ wx: { dev: { }, build: { apiPrefix } } }) 3、 配置本地mock数据 前两步操作实现了网络请求dev模式请求本地，build模式请求线上，这一步就讲解如何mock本地请求数据。 在/mock/api/文件夹下创建mock数据的js文件。文件内容格式如下： module.exports = [ { method: 'get', path: '/api/getdriver', controller: function (req, res, next) { console.log('/api/driver/getList') res.json({ total: 100, driverList: [] }); }, } ] method指定请求方法，默认值['get','post'] path指定请求的路径 controller 是express的中间件形式，在中间件中可以做任何操作最后调用res的方法返回结果。 启动dev模式后，通过ip+端口+path即可访问配置的api请求。结合上面讲到的网络请求方法，即可实现本地的api数据mock。 【扩展】如何在本地dev模式请求线上数据？ 可以在mock文件的controller中请求对应的线上数据，例如可以使用request模块实现请求。 如何mock php模板下发数据 /mock/template/文件夹下存放的php文件是下发的模板数据，php文件内将下发的数据赋值给$chameleon对象，例如： 0, \"errmsg\" => \"\", \"pageData\" => array( \"pageInfo\" => array( \"title\" => \"chameleon\", \"content\" => \"chameleon跨端\" ) ) ); ?> 在模板中通过变量pageData,errno,errmsg接收。 var pageData = {json_encode($pageData)} var errno = {json_encode($errno)} var errmsg = {json_encode($errmsg)} 同时还模拟了与模板下发的pageData相同的ajax请求，只需在当前访问页面的url上添加puredata=1参数。 { errno: 0, errmsg: '', pageData: { pageInfo: { title: 'chameleon', content: 'chameleon跨端' } } } "},"framework/newmock.html":{"url":"framework/newmock.html","title":"api 多域名 mock","keywords":"","body":"api多域名mock 在数据mock一节讲述了如何进行api数据的mock，但是只局限于所有api请求都是相同域名的情况，工作中可能出现一个项目请求多个域名的api接口，本节将讲解如和进行多域名的mock。 1 版本要求 chameleon-tool >= 0.2.0-alpha.0 chameleon-api >= 0.3.0-alpha.4 2 chameleon.config.js中配置多域名信息 domain对象配置多域名的信息。 domain, Object 类型。 配置在base对象中，可以作为所有平台的公共配置，dev模式中配置的localhost会替换成当前dev模式启动的web服务ip+端口。 具体使用文档参见api多域名mock 例如： cml.config.merge({ base: { dev: { domain: { domain1: \"localhost\", domain2: \"localhost\" }, }, build: { domain: { domain1: \"http://api.cml.com\", domain2: \"http://api2.cml.com\" }, } }, }) 3 使用 chameleon-api 发网络请求 chameleon-api的网络请求get、post、request方法中添加domain参数。 chameleon.config.js中添加的domain对象配置，在项目中可以通过process.env.domain变量访问。 例如： import cml from \"chameleon-api\"; cml.get({ domain: process.env.domain.domain1, url: '/api/getMessage' }) .then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }); 4 配置mock数据 前两步操作实现了网络请求dev模式请求本地，build模式请求线上，这一步就讲解如何mock本地多域名的请求数据。 在/mock/api/文件夹下创建mock数据的js文件。文件内容格式如下： module.exports = [{ domainKey: 'domain1', request: [ { method: ['get', 'post'], path: '/api/getMessage', controller: function (req, res, next) { res.json({ total: 0, message: [{ name: 'Hello chameleon! domain1' }] }); } } ] }, { domainKey: 'domain2', request: [ { method: ['get', 'post'], path: '/api/getMessage', controller: function (req, res, next) { res.json({ total: 0, message: [{ name: 'domain2!' }] }); } } ] }] domainKey 指定mock的域名，对应chameleon.config.js中domain对象的key值。 method指定请求方法，默认值['get','post'] path指定请求的路径 controller 是express的中间件形式，在中间件中可以做任何操作最后调用res的方法返回结果。 "},"framework/source_location.html":{"url":"framework/source_location.html","title":"资源定位","keywords":"","body":"资源定位 静态资源引用 模板中引用静态资源，不能直接将资源的路径写在模板中，而是要通过js中require该静态资源得到变量，在模板中引用该变量。 该路径会根据项目配置的publicPath自动替换成正确路径。利用该功能可以实现\b静态资源\b开发路径和部署路径之间的\b分离，开发者只需要写相对路径，线上可以通过设置publicPath指定任意路径。 --> class Index { data = { imgPath: require(\"./assets/logo.png\") } }; export default new Index(); 图片base64\b 支持在引用图片url后面添加inline参数，以指定图片的base64格式，例如： class Index { data = { imgPath: require(\"./assets/logo.png?__inline\") } }; export default new Index(); "},"framework/devproxy.html":{"url":"framework/devproxy.html","title":"代理调试","keywords":"","body":"代理模式开发 调试线上编译处理过的非可读性代码，可以使用本功能 通过简单的chameleon配置将线上文件代理到线下的开发环境，这样就可以通过修改线下的源码debug线上页面了，使用方法如下： 第一步 chameleon.config.js中开启代理模式: { ... proxy: { enable: true, } ... } 第二步 执行以下命令 cml dev 第三步 根据调试面板打印的信息给手机安装证书 第四步 根据上图提示将手机代理到相应的端口 完成以上步骤就可以进行代理开发了。 默认代理了weex和web端的js和css文件，如需代理更多文件，可以\b添加mapremote配置，方法如下： { ... proxy: { enable: true, mapremote: [{ from: 'https://a.b.com/weex/aaa_(.+).js', to: 'http://localhost:8000/weex/aaa.js' },{ from: 'https://a.b.com/weex/bbb_(.+).js', to: 'http://localhost:8000/weex/bbb.js' }] } ... } "},"framework/chameleon_url.html":{"url":"framework/chameleon_url.html","title":"Chameleon URL","keywords":"","body":"一个完整 Chameleon URL 一个 Chameleon URL 能在多端运行，在普通浏览器/webview运行 web 端，小程序运行小程序端，Native渲染（weex）则拉取对应的 JS Bundle并展现，完整地址如下，使用场景包含： a.跨应用页面之间跳转使用 open 接口 b.服务端下发给端（weex/浏览器/小程序）进行跳转 https://h5地址? cml_addr=jsbundle地址& path=路由path(通用字段)& envVersion=要打开的小程序版本(通用字段)& weixin_appid=123456& weixin_path=微信小程序路由path& weixin_envVersion=要打开的微信小程序版本& baidu_appid=123456& baidu_path=百度小程序路由path& baidu_envVersion=要打开的百度小程序版本& alipay_appid=123456& alipay_path=支付宝小程序路由path 参数 作用 说明 h5地址 H5端的地址或者用于提示bundle出错的h5地址 \b如果你没有h5地址，可以选择将h5地址写为jsbundle地址（后面的cml_addr\b\b=jsbundle地址依然需要）。 cml_addr 描述weex/rn js bundle地址 内部非使用sdk开发者\b暂时使用cml_addr字段 path 描述应用里面的页面路由， 即路由里面的path值 若未填写weixin_path, baidu_path, alipay_path时, 统一使用该字段 envVersion 要打开的小程序版本 有效值 develop（开发版），trial（体验版），release（正式版） ，仅在当前小程序为开发版或体验版时此参数有效(仅支持微信小程序和支付宝小程序) weixin_appid 描述微信小程序的app id 微信小程序跳转需要 appid weixin_path 描述应用里面的页面路由(目标微信小程序为非chameleon项目时可用) weixin_envVersion 要打开的小程序版本 有效值 develop（开发版），trial（体验版），release（正式版） ，仅在当前小程序为开发版或体验版时此参数有效(该字段仅对微信小程序跳转生效) baidu_appid 描述百度小程序的appKey 百度小程序跳转需要 appKey baidu_path 描述应用里面的页面路由(目标百度小程序为非chameleon项目时可用) alipay_appid 描述支付宝小程序的app id 支付宝小程序跳转需要 appid alipay_path 描述应用里面的页面路由(目标支付宝小程序为非chameleon项目时可用) alipay_envVersion 要打开的小程序版本 有效值 develop（开发版），trial（体验版），release（正式版） ，仅在当前小程序为开发版或体验版时此参数有效(该字段仅对支付宝小程序跳转生效) "},"framework/polymorphism/standards.html":{"url":"framework/polymorphism/standards.html","title":"规范与校验","keywords":"","body":"规范与校验 按照框架定义，有相应的目录规范，文件规范，文件内容规范等，按照规范编写代码，可以最大程度的减少开发、调试时间。 另，框架提供了校验工具，让开发者可以提前发现不符合规范的问题，提高效率。 接口语法校验 全局变量校验 代码规范校验 "},"framework/polymorphism/check.html":{"url":"framework/polymorphism/check.html","title":"接口语法校验","keywords":"","body":"接口校验语法 接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）进行沟通。 校验配置 通过配置决定是否开启接口的校验。 Object、Array、Nullable这三个类型默认是不支持的，因为我们建议更精确的校验，可以通过配置文件开启这三个类型。 具体参见多态校验控制的配置 类型说明 \b注意：建议定义类型的时候取值为 Number String Boolean Null Undefined(Void) Object Array Function Date RegExp 目前chameleon接口定义支持简单类型和复合类型。 其中简单类型包括以下类型： Number(number) String(string) Boolean(bool) Undefined(void) Null 复合类型包括以下类型： Function Object Array Date RegExp 接口语法 接口的使用分两个过程： 定义一个接口。 定义实现接口的类。 接口定义 范式: interface [接口名称] { // 接口中的属性 [属性名称]: [类型], // 接口中的方法 [方法名称]([传入参数1名称]: [传入参数1类型], [传入参数2名称]: [传入参数2类型], ...): [返回类型] } 举例： // 一个名为interface1的接口 interface interface1 { // foo1: 传入分别为string和number的两个数据，返回值类型为string值 foo1(a: string, b: number): string; // foo2: 传入分别为string和Callback(上文定义)的两个数据，返回值类型为bool值 foo2(c: string, d: Callback): Boolean; } 实现接口（定义类） 范式： class [类名称] implaments [接口名称] { // 实现接口中的属性 [属性名称]: [类型] // 实现接口中的方法 [方法名称]([传入参数1名称], [传入参数2名称], ...) { return [返回值]; } } 举例： // 实现一个名称为Clazz，实现上文定义的interface1接口 class Clazz implaments interface1 { // 实现interface1定义的foo1方法，输入值和输出值要满足定义 foo1(a, b) { return 'hello ' + a + ' : ' + (b + 1); } // 实现interface1定义的foo2方法，输入值和输出值要满足定义 foo2(c, d) { return 'balabala...'; } } 复合类型的定义范式 type [类型名称] = [类型定义] 不同的复合类型，类型定义也不相同，下面会对三种复合类型做详细说明。 Function类型定义 范式: type [Function类型名称] = ([传入参数1名称]: [传入参数1类型], [传入参数2名称]: [传入参数2类型], ...) => [返回类型] 举例： // 定义一个传参分别为number,string,bool类型的三个参数，返回值为number的函数类型 type Callback = (a: number, b: string, c: bool) => number; Object类型定义 范式： type [Object类型名称] = { [属性名称1]: [类型1], [属性名称2]: [类型2] } 举例： // 定义含有a,b,c三个属性的复合类型 type Scheme = { a: string, b: bool, c: number } Array类型定义 范式： type [Array类型名称] = [ [类型1] ] 举例： // 定义名称为arrayType1的数组类型，数组元素为number类型 type arrayType1 = [ number ] 目前数组的详细校验只能校验数组中的元素是同一种类型，即[1,2,3],而不能校验 [1,2,'this is string']; 如果想要校验某个入参或者函数的返回值是一个数组，但是数组中的值得类型不是同一类型 或者只想简单的对某个对象进行类型校验，但是对象中具体的key-value值不想校验； 那么在- 项目配置开启['Object','Array']直接校验的前提下，可以如下写**interface EntryInterface { handleDate(arr:Array,o:Object) : Array } class Method implements EntryInterface { let arr = [1,2,3,'str']; let obj = {address:'China'} handleDate(arr,obj){ return ['this is str',{name:\"jhon\"}]; } } 此时校验就只会校验入参或者返回值得数据类型是否是 Array 或者 Object ，而不会深入校验数组或者对象中的元素； 复合类型中的相互嵌套 Function、Object、Array三种复合类型可以互相嵌套： // 定义一个传参分别为number,string,bool类型的三个参数，返回值为number的函数类型 type Callback = (a: number, b: string, c: bool) => number; // 定义名称为arrayType1的数组类型，数组元素为number类型 type arrayType1 = [ number ] // 定义名称为Scheme的，含有Array类型和Function类型属性的Object类型 type Scheme = { a: arrayType1, b: Callback, } // 定义名称为Plan，含有Scheme类型和Callback的属性的Object类型 type Plan = { a: string, b: Scheme, c: Callback } // 定义名称为arrayType1类型，元素为Plan类型 type arrayType1 = [ Plan ] Date 类型的定义 如果函数参数或者返回值是 Date 数据类型，那么可以按照下面的方式进行定义； interface EntryInterface { handleDate(d:Date) : Date } class Method implements EntryInterface { handleDate(d){ return new Date(); } } RegExp 类型的定义 如果函数参数或者返回值是 RegExp 数据类型，那么可以按照下面的方式进行定义； interface EntryInterface { handleDate(d:RegExp) : RegExp } class Method implements EntryInterface { handleDate(r){ return new RegExp(); } } Maybe Types : 意味着该值可能是这种类型，但是也可能是 undefined 或者 null 注意如果要定义Nullable（?Number）这样的参数，那么该参数的占位符是必须的 interface EntryInterface { acceptsMaybeNumber(a:? Number,b:String,c:Boolean) : Undefined } class Method implements EntryInterface { acceptsMaybeNumber(a,b,c){ } } acceptsMaybeNumber(42,'str',true); // Works! acceptsMaybeNumber(undefined,'str',true); // Works! acceptsMaybeNumber(null,'str',true); // Works! acceptsMaybeNumber(\"42\",'str',true); // Error! //**注意如果要定义Nullable（?Number）这样的参数，那么该参数的占位符是必须的,在校验入参的时候，会按照interface中定义的顺序，有序的校验传入的参数是否和interface中定义的数据参数类型一直，(?Number)这种定义的校验其实只是说明这个参数可以是 null undefined number类型的数据，但是是必须传递的** acceptsMaybeNumber('str',true); // Error! "},"framework/global_check.html":{"url":"framework/global_check.html","title":"全局变量校验","keywords":"","body":"全局变量校验 chameleon的代码最终会运行在多端框架中，每一个端都会有一些特有的全局变量，chameleon内部维护了一个各端全局变量的散列表如下表所示。 全局变量校验校验的是某一端运行的代码中存在其他端的全局变量并且不是当前端的全局变量。例如非微信小程序端的\b代码中不能出现wx全局变量，非百度小程序的代码中不能出现\bswan全局变量。 可以通过项目配置决定是否开启全局变量校验，还可以配置哪些文件是白名单文件不进行校验。 端全局变量 微信小程序[\"wx\"] 百度小程序[\"swan\"] weex[\"weex\"] 支付宝小程序[\"my\"] web[\"postMessage\",\"blur\",\"focus\",\"close\",\"frames\",\"self\",\"window\",\"parent\",\"opener\",\"top\",\"length\",\"closed\",\"location\",\"document\",\"origin\",\"name\",\"history\",\"locationbar\",\"menubar\",\"personalbar\",\"scrollbars\",\"statusbar\",\"toolbar\",\"status\",\"frameElement\",\"navigator\",\"customElements\",\"external\",\"screen\",\"innerWidth\",\"innerHeight\",\"scrollX\",\"pageXOffset\",\"scrollY\",\"pageYOffset\",\"screenX\",\"screenY\",\"outerWidth\",\"outerHeight\",\"devicePixelRatio\",\"clientInformation\",\"screenLeft\",\"screenTop\",\"defaultStatus\",\"defaultstatus\",\"styleMedia\",\"onanimationend\",\"onanimationiteration\",\"onanimationstart\",\"onsearch\",\"ontransitionend\",\"onwebkitanimationend\",\"onwebkitanimationiteration\",\"onwebkitanimationstart\",\"onwebkittransitionend\",\"isSecureContext\",\"onabort\",\"onblur\",\"oncancel\",\"oncanplay\",\"oncanplaythrough\",\"onchange\",\"onclick\",\"onclose\",\"oncontextmenu\",\"oncuechange\",\"ondblclick\",\"ondrag\",\"ondragend\",\"ondragenter\",\"ondragleave\",\"ondragover\",\"ondragstart\",\"ondrop\",\"ondurationchange\",\"onemptied\",\"onended\",\"onerror\",\"onfocus\",\"oninput\",\"oninvalid\",\"onkeydown\",\"onkeypress\",\"onkeyup\",\"onload\",\"onloadeddata\",\"onloadedmetadata\",\"onloadstart\",\"onmousedown\",\"onmouseenter\",\"onmouseleave\",\"onmousemove\",\"onmouseout\",\"onmouseover\",\"onmouseup\",\"onmousewheel\",\"onpause\",\"onplay\",\"onplaying\",\"onprogress\",\"onratechange\",\"onreset\",\"onresize\",\"onscroll\",\"onseeked\",\"onseeking\",\"onselect\",\"onstalled\",\"onsubmit\",\"onsuspend\",\"ontimeupdate\",\"ontoggle\",\"onvolumechange\",\"onwaiting\",\"onwheel\",\"onauxclick\",\"ongotpointercapture\",\"onlostpointercapture\",\"onpointerdown\",\"onpointermove\",\"onpointerup\",\"onpointercancel\",\"onpointerover\",\"onpointerout\",\"onpointerenter\",\"onpointerleave\",\"onafterprint\",\"onbeforeprint\",\"onbeforeunload\",\"onhashchange\",\"onlanguagechange\",\"onmessage\",\"onmessageerror\",\"onoffline\",\"ononline\",\"onpagehide\",\"onpageshow\",\"onpopstate\",\"onrejectionhandled\",\"onstorage\",\"onunhandledrejection\",\"onunload\",\"performance\",\"stop\",\"open\",\"alert\",\"confirm\",\"prompt\",\"print\",\"requestAnimationFrame\",\"cancelAnimationFrame\",\"requestIdleCallback\",\"cancelIdleCallback\",\"captureEvents\",\"releaseEvents\",\"getComputedStyle\",\"matchMedia\",\"moveTo\",\"moveBy\",\"resizeTo\",\"resizeBy\",\"getSelection\",\"find\",\"webkitRequestAnimationFrame\",\"webkitCancelAnimationFrame\",\"fetch\",\"btoa\",\"atob\",\"createImageBitmap\",\"scroll\",\"scrollTo\",\"scrollBy\",\"onappinstalled\",\"onbeforeinstallprompt\",\"crypto\",\"ondevicemotion\",\"ondeviceorientation\",\"ondeviceorientationabsolute\",\"indexedDB\",\"webkitStorageInfo\",\"sessionStorage\",\"localStorage\",\"chrome\",\"visualViewport\",\"speechSynthesis\",\"webkitRequestFileSystem\",\"webkitResolveLocalFileSystemURL\",\"openDatabase\",\"applicationCache\",\"caches\",\"whichAnimationEvent\",\"animationendEvent\",\"infinity\",\"SETTING\",\"AppView\",\"ExtensionOptions\",\"ExtensionView\",\"WebView\",\"iconPath\",\"_app\",\"_ZOOM_\",\"Feed\",\"md5\",\"$\",\"jQuery\",\"Search\",\"windmill\",\"Lethargy\",\"alertTimeOut\",\"supportApps\",\"lethargyX\",\"lethargyY\",\"iView\",\"onModuleResLoaded\",\"iEditDelete\",\"infinityDrag\",\"i\",\"array\",\"TEMPORARY\",\"PERSISTENT\",\"addEventListener\",\"removeEventListener\",\"dispatchEvent\"] "},"framework/linter.html":{"url":"framework/linter.html","title":"代码规范校验","keywords":"","body":"代码规范校验 核心文件校验 检查以下文件是否存在 chameleon.config.js src/app/app.cml src/router.config.json CML文件规范校验 多文件cml格式下，是否存在interface文件 命名名称是否符合规范 模板规范校验 根据模板语法(lang=vue|cml)校验语法是否正确 模板中组件使用是否符合规范 脚本规范校验 编写一端代码逻辑时，如果使用其他端的全局变量，会校验失败。 使用未定义的event名称时，会报错 使用未定义的prop名称时，会报错 样式规范校验 满足css规则 不支持级联 配置规范校验 json格式是否合法 usingComponents只放置在base字段下 "},"framework/linter/core.html":{"url":"framework/linter/core.html","title":"核心文件校验","keywords":"","body":"核心文件校验 根据chameleon目录结构，确定核心文件的位置，保证chameleon项目能够正常运行。 目录结构 ├── chameleon.config.js // 项目的配置文件 ├── dist // 打包产出目录 ├── mock // 模拟数据目录 ├── node_modules // npm包依赖 ├── package.json └── src // 项目源代码 ├── app // app入口 ├── components // 组件文件夹 ├── pages // 页面文件夹 ├── router.config.json // 路由配置文件 └── store // 全局状态管理 核心文件列表 会对以下核心文件进行检查： chameleon.config.js src/app/app.cml src/router.config.json "},"framework/linter/cml-file.html":{"url":"framework/linter/cml-file.html","title":"CML 文件规范校验","keywords":"","body":"CML文件规范校验 CML文件规范校验包括校验以下三个规范： CML文件命名规范 CML文件内容规范 CML Interface内容规范 CML文件命名规范 以cml后缀结尾的文件分两种情况： 1. 多端实现完全一致组件命名格式： [component name].cml 组件所有逻辑实现在同一文件中 举例： demo.cml 2. 多端实现不一致组件命名格式： [component name].[weex|wx|alipay|baidu|web].cml 组件文件名按照适配端命名，需要同一目录下的interface文件组合使用 [component name].interface 举例： demo.interface demo.weex.cml demo.wx.cml demo.alipay.cml demo.baidu.cml demo.web.cml CML文件内容规范 cml文件中可能包括以下几个字段标签 template(template规范)：标签中书写组件的视图层结构，chameleon自定义了一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。 style(CMSS规范)：标签中书写组件的样式, 描述视图中的元素样式。 script(script规范)：标签中填充编写组件逻辑层响应页面操作的代码。 json(json规范)：标签中书写组件的配置信息。 举例： // demo.cml code class Index { } export default new Index(); #banner { background-color: #ff0000; } { \"base\":{ \"usingComponents\": { } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" }, \"alipay\": { \"defaultTitle\": \"index\", \"pullRefresh\": false, \"allowsBounceVertical\": \"YES\", \"titleBarColor\": \"#ffffff\" }, \"baidu\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"index\", \"backgroundColor\": \"#ffffff\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": false, \"onReachBottomDistance\": 50 }, \"web\": { }, \"weex\": { } } CML Interface内容规范 具体可参见interface规范，.interface后缀文件用于定义多态组件的接口。 "},"framework/linter/standards/cml-interface.html":{"url":"framework/linter/standards/cml-interface.html","title":"interface 规范","keywords":"","body":"interface规范 接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）进行沟通。 类型说明 注意：建议定义类型的时候取值为 Number String Boolean Null Undefined(Void) Object Array Function Date RegExp 目前chameleon接口定义支持简单类型和复合类型。 其中简单类型包括以下类型： Number(number) String(string) Boolean(bool) Undefined(void) Null 复合类型包括以下类型： Function Object Array Date RegExp Promise 接口语法 接口的使用分两个过程： 定义一个接口。 定义实现接口的类。 接口定义 范式: interface [接口名称] { // 接口中的属性 [属性名称]: [类型], // 接口中的方法 [方法名称]([传入参数1名称]: [传入参数1类型], [传入参数2名称]: [传入参数2类型], ...): [返回类型] } 举例： // 一个名为interface1的接口 interface interface1 { // foo1: 传入分别为string和number的两个数据，返回值类型为string值 foo1(a: string, b: number): string; // foo2: 传入分别为string和Callback(上文定义)的两个数据，返回值类型为bool值 foo2(c: string, d: Callback): Boolean; } 实现接口（定义类） 范式： class [类名称] implaments [接口名称] { // 实现接口中的属性 [属性名称]: [类型] // 实现接口中的方法 [方法名称]([传入参数1名称], [传入参数2名称], ...) { return [返回值]; } } 举例： // 实现一个名称为Clazz，实现上文定义的interface1接口 class Clazz implaments interface1 { // 实现interface1定义的foo1方法，输入值和输出值要满足定义 foo1(a, b) { return 'hello ' + a + ' : ' + (b + 1); } // 实现interface1定义的foo2方法，输入值和输出值要满足定义 foo2(c, d) { return 'balabala...'; } } 复合类型的定义范式 type [类型名称] = [类型定义] 不同的复合类型，类型定义也不相同，下面会对三种复合类型做详细说明。 Function类型定义 范式: type [Function类型名称] = ([传入参数1名称]: [传入参数1类型], [传入参数2名称]: [传入参数2类型], ...) => [返回类型] 举例： // 定义一个传参分别为number,string,bool类型的三个参数，返回值为number的函数类型 type Callback = (a: number, b: string, c: bool) => number; Object类型定义 范式： type [Object类型名称] = { [属性名称1]: [类型1], [属性名称2]: [类型2] } 举例： // 定义含有a,b,c三个属性的复合类型 type Scheme = { a: string, b: bool, c: number } Array类型定义 范式： type [Array类型名称] = [ [类型1] ] 举例： // 定义名称为arrayType1的数组类型，数组元素为number类型 type arrayType1 = [ number ] 复合类型中的相互嵌套 Function、Object、Array三种复合类型可以互相嵌套： // 定义一个传参分别为number,string,bool类型的三个参数，返回值为number的函数类型 type Callback = (a: number, b: string, c: bool) => number; // 定义名称为arrayType1的数组类型，数组元素为number类型 type arrayType1 = [ number ] // 定义名称为Scheme的，含有Array类型和Function类型属性的Object类型 type Scheme = { a: arrayType1, b: Callback, } // 定义名称为Plan，含有Scheme类型和Callback的属性的Object类型 type Plan = { a: string, b: Scheme, c: Callback } // 定义名称为arrayType1类型，元素为Plan类型 type arrayType1 = [ Plan ] Promise 类型的定义 对于 async函数，由于该函数调用之后的返回值是 Promise对象，所以这样的函数的返回值要声明成 Promise; interface EntryInterface { appEntry(): Promise; appEntry2() : Promise; } 在 methods 中 class Method implements EntryInterface { async appEntry(num) { } appEntry2(){ return new Promise((resolve,reject) => { setTimeout(resolve,2000); }) } } Date 类型的定义 如果函数参数或者返回值是 Date 数据类型，那么可以按照下面的方式进行定义； interface EntryInterface { handleDate(d:Date) : Date } class Method implements EntryInterface { handleDate(d){ return new Date(); } } RegExp 类型的定义 如果函数参数或者返回值是 RegExp 数据类型，那么可以按照下面的方式进行定义； interface EntryInterface { handleDate(d:RegExp) : RegExp } class Method implements EntryInterface { handleDate(r){ return new RegExp(); } } "},"framework/linter/cml-template.html":{"url":"framework/linter/cml-template.html","title":"模板规范校验","keywords":"","body":"模板规范校验 该文档汇集模板校验支持所有检查点，附录有模板格式规范 模板语言校验 模板可以指定模板语言，指定方式为在 template 标签上指定 lang 属性， 其合法值为 \"cml\" 和 \"vue\"。 校验点: template 可以忽略 lang 属性，此时默认值为 cml template lang 属性如果指定，则必须为 \"cml\" 或者 \"vue\" 报错信息：'the tag template lang attribute: \"\" is not valid'. 模板 template 标签校验 校验点：每个模板只能\b且必须有一对 template 根标签。 报错信息：\"Each template can only have one group of template tags.\" 模板内 tags 校验 每个模板都有一个模板语言和一个平台类型，其中模板语言由 template 的 lang 属性指定，平台类型由模板文件的文件名解析出来。 对于多态组件平台类型可以直接从文件名解析出来， 比如 index.web.cml, index.weex.cml, index.wx.cml, index.alipay.cml, index.baidu.cml, 对应的平台类型分别为 web, weex, wx, alipay, baidu。 对于单文件组件，由于其模板要跨三端，故模板中只能使用 chameleon 原生支持的内建标签。 校验点： 单文件组件只能使用 chameleon 内建标签，使用非内建标签校验不通过。 chameleon 内建标签有: ['template','view','text','block','scroller','list','cell','image','switch','video','input','button','radio','checkbox', 'page', 'router-view', 'slot'] src/app/app.cml 项目启动文件中可以使用app组件，且只有store和router-config属性 多态组件可以使用 chameleon 内建标签，\b加上各平台类型所支持的原生标签，使用其他标签验证不同过。在使用平台类型支持的原生标签时，必须使用 'origin-' \b为前缀。比如: 在 wx 平台下使用 swiper 标签，那么在模板里的写法是 'origin-swiper'. 各个平台类型支持的原生标签列举如下: web 平台原生支持标签: [\"a\",\"abbr\",\"acronym\",\"address\",\"applet\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"basefont\",\"bdi\",\"bdo\",\"big\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"center\",\"cite\",\"code\",\"col\",\"colgroup\",\"command\",\"datalist\",\"dd\",\"del\",\"details\",\"dir\",\"div\",\"dfn\",\"dialog\",\"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"font\",\"footer\",\"form\",\"frame\",\"frameset\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hr\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"map\",\"mark\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"nav\",\"noframes\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"pre\",\"progress\",\"q\",\"rp\",\"rt\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"small\",\"source\",\"span\",\"strike\",\"strong\",\"style\",\"slot\",\"sub\",\"summary\",\"sup\",\"table\",\"tbody\",\"td\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"tt\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"] weex 平台原生支持标签: ['a','div','image','indicator','input','list','cell','recycle-list','loading','refresh','scroller','slider','textarea','text','richtext','video','waterfall','web'] wx 平台原生支持标签: ['template','view','block','scroll-view','swiper','movable-view','movable-area','cover-view','cover-image','icon','text','rich-text','progress','lable','input','form','checkbox','picker','picker-view','radio','switch','slider','textarea','navigator','functional-page-navigator','camera','live-player','live-pusher','map','open-data','web-view','ad','official-account','slot'] alipay 平台原生支持标签: ['view','swiper','scroll-view','cover-view','movable-view','text','icon','progress','rich-text','button','form','label','input','textarea','radio','checkbox','switch','slider','picker-view','picker','navigator','image','canvas','map','webview'] baidu 平台原生支持标签: ['view','scroll-view','swiper','movable-area','cover-view','cover-image','icon','text','rich-text','progress','animation-view','button','checkbox','form','input','label','picker','radio','slider','switch','textarea','navigator','audio','image','video','camera','ar-camera','live-player','map','canvas','open-data','web-view'] 报错信息：'tag: \"\" is either not allowed in this template or not referenced as a component' 模板指令校验 除引入的\b平台原生组件对应的标签和'origin-'为前缀的原生标签，每个模板只能够使用 template lang 指定\b\b模板语言对应的指令。Chameleon \b现只提供两种模板语言 'vue' 和 'cml'。其对应的指令列举如下: lang='cml' 支持的指令：['c-if','c-else','c-else-if','c-for','c-for-index','c-for-item','c-model','c-text','c-show','c-bind','c-catch','c-key'] lang='vue' 支持的指令：['v-if','v-else','v-else-if','v-for','v-on','v-bind','v-html','v-show','v-model','v-pre','v-once','slot-scope','is','@',':'] 校验点： 单文件模板只能使用模板语言对应的指令，使用模板语言指令之外的指令校验不通过 多态组件各平台文件中以\b 'origin-' 为前缀的平台类型原生标签上必须使平台原生指令，不能使用 \bChameleon 内置指令，使用此外其他指令校验不通过。各平台支持原生指令列举如下: web 平台支持指令: ['v-if', 'v-else', 'v-else-if', 'v-for', 'v-on', 'v-bind', 'v-html', 'v-show', 'v-model', 'v-pre', 'v-once', 'slot-scope', 'is','@',':'] weex 平台支持指令同 vue.js 框架: ['v-if','v-else','v-else-if','v-for','v-on','v-bind','v-html','v-show','v-model','v-pre','v-once','slot-scope','is','@',':'] wx 平台支持指令：['wx:if','wx:elif','wx:else','wx:for','wx:for-item','wx:for-index','wx:key','bindtap','catchtap'] \b多态组件通过 usingComponents 配置引入的\b第三方\b平台原生组件，组件对应的标签上只能够使用平台原生指令，不能使用 \bChameleon 内置指令，使用此外其他指令校验不通过。 报错信息：'directive \"\" is not allowed to be used in this template, as the template language is set to \"\"' 报错信息：'tag \"\" is prefixed with \"origin-\" directive, so it\\'s not allowed to use a chameleon built-in directive:\"\"' 报错信息：'tag \"\" is a third party impored component, so it\\'s not allowed to use a chameleon built-in directive:\"\"' 组件属性和事件名称校验 在使用组件的时，会对使用过程中属性名和绑定的事件名称进行校验。组件属性校验分为内建组件与自定义组件两部分。 校验点： 内建组件:使用的属性名和绑定事件必须在组件内有定义否则校验不通过 chameleon 内建组件有：[\"template\", \"view\", \"text\", \"block\", \"scroller\", \"list\", \"cell\", \"image\", \"switch\", \"video\", \"input\", \"textarea\", \"richtext\", \"button\", \"radio\", \"checkbox\", \"page\", \"router-view\", \"slot\", \"aside\", \"col\", \"container\", \"foot\", \"head\", \"main\", \"row\"] 报错信息：'component \"\" doesn\\'t have a defined property named \"\"' \b报错信息：'component \"\" doesn\\'t have a defined event named \"\"' 自定义组件:模板校验时和根据 usingComponents 配置解析对应组件，使用组件时属性名和事件名必须在组件内有定义否则校验不通过。 报错信息： \"The property \"propName\" is not a property of component \"compName\" which path is: path/to/component\" 报错信息： \"The event \"eventName\" is not defined in component \"compName\" which path is: path/to/component\" 内置组件嵌套规则校验 在使用 chameleon 内置组件时，内置组件之间需要遵循一定的嵌套关系。 校验点： text 组件 text 组件只能包含 text 组件作为子节点 scroller 组件 scroller 组件不能包含 textarea 或者 video 组件 list list 组件不能包含 textarea 或者 video 组件 video video 组件如果包含子组件，那么只能是 text 组件 报错信息 'tag \"\" can not have any child elements, therefor tag \"\" is not allowed as it\\'s children' 报错信息 'tag \"\" can only have \"\" as it\\'s child elements, therefor tag \"\" is not allowed as it\\'s children' 报错信息 'tag \"\" can not have \"\" as it\\'s child elements, and element in this list: \"\" is forbidden as well' 附：模板格式规范 模板书写规范 chameleon 模板书写规范尊从 HTML5 基本规范。 模板目录规范 chameleon 支持三端(三种 native 环境)，每个组件在每个环境对应有一个模板。模板命名格式 组件名称+端名称.cml 比如：c-title 组件 ├── components │ ├── c-title │ │ ├── c-title.web.cml │ │ ├── c-title.weex.cml │ │ └── c-title.wx.cml 其中： c-title.web.cml 为 web 端模板，c-title.weex.cml 为 iOS、Android 端，c-title.wx.cml 为微信小程序端。 本节模板规范就是指对这三个模板文件的编写规范。 模板语言指定 每个端的模板都可以并且必须选择两种语法规范中的一个，cml 语法规范 或者 类 vue 语法规范。指定语法规范的方式为在根节点 template 标签上给属性 lang 指定 \"cml\" 或者 \"vue\"。 列如指定模板为 cml 语法规范 注意：每个模板只能够有一个根节点并且必须为 template 标签，template 便签每个模板只能有一个。 模板标签使用规范 每个模板内可以使用的标签由三部分组成： Chameleon 的内置组件对应的标签 chamelon 支持的标签有: template、view、text、block、scroller、list、cell、image、switch、video、input、textarea、richtext、button、radio、checkbox、page、router-view、slot、aside、col、container、foot、head、main、row 多态组件中在平台文件里，\b以 'origin-' \b为\b前缀的平台原生组件对应的\b标签。 \b模板文件中通过 usingComponents 引入的组件对应的\b标签。 举例 仍以 c-title 组件为例，假设各个模板都有自定义组件配置 { \"base\": { \"usingComponents\": { \"tickets\": \"/components/ticket/index\" } } } c-title.web.cml 可以使用 chameleon 支持的 view、text、block 等基本标签，带 'origin-' \b前缀的 web 原生标签 origin-div、origin-p、origin-span 等,以及自定义组件 tickets。 c-title.weex.cml 可以使用 chameleon 支持的 view、text、block 等基本标签，weex 支持的标签，以及自定义组件 tickets。如果以 vue 作为 weex 使用的前端框架，那么 weex 支持的标签基本和 vue 框架支持的标签基本一致，其中有部分不支持的标签比如：transition 标签，具体请参见 weex 文档。 c-title.wx.cml 可以使用 chameleon 支持的 view、text、block 等基本标签，带 'origin-' 前缀的 wx 原生标签比如 origin-swiper、origin-movable-area、origin-cover-view、origin-web-view 等,以及自定义组件 tickets。 模板指令使用规范 除引用平台原生组件\b对应的标签外，每个模板必须使用模板\b语言(由 template 标签\b的 lang 属性指定) 所对应的指令集。 模板语言为 cml 时支持的指令有：c-if、c-else、c-else-if、c-for、c-for-index、c-for-item、c-model、c-text、c-show、c-bind、c-catch 模板语言为类 vue 时支持的指令有：v-if、v-else、v-else-if、v-for、v-on、v-bind、v-html、v-show、v-model、v-pre、v-once、slot-scope、is、@、: 类 vue 语法支持上述列表中的指令，其他 vue.js 的指令如 v-cloak 是不支持的。 举例 若模板语言为 \"cml\" 即 template 标签 lang 属性为 \"cml\"，native 环境为微信小程序。还是以 c-title 组件为例，那么此时对应的是 c-title.wx.cml 模板。 c-title.wx.cml: {{messageText}} 那么模板里可以使用 chameleon 支持的指令: c-if、c-else、c-else-if、c-for、c-for-index、c-for-item、c-model、c-text、c-show、c-bind、c-catch \b引用平台原生组件 Chameleon 提供两种方式引入平台原生\b\b\b组件和平台第三方原生组件： 通过给平台\b\b原生内置组件添加 'origin-' 前缀引用原生组件 通过 usingComponents 引入平台原生第三方组件 \b引用的原生组件上只能够使用平台支持的原生指令，不能使用 Chameleon 内置指令。\b改限制只限于组件本身，对其子组件没有影响。 举例 若模板语言为 \"cml\" 即 template 标签 lang 属性为 \"cml\"，native 环境为微信小程序。还是以 c-title 组件为例，那么此时对应的是 c-title.wx.cml 模板。 c-title.wx.cml: {{messageText}} 那么模板里可以使用 chameleon 支持的指令: c-if、c-else、c-else-if、c-for、c-for-index、c-for-item、c-model、c-text、c-show、c-bind、c-catch origin-picker-view 组件可以使用微信小程序原生支持的指令: wx:if、wx:elif、wx:else、wx:for、wx:for-item、wx:for-index、wx:key、bindtap、catchtap "},"framework/linter/cml-script.html":{"url":"framework/linter/cml-script.html","title":"脚本规范校验","keywords":"","body":"脚本规范校验 组件逻辑层响应页面操作的代码，需要导出以下规范的对象。 { // 数据 data: { dataKey1: dataValue1, dataKey2: dataValue2 }, // 属性 props: { propKey1: propValue1, propKey2: propValue2 }, // 计算属性 computed: { computedKey1: () => { }, computedKey2: () => { } }, // 监听属性 watch: { watchKey1: () => { }, watchKey2: () => { } }, // 实例初始化之后，数据和方法挂在到实例之前 beforeCreate: () => { }, // 数据及方法挂载完成 created: () => { }, // 开始挂载已经编译完成的html,到对应的dom节点时 beforeMount: () => { }, // 模板或者html编译完成,且渲染到dom中完成 mounted: () => { }, // 实例销毁之前 beforeDestroy: () => { }, // 实例销毁后 destroyed: () => { } } 生命周期 钩子 执行时机 详细 beforeCreate 实例初始化之后，数据和方法挂在到实例之前 在该钩子函数中会传入当前页面query参数 created 数据及方法挂载完成 beforeMount 开始挂载已经编译完成的html,到对应的dom节点时 mounted 模板或者html编译完成,且渲染到dom中完成 beforeDestroy 实例销毁之前 destroyed 实例销毁后 全局变量校验 编写一端代码逻辑时，如果使用其他端的全局变量，会校验失败。 按照端类型区分可用的全局变量： WEEX weex, global WX wx, global alipay my, global baidu swan, global WEB postMessage, blur, focus, close, frames, self, window, parent, opener, top, length, closed, location, document, origin, name, history, locationbar, menubar, personalbar, scrollbars, statusbar, toolbar, status, frameElement, navigator, customElements, external, screen, innerWidth, innerHeight, scrollX, pageXOffset, scrollY, pageYOffset, screenX, screenY, outerWidth, outerHeight, devicePixelRatio, clientInformation, screenLeft, screenTop, defaultStatus, defaultstatus, styleMedia, onanimationend, onanimationiteration, onanimationstart, onsearch, ontransitionend, onwebkitanimationend, onwebkitanimationiteration, onwebkitanimationstart, onwebkittransitionend, isSecureContext, onabort, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting, onwheel, onauxclick, ongotpointercapture, onlostpointercapture, onpointerdown, onpointermove, onpointerup, onpointercancel, onpointerover, onpointerout, onpointerenter, onpointerleave, onafterprint, onbeforeprint, onbeforeunload, onhashchange, onlanguagechange, onmessage, onmessageerror, onoffline, ononline, onpagehide, onpageshow, onpopstate, onrejectionhandled, onstorage, onunhandledrejection, onunload, performance, stop, open, alert, confirm, prompt, print, requestAnimationFrame, cancelAnimationFrame, requestIdleCallback, cancelIdleCallback, captureEvents, releaseEvents, getComputedStyle, matchMedia, moveTo, moveBy, resizeTo, resizeBy, getSelection, find, webkitRequestAnimationFrame, webkitCancelAnimationFrame, fetch, btoa, atob, createImageBitmap, scroll, scrollTo, scrollBy, onappinstalled, onbeforeinstallprompt, crypto, ondevicemotion, ondeviceorientation, ondeviceorientationabsolute, indexedDB, webkitStorageInfo, sessionStorage, localStorage, chrome, visualViewport, speechSynthesis, webkitRequestFileSystem, webkitResolveLocalFileSystemURL, openDatabase, applicationCache, caches, whichAnimationEvent, animationendEvent, infinity, SETTING, AppView, ExtensionOptions, ExtensionView, WebView, iconPath, _app, _ZOOM_, Feed, md5, $, jQuery, Search, windmill, Lethargy, alertTimeOut, supportApps, lethargyX, lethargyY, iView, onModuleResLoaded, iEditDelete, infinityDrag, i, array, TEMPORARY, PERSISTENT, addEventListener, removeEventListener, dispatchEvent "},"framework/linter/cml-cmss.html":{"url":"framework/linter/cml-cmss.html","title":"样式规范校验","keywords":"","body":"样式规范校验 CMSS 规则 CMSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 selector { declaration1; declaration2; ... declarationN } 每条声明由一个属性和一个值组成。 声明 属性（property）是你希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开，一条声明以分号结尾。 selector { property1: value1; property2: value2; } selector应为一条独立的id名称或者class名称，不支持级联 // 正确 .selector { property1: value1; property2: value2; } #selector { property1: value1; property2: value2; } // 错误 #selector1 .selector { property1: value1; property2: value2; } 多端之间的差异对比 CSS属性 H5 小程序 weex 布局 all all flexbox 盒模型 all all 只支持display:border-box float浮动 ✅ ✅ ❌ display:inline-block|none ✅ ✅ ❌ ID选择器 ✅ ✅ ❌ 类选择器 ✅ ✅ ✅ 属性选择器 ✅ ✅ ❌ 级联选择器、派生选择器(后代、子元素、相邻兄弟) ✅ ✅ ❌ 选择器分组 ✅ ✅ ✅ 伪类(:active|:focus) ✅ ✅ ✅ 伪类(:hover|:link|:visited|:first-child|:lang) ✅ ✅ ❌ 伪元素(:first-letter|:first-line|:before|:after) ✅ ✅ ❌ 百分比定值 ✅ ✅ ❌ line-height:1 ✅ ✅ ❌ 尺寸 px|rem|em|vw|vh px|rpx px !important ✅ ✅ ❌ 注意:框架会根据上表所述的多端之间的差异做校验。 "},"framework/linter/cml-json.html":{"url":"framework/linter/cml-json.html","title":"配置规范校验","keywords":"","body":"配置规范校验 CML文件配置规范的校验，包括语法格式，组件的引用等。 说明 wx、alipay、baidu、web、weex分别对应各端构建时所应用的配置信息，base的配置会应用到每一端的配置，内部做的result = merge(base,target)。 wx字段配置的内容最终会生成到微信小程序所需要的json文件。 wx.component字段,如果在微信中该cml文件是组件必须声明该字段。 usingComponents字段是目前最重要的配置，三端都会使用，微信小程序规定页面的json文件中配置使用到的组件。web和weex端的构建时也是根据该字段去找到相应的组件进行自动化的注册。所以用到组件必须进行配置 usingComponents中组件的引用地址支持引用src和node_modules下的组件，src下的，可以写相对路径，也可以写相对于src的绝对路径，例如/components/**, node_modules下的组件，不需要写node_modules，直接从npm的包名称开始写例如cml-test-ui/navi/navi。 路径写到.cml文件所在层级，不写后缀。 例子： { \"base\": { \"usingComponents\": { \"c-scroller\": \"chameleon-ui-builtin/components/scroller/scroller\", \"c-checkbox\": \"/components/c-checkbox/c-checkbox\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" }, \"alipay\": { \"defaultTitle\": \"index\", \"pullRefresh\": false, \"allowsBounceVertical\": \"YES\", \"titleBarColor\": \"#ffffff\" }, \"baidu\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"index\", \"backgroundColor\": \"#ffffff\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": false, \"onReachBottomDistance\": 50 }, } ## chameleonjson规范 包括以下三条： 1. 满足标准的json格式规范，满足JSON.parse的解析 - 数据在名称/值对中 - 数据由逗号分隔 - 花括号保存对象 - 方括号保存数组 2. chameleon json为对象，必须包括base字段，根据适配的平台可配置wx|alipay|baidu|web|weex字段，作为单一端上的特殊配置 ```javascript // 适配微信小程序和weex { \"base\": { }, \"wx\": { }, \"alipay\": { }, \"baidu\": { }, \"weex\": { } } usingComponents使用规范: 多端实现完全一致组件: usingComponents字段必须放置在base下，不应出现wx|alipay|baidu|web|weex字段中 多端实现不一致组件: usingComponents字段可以放置在base下，也可以在出现当前端对应的wx|alipay|baidu|web|weex字段中 注：多端实现完全一致组件 和 多端实现不一致组件 的说明可参见这 "},"terminal/io.html":{"url":"terminal/io.html","title":"导入与导出","keywords":"","body":"导出(Export) 即 将Chameleon可重用组件导出给普通项目使用，或者说 某端普通项目里面使用Chameleon可重用组件。 导入(Import) 即 在Chameleon可重用项目中导入普通项目产出的组件，或者说 可重用代码Chameleon项目使用某端普通组件。 使用方式 终端 项目框架 导入 导出 说明 微信 原始项目 已支持 微信 MPX 待支持 Web Vue 已支持 Web React 待支持 Web 其他 支持导入，不支持导出 Native Vue 已支持 Native React 待支持 Native Flutter 待支持 Native Objective-C MVVM框架 待支持 Native Android Java MVVM框架 待支持 相关链接 渐进式接入 Web 框架 Weex 框架 微信小程序框架 支付宝小程序框架 百度小程序框架 "},"framework/progressive.html":{"url":"framework/progressive.html","title":"渐进式接入","keywords":"","body":"渐进式接入(Progressive) 跨端有2种需求。 整个项目一套代码实现：第一种业务层需求在各端环境高度类似，原本需要针对不同端重复开发、重复测试，那么使用Chameleon将整个项目”从上至下“都用一套代码运行，针对各端底层极个别差异化实现（使用多态协议）。 场景举例：首页官网、列表详情页等 仅组件一套代码运行：第二种是各端页面需求不一致，却有共同的组件需要重复开发、重复测试，各个端用各自原本框架开发（或者使用Chameleon方案)，使用一套代码开发公用组件，然后各个端可以使用公用组件实现业务 场景举例：分享组件、支付组件、地图组件 整个项目一套代码实现 仅组件一套代码运行 相关链接 webpack集成 组件导出应用 "},"framework/webpack_plugin.html":{"url":"framework/webpack_plugin.html","title":"webpack 集成","keywords":"","body":"webpack集成 注：内部webpack插件版本基于webpack@3.12.0开发选择，暂不兼容webpack4。 通过以下步骤，可以让webpack项目中使用chameleon的任意组件。 1 安装npm包 npm i easy-chameleon chameleon-ui-builtin 2 执行脚本 node node_modules/\\easy-chameleon/bin/index.js，该脚本会执行检测，安装未安装的第三方npm包 3 .babelrc 的preset 添加flow, chameleon中用了flow语法，如果需要用到chameleon-api，建议配置babel-plugin-chameleon-import插件实现按需加载。例如： { \"presets\": [ \"flow\", [\"env\", { \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 4 入口代码中，引入代码 import 'easy-chameleon/entry/web_global.js'; 5 修改webpack配置文件,easy-chameleon提供了getConfig\b方法获取webpack配置\b，利用webpack-merge将项目原有webpack配置与getConfig方法获取的配置进行合并，例如： const merge = require('webpack-merge') const {getConfig} = require('easy-chameleon'); devWebpackConfig = merge(devWebpackConfig, getConfig({ cmlType: 'web', media: 'dev', hot: true, disableExtract: false, context: path.join(__dirname,'../'), cmss: { rem: false, scale: 0.5 } })) getConfig方法参数 getConfig(Object object) 参数类型默认值必填说明 cmlTypeString\b是端类型，可选值为web|wx|weex mediaString\b是构建模式，可选值为dev|build hotBooleanfalse\b否\b是否开启热更新，只在web端生效 disableExtractBooleanfalse\b否\b不提取css文件 cmssObject\b否\bcmss处理的配置\b，参见下方cmss对象属性列表 wxConfigObject\b否微信端构建配置，参见下方wxConfig对象属性列表 cmss 对象属性列表 参数类型默认值必填说明 remBooleantrue\b否将cpx以75cpx=1rem为标准转换成rem scaleNumber0.5\b否当rem为false时，scale将生效，将cpx乘以scale为px wxConfig 对象属性列表 参数类型默认值必填说明 entryArray[String]\b是指定输出的组件入口，以项目根目录下的相对路径,会寻找指定路径下的cml文件进行编译 outputPathString\b否输出路径 示例 详细示例戳这里webpack集成chameleon "},"framework/compont_export.html":{"url":"framework/compont_export.html","title":"组件导出应用","keywords":"","body":"组件导出 这里介绍的是第二种场景，将 CML 组件导出到某个端使用。 介绍 为了让开发者更自由地使用Chameleon，我们提供组件导出的形式，让开发者可以在任意端原有项目中使用通过Chameleon开发的组件。我们用web端和小程序端举例，按正常开发模式我们需要分别维护着4套代码（web、wx、alipay、baidu），在某一个业务场景下需要开发一个时间选择器的组件，原有模式下我们需要每个端独自开发，而对于这种公共的组件，就可以选择使用Chameleon去维护，通过Chameleon开发，只需要维护一套组件代码，最后通过组件导出就可以在各个端进行使用了。这样的模式完全利用了Chameleon的跨端优势，大大降低了代码开发维护成本。 组件导出开发模式： 命令行 cml web export 执行web端组件导出 cml weex export 执行weex端组件导出 cml wx export 执行wx端组件导出 cml alipay export 执行alipay端组件导出 cml baidu export 执行baidu端组件导出 配置 在chameleon.config.js中增加export配置，即可自定义组件导出配置,可配置项参考下表： 配置项 类型 说明 entry Array 组件导出的入口目录，项目根目录的相对路径 outputPath String 组件导出目录，绝对路径 publicPath String 公共资源地址 hash Boolean 导出文件名是否带hash，默认true minimize Boolean 导出文件名是否压缩，默认true disableExtract Boolean 不拆分css，默认false 导出组件 chameleon组件导出目录结构如下： ├── dist | ├── export │ │ ├── platform (web、weex、wx、alipay、baidu ...) │ │ │ ├── common | │ │ │ ├── web_global.js [仅导出web端组件时存在，需要在入口文件中引用] | │ │ │ ├── web_global.css [会在web_global.js中引用] │ │ │ ├── 组件目录 │ │ │ └── 资源目录 下面是在webpack+vue环境下引用chameleon导出组件的示例： 假设目前已经通过chameleon项目导出了c-header组件，将组件移动到webpack+vue的环境后，需要进行一下几步操作： 假设是web端组件，则首先需要在入口文件中引用web_global.js 在需要使用组件的地方引用组件即可 Bug&Tips .babelrc配置中去掉module: false 由于生产模式组件为编译后的模块，所以尽量使用线上资源 示例 详细示例戳这里普通项目使用跨端组件 "},"terminal/web/framework.html":{"url":"terminal/web/framework.html","title":"Web 框架","keywords":"","body":"web 框架 组件开发模式 具体如何引入请移步web组件接入 "},"terminal/web/component.html":{"url":"terminal/web/component.html","title":"Web 组件接入","keywords":"","body":"web端组件接入 chameleon允许在web端多态组件中直接引入原生vue组件，一方面是为了增加代码重用度，另一方面则是方便渐进式地迁移使用chameleon。 为什么要接入web端组件 chameleon作为跨端框架，将各端相同性及差异性进行统一封装形成chameleon的规范，但即使是这样，我们也没有办法百分百地避免差异，这样的差异可能来自产品的要求、技术的实现等等，由此chameleon提出了组件多态协议，在多态组件实现中，直接引用原生组件，降低开发成本。 怎么引入web端组件 在chameleon中使用组件只需要在组件配置中写入依赖的子组件，下面是web端组件引用vue单文件组件的示例： ... { \"base\": { \"usingComponents\": { \"v-list\": \"/components/vue-components/v-list\" } } } {{l}} export default { props: { list: { type: Array, default: function() { return [1, 2, 3, 4] } } } } 需要注意的是组件路径需要写到.vue层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"terminal/weex/framework.html":{"url":"terminal/weex/framework.html","title":"Weex 框架","keywords":"","body":"weex 框架 组件开发模式 具体如何引入请移步weex组件接入 "},"terminal/weex/component.html":{"url":"terminal/weex/component.html","title":"Weex 组件接入","keywords":"","body":"weex端组件接入 chameleon允许在weex端多态组件中直接引入原生vue组件，一方面是为了增加代码重用度，另一方面则是方便渐进式地迁移使用chameleon。 为什么要接入weex端组件 chameleon作为跨端框架，将各端相同性及差异性进行统一封装形成chameleon的规范，但即使是这样，我们也没有办法百分百地避免差异，这样的差异可能来自产品的要求、技术的实现等等，由此chameleon提出了组件多态协议，在多态组件实现中，直接引用原生组件，降低开发成本。 怎么引入weex端组件 第一类是weex支持的原生组件，比如div text等，详细请查看weex原生组件列表，如果这样的组件已经满足开发需求，那么就可以直接使用了： {{l}} 第二类是原先封装好的组件，首先你需要将组件复制到chameleon项目中，然后只需要在chameleon组件中声明式引入该组件即可使用。 还是以list组件为例，假设原有封装好的组件custom-list，目录结构如下： ... { \"base\": { \"usingComponents\": { \"v-list\": \"/components/vue-components/v-list\" } } } {{l}} export default { props: { list: { type: Array, default: function() { return [1, 2, 3, 4] } } } } 需要注意的是组件路径需要写到.vue层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"terminal/wx/framework.html":{"url":"terminal/wx/framework.html","title":"微信小程序框架","keywords":"","body":"微信小程序框架 组件开发模式 具体如何引入请移步小程序组件接入 "},"terminal/wx/component.html":{"url":"terminal/wx/component.html","title":"小程序组件接入","keywords":"","body":"小程序组件接入 chameleon允许在多态组件中引入原生微信小程序组件，对于已经熟悉小程序组件开发的朋友将非常easy，之前封装的微信小程序组件可以直接使用，微信小程序相关的ui库可以直接使用，微信小程序自带的组件也可以直接使用。 为什么要接入微信小程序组件 多态组件存在的差异不过来自于各端需求不同，又或是各端实现方式的不同。微信小程序组件的接入跟第二个问题完美契合，在原有的小程序开发过程中或许已经产出了常用组件，又或是使用着某个微信小程序的组件库，当使用chameleon进行开发时，避免了二次开发原有组件的成本。 怎么引入微信小程序组件 第一类是微信小程序支持的组件，比如view text等，详细请查看微信小程序组件列表，如果这样的组件已经满足开发需求，那么就可以直接使用了： {{l}} 第二类是原有的组件，首先你需要将组件复制到chameleon项目中，然后只需要在chameleon组件中声明式引入该组件即可使用。 还是以list组件为例，假设原有封装好的微信小程序的组件custom-list，目录结构如下： ├── components // 组件文件夹 | ├── custom-list | | ├── custom-list.wxml | | ├── custom-list.wxss | | ├── custom-list.js | | └── custom-list.json 那么，在list.wx.cml中可以直接引用： ... { \"base\": { \"usingComponents\": { \"custom-list\": \"/components/custom-list/custom-list\" } } } 需要注意的是组件路径需要写到.wxml层级，但是不带后缀。 第三类是微信小程序的组件库，这里以iVew Webapp为例，首先需要将其代码下载下来放到chameleon项目中，假设目录结构如下： ├── components // 组件文件夹 | ├── iview | | ├── action-sheet | | | ├── index.js | | | ├── index.json | | | ├── index.wxml | | | └── index.wxss | | ├── alert | | ├── avatar | | └── ... 这里我们需要使用action-sheet组件只需要如下即可： ... { \"base\": { \"usingComponents\": { \"action-sheet\": \"/components/iview/action-sheet/index\" } } } 需要注意的是组件路径需要写到.wxml层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"terminal/alipay/framework.html":{"url":"terminal/alipay/framework.html","title":"支付宝小程序框架","keywords":"","body":"支付宝小程序框架 组件开发模式 具体如何引入请移步alipay组件接入 "},"terminal/alipay/component.html":{"url":"terminal/alipay/component.html","title":"小程序组件接入","keywords":"","body":"小程序组件接入 chameleon允许在多态组件中直接引入支付宝小程序组件，如果你已经封装了支付宝小程序的组件，如果你已经在用支付宝小程序的组件库，不用担心，在chameleon项目中你仍然可以使用。 为什么要接入支付宝小程序组件 多态组件存在的差异不过来自于各端需求不同，又或是各端实现方式的不同。支付宝小程序组件的接入跟第二个问题完美契合，在原有的小程序开发过程中或许已经产出了常用组件，又或是使用着某个支付宝小程序的组件库，当使用chameleon进行开发时，避免了二次开发原有组件的成本。 怎么引入支付宝小程序组件 第一类是支付宝小程序支持的组件，比如view text等，详细请查看支付宝小程序组件列表，如果这样的组件已经满足开发需求，那么就可以直接使用了： {{l}} 第二类是原有的组件，首先你需要将组件复制到chameleon项目中，然后只需要在chameleon组件中声明式引入该组件即可使用。 还是以list组件为例，假设原有封装好的支付宝小程序的组件custom-list，目录结构如下： ├── components // 组件文件夹 | ├── custom-list | | ├── custom-list.axml | | ├── custom-list.acss | | ├── custom-list.js | | └── custom-list.json 那么，在list.alipay.cml中可以直接引用： ... { \"base\": { \"usingComponents\": { \"custom-list\": \"/components/custom-list/custom-list\" } } } 需要注意的是组件路径需要写到.axml层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"terminal/baidu/framework.html":{"url":"terminal/baidu/framework.html","title":"百度小程序框架","keywords":"","body":"百度小程序框架 组件开发模式 具体如何引入请移步baidu组件接入 "},"terminal/baidu/component.html":{"url":"terminal/baidu/component.html","title":"小程序组件接入","keywords":"","body":"小程序组件接入 chameleon允许在多态组件中直接引入百度小程序组件，如果你已经封装了百度小程序的组件，如果你已经在用百度小程序的组件库，不用担心，在chameleon项目中你仍然可以使用。 为什么要接入百度小程序组件 多态组件存在的差异不过来自于各端需求不同，又或是各端实现方式的不同。百度小程序组件的接入跟第二个问题完美契合，在原有的小程序开发过程中或许已经产出了常用组件，又或是使用着某个百度小程序的组件库，当使用chameleon进行开发时，避免了二次开发原有组件的成本。 怎么引入百度小程序组件 第一类是百度小程序支持的组件，比如view text等，详细请查看百度小程序组件列表，如果这样的组件已经满足开发需求，那么就可以直接使用了： {{l}} 第二类是原有的组件，首先你需要将组件复制到chameleon项目中，然后只需要在chameleon组件中声明式引入该组件即可使用。 还是以list组件为例，假设原有封装好的百度小程序的组件custom-list，目录结构如下： ├── components // 组件文件夹 | ├── custom-list | | ├── custom-list.swan | | ├── custom-list.css | | ├── custom-list.js | | └── custom-list.json 那么，在list.baidu.cml中可以直接引用： ... { \"base\": { \"usingComponents\": { \"custom-list\": \"/components/custom-list/custom-list\" } } } 需要注意的是组件路径需要写到.swan层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"chameleon_client/introduction.html":{"url":"chameleon_client/introduction.html","title":"Native 渲染能力接入","keywords":"","body":"Chameleon SDK 端渲染器支持React-Native模式和Weex模式，功能主要包含： Chameleon SDK接入 端JS包资源缓存、更新和预加载 "},"chameleon_client/integration.html":{"url":"chameleon_client/integration.html","title":"Chameleon SDK 接入","keywords":"","body":"Chameleon SDK接入 使用Chameleon的渲染能力，需要集成对应平台的SDK。请在左侧目录中根据你需要接入的平台来查看文档。 iOS接入 Android接入 SDK独有方法 "},"chameleon_client/ios/introduction.html":{"url":"chameleon_client/ios/introduction.html","title":"iOS","keywords":"","body":"功能介绍 Chameleon iOS SDK使用Weex、ReactNative与WebView作为基础渲染引擎，提供了基础的组件功能之外，还支持用户扩展自己的功能组件。 集成 环境要求 Chameleon最低支持的iOS deployment target为：iOS 9.0 Chameleon使用Cocoapods进行管理，使用npm管理react_native。 组件名 依赖版本 备注 Cocoapods 1.3.1 - npm 最新版本即可 - WeexSDK 0.19.0.2 - react_native 0.57.6 - react 16.6.1 - 详细集成 当sdk下载下来后，首先进入/chameleon-sdk-iOS/Chamleon/react_native,并运行npm install进行更新。（这也是react_native的更新办法。） 接下来我们以demo工程为例（要注意工程路径位置,在工程实际配置中需要注意 :path 的内容）。 在Podfile中，写入： platform :ios, '9.0' target 'Chameleon_Example' do #Chameleon pod 'Chameleon', :path => '../Chamleon/' #如果需要Weex，则写入weex依赖。 pod 'WeexSDK', '~> 0.19.0.2' #如果需要react_native，则写入react_native依赖。 pod 'React', :path => '../Chamleon/react_native/node_modules/react-native', :subspecs => [ 'Core', 'CxxBridge', # 如果RN版本 >= 0.45则加入此行 'DevSupport', # 如果RN版本 >= 0.43，则需要加入此行才能开启开发者菜单 'RCTText', 'RCTNetwork', 'RCTWebSocket', # 这个模块是用于调试功能的 ] pod 'yoga', :path => '../Chamleon/react_native/node_modules/react-native/ReactCommon/yoga' pod 'DoubleConversion', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/DoubleConversion.podspec' pod 'glog', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/GLog.podspec' pod 'Folly', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/Folly.podspec' end 将podfile保存，并运行pod install。 常见问题 Multiple commands produce Showing All Messages :-1: Multiple commands produce 'XXXXX': 1) Target 'Chameleon_Example' has create directory command with output 'XXXXp' 2) That command depends on command in Target 'Chameleon_Example': script phase “[CP] Copy Pods Resources” 解决办法：删除 工程->Build Phrases->[CP] Copy Pods Resources->Output files下的copy路径。 功能概览 项目目录 描述 作用 Chamleon SDK源码与依赖文件夹 Example react_native依赖 Chamleon/sdk_src 目录 功能描述 CMLSDKEngine类 初始化SDK、注册自定义的module 等功能 CMLCommon Chameleon抽象层。抽象了基础的渲染页面、缓存、配置、预加载等功能。 CMLReactNative 针对ReactNative额外配置的部分 CMLWeex 针对Weex额外配置的部分 CMLWeb 针对WebView额外配置的部分 提供功能 Bundle预加载 先设置预加载地址 [CMLEnvironmentManage chameleon].weexService.config.prefetchContents = @[@\"http%3A%2F%2F172.22.139.32%3A8000%2Fweex%2Fchameleon-bridge.js%3Ft%3D1546502643623\"]; 开始预加载 [[CMLEnvironmentManage chameleon].weexService setupPrefetch]; 自动降级 当Bundle下载失败、渲染出现严重错误时，会自动降级至H5。 降级设计图 本地bundle降级 当H5渲染失败时，倘若设置了默认的本地bundle，会使用本地bundle进行降级。 主动降级 当渲染出现错误时，FE可以通过JSBridge通知客户端触发降级。 功能扩展 使用+ (void)registerModule:(NSString *)moduleName className:(NSString *)className;注册自己的扩展。 使用说明 初始化SDK [CMLSDKEngine initSDKEnvironment]; 设置渲染引擎类型 [CMLEnvironmentManage chameleon].serviceType = CMLServiceTypeWeex; 设置预加载环境 [CMLEnvironmentManage chameleon].weexService.config.prefetchContents = @[@\"http%3A%2F%2F172.22.139.32%3A8000%2Fweex%2Fchameleon-bridge.js%3Ft%3D1546502643623\"]; 设置预加载 [[CMLEnvironmentManage chameleon].weexService setupPrefetch]; 相关链接 Module的使用 预加载和缓存 "},"chameleon_client/ios/module.html":{"url":"chameleon_client/ios/module.html","title":"Module 的使用","keywords":"","body":"Module 的使用 1. 什么是 module module 是 Native 提供给前端页面调用的，完成一组操作的方法集合，用于扩展 Native 的能力。在 Chameleon 页面中，开发者引入相关js库后即可调用 module 中的方法。 import bridge from 'chameleon-bridge'; // 主动调用客户端方法 export function sayHello() { bridge.callNative( 'moduleDemo', // 模块名 'sayHello', // 方法名 {}, // 参数 res => {} // 回调方法 ); } 2. Module 的使用 Module 的使用分两种情况，一种是使用 Chameleon SDK 内置的Module，一种是用户自定义实现自己的 Module。 2.1 使用内置的 Module 内置的 Module 在js 前端代码里直接使用即可，目前内置的 Module 有： clipboard cml modal storage stream webSocket Chameleon DOC 《API一章》 里描述的能力，部分实现就是由上述 module 支撑的。 2.2 自定义实现自己的 Module 示例可参看《手把手叫你系列 CMLStorageModule示例》 注册自己的module关联文件: CMLSDKEngine CMLConstants CMLUtility CMLModuleProtocol 非必须（该协议可获取CMLInstance） 详细说明 功能：通过注册module提供原生能力的扩展 原理：依赖bridge进行协议通信，根据不同module进行协议处理分发 module，扩展原生能力 module注册 [CMLSDKEngine registerModule:@\"module名\" className:@\"类名\"]; module名:两端及前端同学定义的一个名字 module方法实现 #import \"CMLConstants.h\" #import \"CMLUtility.h\" CML_EXPORT_METHOD(@selector(xxx:callBack:)) - (void)xxx:(NSDictionary *)param callBack:(CMLMoudleCallBack)callback { } xxx:方法名，协商定义，需要跟前端一致 param：所带参数，字典类型 callback：回调block (非必须) 遵循CMLModuleProtocol的作用 CMLModuleProtocol协议可获取到CMLInstance 通过CMLInstance可获取当前运行环境、viewController "},"chameleon_client/ios/cache.html":{"url":"chameleon_client/ios/cache.html","title":"预加载和缓存","keywords":"","body":"预加载和缓存 1. 预加载和缓存概念 预加载和缓存都是为了节省 JSBundle 下载的时间，加快 UI 的渲染。 1.1 预加载 预加载是将下载 JSBundle 的动作提前完成，在需要用到的时候直接从本地读取并渲染。实际项目使用中，可以将需要预加载的 url 配置到预加载地址列表里，在app启动时提前从服务端获取，通过 Chameleon SDK 提供的预加载能力提前下载下来。 1.2 缓存 对于没有预加载的 JSBundle 在渲染前需要先下载，下载完成后 Chameleon SDK 会缓存此 JSBundle，下次渲染同一个 JSBundle时，如果此 JSBundle 没有更新则不会下载新的，达到节省时间和流量提升渲染速度的目的。 2. CMLCache CMLCache是一个对js进行下载、缓存的一个模块，根据协议来实现js增量更新功能。主要有以下内容 | |——CMLWeexCache 缓存模块接口类 |——CMLCacheInfo JsBundle文件缓存实现逻辑 |——CMLCacheItem jsBundle文件内存对象，描述每一个jsBundle文件的缓存状态 |——CMLConfig 配置类，业务方可通过这个类设置是否开启缓存功能、预加载js路径、缓存大小限制、默认兜底页链接等 2.1 CMLCache 对jsBundle进行预加载、获取、缓存的处理对外接口。 在该文件里，我们将拿到的URL解析出此页面需要加载的jsbundle标识，然后根据jsBundle标识来检测是否在本地已预加载，如果此jsBundle已预加载成功，则直接读本地缓存渲染；否则先从网络下载jsBundle，然后渲染并缓存本地。 后续我们将支持在一个URL中下发多段jsbundle标识，每段jsbundle标识代表这个页面的一部分，然后在根据每段jsbundle标识，分别从本地缓存里获取去寻找对应的js代码，如果不存在则从网络去下载这一段jsBundle并保存在本地，然后SDK中会将最终得到的多段jsBundle，组合成一个完整页面的jsBundle加载出来。 2.2 CMLCacheInfo jsBundle的内存管理器，是加载、获取、缓存等处理的实际操作者。 对本地缓存jsBundle的maxSize加以限制，如果超过maxSize，则优先清除老的jsBundle缓存 2.3 CMLCacheItem 对jsBundle的封装，包括jsBundle文件在本地存储的路径、内存索引；CMLCacheInfo就是通过CMLCacheItem来对jsBundle进行操作。 2.4 使用（以weex为例） 缓存相关配置 缓存相关配置定义位于CMLWeexConfig （CMLConfig） //设置服务类型为weex [CMLEnvironmentManage chameleon].serviceType = CMLServiceTypeWeex; //设置默认错误web链接 [CMLEnvironmentManage chameleon].weexService.config.defaultErrUrl = @“defaultErrUrl” Chameleon功能和缓存功能都是默认开启的，如果有特殊需要，可以手动关闭；另外在这里还有缓存限制maxSize、缓存目录等配置 [CMLEnvironmentManage chameleon].weexService.config.isFeatureAvailable = NO； [CMLEnvironmentManage chameleon].weexService.config.isEnableCacheFeature = NO; 预加载 //设置预加载URL列表 [CMLEnvironmentManage chameleon].weexService.config.prefetchContents = @[@\"http%3A%2F%2F172.22.139.32%3A8000%2Fweex%2Fchameleon-bridge.js%3Ft%3D1546502643623\"]; //开启预加载 [[CMLEnvironmentManage chameleon].weexService setupPrefetch]; 获取加载jsBundle的URL CMLWeexCache *cache = (CMLWeexCache *)[CMLEnvironmentManage chameleon].weexService.cache; //在缓存中获取JSBundle的URL（本地有缓存则获取到本地缓存的URL，本地无缓存则获取到远端的URL） [cache getBundleCacheOfJSBundleUrl:self.bundleUrl completion:^(NSString *url, NSDictionary *parameter) { //加载jsBundle [self.render renderWithURL:[NSURL URLWithString:url] options:@{@\"query\" : [param copy]} data:nil]; } "},"chameleon_client/android/introduction.html":{"url":"chameleon_client/android/introduction.html","title":"Android","keywords":"","body":"Android SDK 简介 　　github地址点这里 　　Chameleon android SDK 是 Chameleon 整体框架的一部分，主要任务是完成 Chameleon JsBundle 在 android 端的本地渲染。SDK 底层采用 weex 作为渲染引擎，同时扩展一些一般工程通用的基础能力，如缓存能力、降级能力等。 1. 项目结构 项目一级目录结构如下： |+ app SDK使用示例 |+ cmlsdk SDK接入层，抽象 Chameleon 引擎能力、实现通用扩展能力 |+ cmlweex 包装 weex 渲染引擎 |+ cmlweb 包装 web 渲染引擎 |+ js-bundle-mgr 实现 js bundle 预加载、缓存 |+ rich-text-component 富文本组件 |+ sdk-image 图片选择、图片拍摄组件 |+ sdk-location 位置组件 cmlsdk 模块单独拿出来看下目录结构： |- cmlsdk |+ adapter 定义了扩展能力的接口以及默认实现，无默认实现的能力需要第三方项目根据自己的实际业务需求去实现 |+ bridge 定义了 js 和 native 通信的接口，实现协议相关的处理能力，以及实现了协议层使用入口 |+ bundle js bundle 相关定义，目前只有一个类用来描述 js bundle 相关信息 |+ common 通用能力的基础封装类 |+ container 渲染容器的抽象能力定义 |+ extend Chameleon 提供的一些能力 |+ module 扩展能力管理，收集 sdk 默认提供的以及第三方用户自己实现的 module，根据 bridge 层指令执行具体某个 module 的某个 method |+ utils 工具类集合 |+ widget 自定义的widget，目前只有一个 title bar，用做 webview 渲染容器的action bar |- CmlBaseLifecycle 生命周期的接口定义 |- CmlConstant 常量定义 |- CmlEngine Chameleon SDK 使用入口 |- CmlEnvironment 运行环境和运行参数配置入口、扩展能力设置入口 |- CmlInstanceManage 页面运行实例的管理类，每一个容器实例运行时，其对应的Instance会注册到这里 |- ICmlEngine 引擎的抽象接口 |- ICmlInstance 容器实例抽象接口 |- ICmlActivityInstance 全屏容器实例抽象接口 |- ICmlViewInstance 视图容器实例抽象接口 项目整体架构如下图所示： 2. Chameleon 使用 Chameleon android SDK 的使用步骤如下: 引用 Chameleon 及工程需要的相关类库 在项目中初始化 Chameleon SDK 加载 JS Bundle 详细的使用方式可以参看手把手系列之《变色龙SDK使用范例》，建议先看使用范例再阅读其他章节。 如果需要自定义自己的 adapter，参看《Adapter的使用》一节。如果需要扩展module，参看《Module的使用》一节。 3. 基础类说明 3.1 CmlEngine 此类是 Chameleon/kəˈmiːlɪən/ SDK 的入口类，提供基本的初始化入口和 Chameleon容器的调起能力。具体包含以下能力 SDK 初始化入口 调起渲染容器 初始化预加载列表 注册扩展module 3.2 CmlEnvironment CmlEnvironment 主要提供了开发期间需要的一些能力，如 调试开关 降级开关 缓存开关 以及一些常量的定义，如 预加载的最大缓存 运行时的最大缓存 adapter 设置和获取，详情参看《Adapter的使用》一节 各种能力的自定义实现配置入口 4. 富文本组件 富文本是Chameleon里唯一一个默认注册的组件，主要有以下内容 | |-richinfo 主要是富文本需要定义的协议、点击事件的回调等 |-utils 工具类，主要是加载assets下默认的字体 |-CmlRichTextComponent 继承与与CmlComponent的富文本组件 |-CmlRichTextEngine 富文本入口类， richinfo CmlClickSpanListener：富文本点击事件回调 CmlCustomTypefaceSpan：加载自定义字体 CmlRichInfo：富文本协议及实现 CmlRichInfoSpan：配合CmlRichInfo显示富文本文字，可直接设置给TextView utils CmlFontUtil：主要就是加载自定义字体，如assets下fonts包下的Barlow-Medium.ttf字体 相关链接 Module的使用 Adapter的使用 "},"chameleon_client/android/module.html":{"url":"chameleon_client/android/module.html","title":"Module 的使用","keywords":"","body":"Module 的使用 　　github地址点这里 　　根目录 assets 目录下的 cml-demo-say.zip 是个简单的示例工程，用来演示native 和 weex容器或web容器的双向通信 1. 什么是 module module 是 Native 提供给前端页面调用的，完成一组操作的方法集合，用于扩展 Native 的能力。在 Chameleon 页面中，开发者引入相关js库后即可调用 module 中的方法。 import bridge from 'chameleon-bridge'; // 主动调用客户端方法 export function sayHello() { bridge.callNative( 'moduleDemo', // 模块名 'sayHello', // 方法名 {}, // 参数 res => {} // 回调方法 ); } 2. Module 的使用 Module 的使用分两种情况，一种是使用 Chameleon SDK 内置的Module，一种是用户自定义实现自己的 Module。 2.1 使用内置的 Module 内置的 Module 在js 前端代码里直接使用即可，目前内置的 Module 有： clipboard cml modal storage stream webSocket Chameleon DOC 《API一章》 里描述的能力，部分实现就是由上述 module 支撑的。 2.2 自定义实现自己的 Module 示例可参看《手把手第4.4小节说明》 module 扩展3个重要的注解 @CmlModule 标注这个类是扩展模块 @CmlMethod 标注可供JS侧调用的方法 @CmlParam 标注调用的参数 详细说明 功能：通过注册module提供原生能力的扩展 原理：依赖bridge进行协议通信，根据不同module进行协议处理分发 module，扩展原生能力 module注册 必须注册CmlEngine.registerModule(Class moduleClass) 不强制要求添加@CmlModule,未添加时会使用默认设置 不建议在运行中动态注册module module名称 默认使用module的类名 配置module名称，添加注解@CmlModule(alias = \"name\") module实例 默认为实例全局唯一，即无论有多少instance都会使用同一个module实例 配置全局性，添加注解@CmlModule(global = false) module组合 针对极特殊情况，允许多个class共用一个module名称 必须有且只有一个class作为module，所有相关class均会使用该moduel配置 其余class必须使用@CmlJoin(name = \"name\")，指定需要关联的moduel名称 每个class实例之间无关联，仅会在使用时再创建实例 method，提供原生能力方法 method注册 自动注册module类中所有的public方法 不强制要求添加@CmlMethod,未添加时会使用默认设置 如果不希望方法被误添加，需要在方法上添加@CmlIgnore method名称 默认使用method方法名 配置method名称，添加注解@CmlMethod(alias = \"name\") method线程 默认运行在主线程 配置method线程，添加注解@CmlMethod(uiThread = false) param，原生能力方法所需要的参数 param类型 针对Context、ICmlInstance等上下文类型，会根据调用环境进行查找替换 对于CmlCallback的类型，会构建对应的回调，需要自行处理回调 其余类型会根据bridge传递的参数进行处理 param参数 根据birdge传递的数据，根据参数类型进行转化 目前可转化的类型为JSONObject、String 如果要直接转为对象，需要设置CmlJsonAdapter或接入相应json库 param字段 只想获取传递数据中的某一个对象时，可以使用@CmlParam 添加@CmlParam(name = \"name\")，设置该参数获取的字段 添加@CmlParam(admin = \"admin\")，设置该参数默认值 "},"chameleon_client/android/adapter.html":{"url":"chameleon_client/android/adapter.html","title":"Adapter 的使用","keywords":"","body":"Adapter 的使用 1. 初步认识 Adapter 先看个例子，对 Adapter 有个直观印象和基本概念。Chameleon SDK 里打印日志使用的是默认的 android.util.Log, 如果想替换它可以按照如下步骤实行： 1.1 替换和注册 如果用户想替换 SDK 默认提供的日志打印，可以实现 CmlLoggerAdapter 接口，并按如下方式注册进 SDK: // 接口实现 public class MyLoggerDefault implements CmlLoggerAdapter { @Override public void d(String tag, String msg) { // 这里实现自己的日志打印 } ... } // 接口注册 public class MyApplication extends Application implements ICmlConfig { @Override public void onCreate() { super.onCreate(); CmlEngine.getInstance().init(this, this); } @Override public void configAdapter() { CmlEnvironment.setLoggerAdapter(new MyLoggerDefault()); // 注册自己的Adapter ... } ... } 以上就完成了日志打印能力的替换。 1.2 原理说明 SDK Adapter 定义和默认实现如下： // 日志接口定义 public interface CmlLoggerAdapter { void d(String tag, String msg); ... } // 日志接口默认实现 public class CmlLoggerDefault implements CmlLoggerAdapter { @Override public void d(String tag, String msg) { Log.d(tag, msg); } ... } 如果用户注册了自己的 Log Adapter 实现则优先使用，否则使用 SDK 默认提供的实现。 1.3 日志打印的使用 日志打印通过 CmlLogUtil 类调用，注册自己的 Logger Adapter 后，打印日志的相关方法就会回调到自定义的方法实现里，使用示例： // 日志打印 public void launchPage(@NonNull Activity activity, String url, HashMap options) { if (TextUtils.isEmpty(url)) { CmlLogUtil.e(TAG, \"CmlEngine launchPage, url is empty.\"); return; } ... } 2. Adapter 基本概念 　　Adapter 的目的是定义一系列能力接口来隔离具体的实现，方便 SDK 使用者在需要时灵活替换成自己的实现。Chameleon SDK 框架层在使用 Adapter 相关能力时都是面向接口的，使用者只需要实现相关能力的 Adapter 接口并通过 SDK 注册接口进行注册，即可轻松替换成自己的实现并进行能力扩展。 　　Chameleon SDK 并没有完整的实现所有 Adapter 接口，也就是说一部分有默认实现的 Adapter 可以直接使用，未提供默认实现的需要使用者自己实现，否则框架将无法使用对应的接口能力。 Chameleon SDK 定义了如下的 Adapter 接口 接口 功能 默认实现 ICmlDegradeAdapter 降级 无 ICmlImgLoaderAdapter 图片加载 有 CmlLoggerAdapter 日志 有 ICmlNavigatorAdapter url 跳转 有 ICmlStatisticsAdapter 统计信息输出 无 ICmlWebSocketAdapter WebSocket 有 CmlHttpAdapter Http 请求 有 CmlJsonAdapter json 解析 有 CmlDialogAdapter 对话框 有 CmlToastAdapter 提示浮层 有 CmlStorageAdapter key->value 存储 有 CmlThreadAdapter 线程 有 2.1 重点 Adapter 说明 降级、对话框、提示浮层 Adapter 在 SDK 实际使用时替换可能性较大，分别说明。 2.1.1 降级 　　ICmlDegradeAdapter 降级接口没有提供默认实现，《变色龙SDK使用范例》 示例里示范了如何实现一个降级处理类 CmlDegradeDefault。 CmlDegradeDefault 默认会关闭 native 渲染容器，并打开 Web 容器加载降级url。 public class CmlDegradeDefault implements ICmlDegradeAdapter { @Override public DegradeViewWrapper getDegradeView(int degradeCode) { return new DegradeViewWrapper() { CmlWebView webView; @Override public View getView(@NonNull Context context) { webView = new CmlWebView(context); webView.onCreate(); return webView; } @Override public void onDestroy() { if (null != webView) { webView.onDestroy(); } } @Override public void loadURL(@NonNull Context context, @NonNull String url, @Nullable HashMap options) { if (null != webView) { webView.render(url, null); } } }; } @Override public void degradeActivity(@NonNull Activity activity, @NonNull String url, @Nullable HashMap options, int degradeCode) { if (url.contains(\"?\")) { url = url.substring(0, url.indexOf(\"?\")); } CmlEngine.getInstance().launchPage(activity, url, null); } } degradeActivity 会在如下降级场景发生时回调 下载 JSBundle 失败 解析 JSBundle 发生异常 降级调试开关打开(在CmlEnvironment里设置) 前端代码手动降级 2.1.2 对话框 此接口定义以下两种对话框能力 showAlert showConfirm CmlModalTip 实现了此接口，通过 CmlModalModule 类暴露给 JS 侧调用，前端用法参考 Chameleon DOC API一章的 《交互反馈》 2.1.3 提示浮层 此接口定义以下浮层提示能力 showToast CmlModalTip 实现了此接口，通过 CmlModalModule 类暴露给 JS 侧调用，前端用法参考 Chameleon DOC API一章的 《交互反馈》 2.2 其他 Adapter 说明 2.2.1 图片加载 CmlDefaultImgLoaderAdapter ，默认使用 Glide，需要用户手动集成 Glide 2.2.2 日志打印 CmlLoggerDefault，默认使用系统 log 输出 2.2.3 跳转 默认使用 Intent.ACTION_VIEW 处理 2.2.4 统计信息输出 没有默认实现，不关心可以不用实现 2.2.5 WebSocket CmlDefaultWebSocketAdapter，默认使用 OkHttp3，需要用户手动集成 OkHttp3 2.2.6 Http 请求 执行 http 请求，并监听 http 响应 2.2.7 json 解析 转换成 json 字符串和反解成 json 对象 2.2.8 key->value 存储 前端用法参考 Chameleon DOC API一章的 《数据存储》 2.2.9 线程 定义工作线程和 ui 线程 "},"chameleon_client/android/cache.html":{"url":"chameleon_client/android/cache.html","title":"预加载和缓存","keywords":"","body":"预加载和缓存 1. 预加载和缓存概念 预加载和缓存都是为了节省 JSBundle 下载的时间，加快 UI 的渲染。 1.1 预加载 预加载是将下载 JSBundle 的动作提前完成，在需要用到的时候直接从本地读取并渲染。实际项目使用中，可以将需要预加载的 url 地址列表在app启动时提前从服务端获取，通过 Chameleon SDK 提供的预加载能力提前下载下来。 1.2 缓存 对于没有预加载的 JSBundle 在渲染前需要先下载，下载完成后 Chameleon SDK 会缓存此 JSBundle，下次渲染同一个 JSBundle时，如果此 JSBundle 没有更新则不会下载新的，达到节省时间和流量提升渲染速度的目的。 2. JsBundleMgr JsBundleMgr是一个对js进行下载、缓存的一个模块，根据协议来实现js增量更新功能。主要有以下内容 | |——cache 基于DiskLrucache来实现缓存功能 |——code js代码的获取及管理 |——net 采用httpUrlConnect实现下载功能 |——utils 工具包 |——CmlJsBundleConstant 常量的管理 |——CmlJsBundleEngine 实现了CmlJsBundleManager接口，入口类 |——CmlJsBundleEnvironment 当前环境的设置，如debug环境等 |——CmlJsBundleManager 实现此接口可自己定义JsBundle的管理 |——CmlJsBundleMgrConfig 配置类，设置预加载js路径、缓存大小等，默认预加载及运行时缓存大小是4M，可自行设置 2.1 code 对js代码进行预加载、获取、缓存的管理。在该包里，我们将拿到的url根据协议来拆分成多个url1、url2等，然后在根据url1、url2等来获取对应的js代码，首先从本地缓存里获取去寻找对应的js代码，如果不存在则从网络去下载并保存在本地 utils 一些文件管理、拆分url、网络判断的工具类 CmlCodeUtils：获取到的url、code的拆解及合并 CmlFileUtils：sd卡及缓存目录的判断 CmlLogUtils：Log的实现 CmlNetworkUtils：当前网络状态的判断，如Wi-Fi、4g等 CmlUtils：Md5的生成、主线程判断等等 2.2 CmlJsBundleConstant 缓存文件名、预加载优先级的管理，预加载优先级有以下三种类型 普通（PRIORITY_COMMON）：非Wi-Fi情况不预加载 强预加载（PRIORITY_FORCE）：无论什么网络情况都预加载 强预加载+预解析（PRIORITY_FORCE_MAX）：目前未用到 2.3 CmlJsBundleEngine 实现了CmlJsBundleManager接口，主要有以下三个方法 initConfig(Context,CmlJsBundleMgrConfig)：初始化config，主要是设置预加载url、预加载缓存、运行时缓存的设置，预加载及运行时缓存默认为4M startPreload()：开始预加载，目前预加载成功或者失败并没有任何信息返回，只能查看log进行分析 getWXTemplate(String,CmlGetCodeStringCallback)：获取js代码 2.4 CmlJsBundleManager 实现此接口可以自己定义JsBundleMgr的实现 2.5 使用 添加依赖 compile 'com.didiglobal.chameleon:js-bundle-mgr:latest.version' 预加载 CmlJsBundleEnvironment.DEBUG = true; List cmlModels = new ArrayList<>(); CmlModel model = new CmlModel(); model.bundle = CmlUtils.parseWeexUrl(url1); model.priority = 2; cmlModels.add(model); model = new CmlModel(); model.priority = 2; model.bundle = CmlUtils.parseWeexUrl(url2); cmlModels.add(model); CmlJsBundleMgrConfig config = new CmlJsBundleMgrConfig.Builder().setPreloadList(cmlModels).build(); CmlJsBundleEngine.getInstance().initConfig(this, config); CmlJsBundleEngine.getInstance().startPreload(); 获取Js代码 CmlJsBundleEngine.getInstance().initConfig(this, new CmlJsBundleMgrConfig.Builder().build()); String url = CmlUtils.parseWeexUrl(url); CmlJsBundleEngine.getInstance().getWXTemplate(url, new CmlGetCodeStringCallback() { @Override public void onSuccess(String codes) { Log.i(TAG, \"onSuccess: \" + codes); } @Override public void onFailed(String errMsg) { Log.i(TAG, \"onFailed: \" + errMsg); } }); "},"chameleon_client/sdk_api.html":{"url":"chameleon_client/sdk_api.html","title":"SDK 独有方法","keywords":"","body":"Chameleon SDK 独有方法 getSDKInfo 获得SDK信息 参数 无 返回值 返回promise 返回值 类型 说明 version String 版本号 inSDK 同步方法，判断webview或native页面是否在sdk环境中，目前只用于内部封装方法使用。 参数 无 返回值 返回值 类型 说明 value Boolean true：在sdk环境中；false：不在sdk环境中 import bridge from 'chameleon-bridge'; const inSDK = bridge.inSDK(); // true/false rollbackWeb 降级到chameleon url对应的h5地址。 callNative(module:String, method:String, args:Object, callback:Function) js调用native sdk import bridge from 'chameleon-bridge'; // 主动调用客户端方法 export function sayHello() { bridge.callNative( 'moduleDemo', // 模块名 'sayHello', // 方法名 {}, // 参数 res => {} // 回调方法 ); } listenNative(module:String, method:String, callback:Function) 监听客户端调用js import bridge from 'chameleon-bridge'; // 监听客户端调用js export function listenTell() { bridge.listenNative( 'moduleDemo', // 模块名 'NaTellJS', // 方法名 res => { // 回调方法中处理返回的数据 } ); } "},"chameleon_client/js_cache.html":{"url":"chameleon_client/js_cache.html","title":"端 JS 包资源缓存、更新和预加载","keywords":"","body":"端JS包资源缓存、更新和预加载 缓存策略 浏览器在加载静态资源的时候一般的话会使用两种HTTP缓存管理机制： 强制缓存(Cache-Control、Expires) 协商式缓存(ETag、Last-Modified) 类似的，在使用chameleon sdk加载JS包的时候也会提供两种缓存管理机制： 基于LRU的强制缓存 类HTTP的协商式缓存(后续发布) 基于LRU的强制缓存 基于LRU的缓存策略，简单来说就是实现了一个缓存池，每次请求先从缓存池中搜索一下，如果有就直接使用缓存池中的JS包，如果没有，就从网络上请求JS包资源并将资源缓存在缓存池中，每一份JS包缓存按照最后使用时间排序，当缓存池满了以后，将最早使用过的缓存从缓存池中清理出去，保证客户端上的资源占用可控。 如何配置 iOS android 类HTTP的协商式缓存(后续发布) 与普通浏览器实现的协商式缓存类似，用户只需在静态资源服务端配置好静态资源的协商式缓存头部，即可实现与普通浏览器一致的方式使用协商式缓存。 更新策略 当JS包升级迭代需要在客户端内使用最新的包时，在使用两种缓存方式下，相应的存在两周更新方式，下面会详细介绍 强制缓存下的更新： 由于强制缓存，客户端不会主动的去向服务器请求最新的更新包，会导致客户端一直使用老的版本。 为了能够打到规避这种情况，我们提供了一种可供参考的解决方案： 配置文件指纹 设置chameleon.config.js中的hash: true，具体可参考工程化配置之文件指纹，chameleon项目构建出的JS包文件名会类似如下 test_project_c6bdf9074a821f01e70f.js 上线打包出来的JS包 得到以下可以访问的资源地址 https://www.static.com/test_project_c6bdf9074a821f01e70f.js 替换入口资源地址 将入口页面中的chameleon urlcml_addr替换成encodeURIComponent后的最新资源地址即可，比如 原chameleon url: https://www.static.com/test_project.html?cml_addr=https%3A%2F%2Fwww.static.com%2Ftest_project_21f01e70fc6bdf9074a8.js 新的chameleon url https://www.static.com/test_project.html?cml_addr=https%3A%2F%2Fwww.static.com%2Ftest_project_c6bdf9074a821f01e70f.js 最佳实践 由于强制缓存下每次修改都需要修改入口页面的chameleon url中的cml_addr参数，可能会导致修改频繁影响效率，所以建议通过后端读取map.json的方式下发跳转chameleon url进行统一管理。 具体请求过程如下图所示: JS包修改上线后，同时将map.json上线到服务器上 入口页面加载数据时，服务器从map.json文件中查询到要跳转的chameleon url，并与初始化数据合并和下发给入口页面。 入口页面逻辑将接受到的chameleon url作为需要跳转的链接进行使用。 这样每次bundle修改后可以自动完成更新 协商式缓存下的更新： 可以直接使用http的缓存更新策略，不需额外的配置。 预加载 在某些场景下，为了能够让页面更快的呈现在用户面前，需要让客户端提前下载一些js包，这时就需要用到预加载。 如何配置 iOS android 参考《变色龙SDK使用范例》第6节 "},"extend/extend.html":{"url":"extend/extend.html","title":"定制扩展端","keywords":"","body":"定制扩展端(Terminal expand)[chameleon-tool@0.4.0-mvvm.6 版本生效] 希望扩展支持 头条小程序、淘宝小程序、高德小程序、react-native？ 你只需按标准流程即可扩展，敬请期待： xxx-runtime ：运行时 xxx-ui: 扩展组件 xxx-api: 基础 api xxx-linter: 语法检查器 xxx-parse: 解析器 原理解释 实现原理图 首先任何一份应用层的高级语言代码块分成几层：语言层（Language）、框架层（Framewrok）与库层（Library）： Language —— 通俗来说，实现程序所需的基本逻辑命令：逻辑判断(if)、循环(for)与函数调用（foo())等。 Framewrok —— 通俗来说，完成一个 App 应用交互任务所需规范，例如生命周期（onLoad、onShow）、模块化与数据管理等。 Library —— 可以理解就是“方法封装集合”。比如 Web 前端中 Vue 更适合叫框架，而 jQuery 更适合叫库；Android 系统下 activity manager + window Manager View System 等的集合叫框架，而 SQLite 、libc 更适合叫库。 对应到 Chameleon 就是这样： 你可以理解 Chameleon 为了实现“让 MVVM 跨端环境大统一”的目标做了以下工作： 定义了标准的 Language(CML DSL)、Framework 与 Library（内置组件和 API）协议层。 在线下编译时将 DSL 转译成各端 DSL，只编译 Language 层面足够基础且稳定的代码。 在各个端运行时分别实现了 Framework 统一，在各个端尽量使用原有框架，方便利用其生态，这样很多组件可以直接用起来。 在各个端运行时分别实现了 Library（内置组件和 API）。 为用户提供多态协议，方便扩展以上几方面的内容，触达底层端特殊属性，同时提升可维护性。 信息/协议 框架协议（Framework) API 接口协议（Library) 内置组件协议（Library) DSL 协议（Language) 用户可扩展协议 实现 Chameleon Runtime chameleon-api chameleon-ui-builtin chameleon tool chameleon tool 描述 各端引擎中按规范各自实现；实现框架生命周期、数据流向、尺寸单位、路由 各端引擎中按规范各自实现；为本地能力调用提供基类 各端引擎中按规范各自实现；为界面开发提供基类 编译转换（组件调用、循环、条件判断、事件回调关联、父子关系等等，不涉及具体什么组件该传什么参数）；提供标准数据驱动规范语法 多态协议标准；提供多端差异化实现。 实现思路很简单，所有设计为了 MVVM 标准化，不做多余设计，所以宏观的角度就像 Node.js（libuv）同时运行在 Windows 和 macOS 系统，都提供了一个跨平台抽象层。 如何扩展端 实现运行代码 按照标准协议实现 chameleon-runtime、chameleon-api、chameleon-ui-builtin框架 实现编译代码输出 编译时代码主要是完成 CML 的 DSL 到目标端 DSL 转译和文件夹结构输出。 具体如下请看 实现编译代码输出 "},"extend/quickstart.html":{"url":"extend/quickstart.html","title":"操作教程","keywords":"","body":"扩展新端开发指南 开发示例体验 扩展新端demo示例仓库: https://github.com/yylgit/cml-extplatform-demo。 实现了微信端的基本扩展。 运行项目 首先全局安装支持扩展新端的脚手架npm i chameleon-tool@0.4.0-mvvm.6 -g。 全局安装lerna 对本项目进行管理 npm i lerna -g。 在本仓库根目录执行lerna bootstrap，这一步是安装外部依赖与建立本仓库npm包之间的依赖。 在cml-demo-project目录执行cml demo dev, 用微信开发者工具打开cml-demo-project/dist/demo目录。 开发流程 采用lerna对开发的npm包进行管理，解决本地开发时多个npm包之间相互依赖的问题。lerna init即可创建一个lerna项目。 1 确定名称 创建npm包 端标识，扩展一个新端首先要确定这个端的标识名称，例如微信小程序端为wx,百度小程序端为baidu，这个标识决定了构建命令的名称、多态协议中的cmlType, 配置对象中的cmlType等。 示例中确定为demo。 运行时npm包名称， 建议以cml-${端标识名称}-runtime格式命名，示例中为cml-demo-runtime。 api库npm包名称， 建议以cml-${端标识名称}-api格式命名，示例中为cml-demo-api。 内置组件npm包名称， 建议以cml-${端标识名称}-ui-builtin格式命名，示例中为cml-demo-ui-builtin。 扩展组件npm包名称， 建议以cml-${端标识名称}-ui格式命名，示例中为cml-demo-ui。 数据管理npm包名称， 建议以cml-${端标识名称}-store格式命名，示例中为cml-demo-store。 编译插件npm包名称， 建议以cml-${端标识名称}-plugin格式命名，示例中为cml-demo-plugin。 在packages目录创建上述的6个npm包。 2 创建开发cml项目 在packages目录创建一个cml的项目作为测试项目，开发过程中可以进行调试代码。示例中为cml-demo-project。 1 cml-demo-project的chameleon.config.js需要 添加extPlatform，babelPath，builtinNpmName字段的配置，配置如下： cml.config.merge({ builtinNpmName: 'cml-demo-ui-builtin', extPlatform: { demo: 'cml-demo-plugin', }, babelPath: [ path.join(__dirname,'node_modules/cml-demo-ui-builtin'), path.join(__dirname,'node_modules/cml-demo-runtime'), path.join(__dirname,'node_modules/cml-demo-api'), ] }) 你的项目中注意把示例npm包名称改成你命名的npm包名称。 builtinNpmName 字段是你定义的内置npm包名称 extPlatform是配置扩展新端的编译插件，key值为端标识，value为编译插件npm包名称。 babelPath 配置运行时相关的三个npm包需要过babel 2 cml-demo-project的package.json的dependencies中添加这几个开发npm包。 \"cml-demo-api\": \"1.0.0\", \"cml-demo-plugin\": \"1.0.0\", \"cml-demo-runtime\": \"1.0.0\", \"cml-demo-ui-builtin\": \"1.0.0\" 3 在仓库的根目录执行lerna bootstrap安装依赖，建立关联，这样cml-demo-project的node_modules下的这几个npm包会符号链接到packages下的同名npm包。 建议开发顺序： 编译插件，先完成基本的编译和打包 运行时，实现VM对象统一 api、内置组件、扩展组件 数据管理 3 编译插件 参考cml-demo-plugin/index.js文件 实现编译类。对项目中的每一个文件或者部分进行编译处理。处理节点的source字段，编译后结果放入output字段。 3.1模板编译 监听compile-template事件 参数列表：(currentNode，parentNodeType) currentNode 当前处理的节点 parentNodeType 父节点的nodeType，如果是app/page/component节点的子节点会有值，否则为undefined 说明： 这个钩子用于处理cml文件的模板部分，如果模板是类vue语法，内部已经将其转为标准的cml语法，这个阶段用于对模板语法进行编译，生成目标代码。 compiler.hook('compile-template', function(currentNode, parentNodeType) { currentNode.output = templateParser(currentNode.source) }) mvvm-template-parser这个npm包提供了模板编译的方法。 const {cmlparse, generator, types: t, traverse} = require('mvvm-template-parser'); cmlparse 将字符串转为ast语法树 traverse 对语法树进行遍历 types 语法树节点类型判断 generator 语法树生成字符串 例如模板编译方法如下： const {cmlparse, generator, types: t, traverse} = require('mvvm-template-parser'); module.exports = function(content) { let ast = cmlparse(content); traverse(ast, { enter(path) { let node = path.node; if (t.isJSXElement(node)) { let attributes = node.openingElement.attributes; attributes.forEach(attr=>{ if(t.isJSXIdentifier(attr.name) && attr.name.name === 'c-for') { attr.name.name = 'wx:for' } if(t.isJSXIdentifier(attr.name) && attr.name.name === 'c-if') { attr.name.name = 'wx:if' } }) let tagName = node.openingElement.name.name; if(/^origin\\-/.test(tagName)) { let newtagName = tagName.replace(/^origin\\-/,''); node.openingElement.name.name = newtagName; node.closingElement.name.name = newtagName; } } } }); return generator(ast).code; } 上面的方法就可以将 模板 True 编译为 True 对模板ast的编译本质上是对目标节点的增删改，通过类型判断确定目标节点. 可以使用网站https://astexplorer.net/ 方便我们确定节点类型。该网站是将ast中的节点图形化展示出来，注意选择javascript,babylon7 jsx。 增删改的api参考babel插件编写文档https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-replacing-a-node-with-multiple-nodes。 我们没有直接让用户采用babel系列 是因为对generator和parser内部都有做针对cml的改造。 3.2 样式编译 监听compile-style事件 参数列表：(currentNode，parentNodeType) currentNode 当前处理的节点 parentNodeType 父节点的nodeType，如果是app/page/component节点的子节点会有值，否则为undefined 说明： 这个钩子用于处理所有的style节点，内部已经对less stylus等语法进行编译处理，这里得到的已经是标准的css格式，可以转成对应端的样式，比如对尺寸单位cpx的转换，将css转成对象形式等。 compiler.hook('compile-style', function(currentNode, parentNodeType) { currentNode.output = styleParser(currentNode.source); }) 推荐用户使用postcss或者rework进行编译，参考cml-demo-plugin/styleParser.js的实现。利用了chameleon-css-loader中的postcss插件进行编译。例如： const postcss = require('postcss'); const cpx = require('chameleon-css-loader/postcss/cpx.js') const weexPlus = require('chameleon-css-loader/postcss/weex-plus.js') module.exports = function(source) { let options = { cpxType: 'rpx' } return postcss([cpx(options), weexPlus()]).process(source).css; } 上面方法可以将 内容 .test { font-size: 24cpx; lines: 1; } 编译为： .test { font-size: 24rpx; lines: 1; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; } 3.3 script编译 参数列表：(currentNode，parentNodeType) currentNode 当前处理的节点 parentNodeType 父节点的nodeType，如果是app/page/component节点的子节点会有值，否则为undefined 说明： 这个钩子用于处理script节点，内部已经对js文件进行了babel处理，这个阶段用于做模块的包装，compiler.amd对象提供了amd模块的包装方法，模块id使用节点的modId字段。例如： compiler.hook('compile-script', function(currentNode, parentNodeType) { currentNode.output = compiler.amd.amdWrapModule(currentNode.source, currentNode.modId); }) 例如一个节点source如下，modId为'./component/test.js'： module.exports = function() { return 'test'; } 经过compiler.amd.amdWrapModule(currentNode.source, currentNode.modId)处理后成为 cmldefine('./component/test.js', function(require, exports, module) { module.exports = function() { return 'test'; } }) 3.4 asset编译 静态资源的编译和script节点的编译相同，因为cml内部已经将静态资源节点变成了资源的publicPath字符串。 例如src/assets/img/chameleon.png这个节点的source为 module.exports = 'http://168.1.1.1:8000/static/img/chameleon.png' 经过compiler.amd.amdWrapModule(currentNode.source, currentNode.modId)处理后成为 cmldefine('./component/test.js', function(require, exports, module) { module.exports = 'http://168.1.1.1:8000/static/img/chameleon.png'; }) 更多编译事件参考 扩展新端手册。 3.5 编译打包与文件输出 参考cml-demo-plugin/index.js中对compiler.hook('pack', function(projectGraph) {}) pack事件的实现，编译编译图，拼接目标文件，调用compiler.writeFile输出文件。 运行时开发 运行时主要是对VM对象进行适配。内部将vm对象分为三类App、Page、Component。对应会调用用户运行时npm包的createApp、createPage、createComponent方法。 在上述的编译插件中添加上运行时npm包名称和运行时方法是否需要组件。 constructor(options) { this.runtimeNpmName = 'cml-demo-runtime'; this.runtimeNeedComponents = false; } 例如一个Page的VM对象如下： class PageIndex { data = { name: 'chameleon' } computed = { name2 () { return 'Hello' + this.name; } } beforeCreated() { } mounted() { } } export default new PageIndex(); 编译时就会插入用户配置的运行时方法： class PageIndex { data = { name: 'chameleon' } computed = { name2 () { return 'Hello' + this.name; } } beforeCreated() { } mounted() { } } export default new PageIndex(); // 编译时自动插入用户配置的运行时方法 import {createPage} from 'cml-demo-runtime'; createPage(exports.default); runtimeNeedComponents 字段决定运行时是否需要组件对象，如果为true，则会传入usingComponents中的组件对象。 class PageIndex { } export default new PageIndex(); // 编译时自动插入用户配置的运行时方法 import {createPage} from 'cml-demo-runtime'; import demoCom from '../components/demo-com/demo-com.cml' createPage(exports.default,{demoCom}); createApp、createPage、createComponent方法实现。参考cml-demo-runtime的结构进行实现，createApp、createPage、createComponent都需要includechameleon-runtime中相应的接口进行实现，才能够实现对chameleon-runtime的扩展。用户的工作量主要在于对vm对象的处理，可以参考chameleon-runtime中的实现方式。 运行时可以配置编译模板实现部分语法，例如事件对象的统一，c-model语法糖的实现。 api库开发 详见扩展新端api库 内置组件库开发 详见扩展新端内置组件库 扩展组件库开发 扩展组件库开发与内置组件库开发大致相同，不同的是需要继承实现cml-ui中的组件。参考cml-demo-ui的实现。 "},"extend/vm.html":{"url":"extend/vm.html","title":"VM 对象标准","keywords":"","body":"VM对象协议 逻辑层负责反馈用户对界面操作的处理中心。 而 VM 对象 是逻辑层规范的输入口，是运行时方法(ceateApp、createComponent、createPage)的输入，包括 字段名类型说明 propsObject 声明当前组件可接收数据属性 props = { type, default } type为数据类型，default为数据默认值 dataObjectCML模板可直接使用的响应数据，是连接视图层的枢纽 methodsObject处理业务逻辑与交互逻辑的方法 watchObject侦听属性，监听数据的变化，触发相应操作 computedObjectCML模板可直接使用的计算属性数据,也是连接视图层的枢纽 beforeCreateFunction例初始化之后，数据和方法挂在到实例之前 一个页面只会返回一次 createdFunction数据及方法挂载完成 beforeMountFunction开始挂载已经编译完成的cml到对应的节点时 mountedFunctioncml模板编译完成,且渲染到dom中完成 beforeDestroyFunction实例销毁之前 destroyedFunction实例销毁后 理解了每个输入字段代表的含义后，可以扩展(ceateApp、createComponent、createPage)处理VM对象，将VM对象转换成当前平台可接收的格式。 2 运行时能力注入 映射，并且在各生命周期中，注入新端到cml框架的运行时能力 2.1 生命周期hook映射 每个 cml 实例(App、Page、Component)在被创建时都要经过一系列的初始化过程 ———— 例如，需要设置数据监听、编译模板、将实例挂载到 \bCML节点 并在数据变化时更新 \bCML节点 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给开发者在不同阶段添加自己的代码的机会。 cml 为App、页面Page、组件Component 提供了一系列生命周期事件，保障应用有序执行。 另外，你还需要实现 生命周期多态。 2.2 methods 应用程序运行过程中，提供给上下文this可调用的方法 2.3 数据驱动能力 当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。 注入的核心是：赋予生命周期hook mixins扩展能力，并且在特定hook中，赋予this响应数据变化的能力 2.3.1 data 数据属性 2.3.2 watch 监听属性 2.3.3 computed 计算属性 "},"extend/component.html":{"url":"extend/component.html","title":"组件化标准","keywords":"","body":"组件化标准 MVVM标准中将.cml文件分为三类，src/app/app.cml为app，router.config.json中配置的路由对应的文件为page，其他的.cml文件为component。 组件引用 在.cml文件的json部分，usingComponents字段中声明组件的引用。 例如： { \"base\":{ \"usingComponents\": { \"navi\": \"/components/navi/navi\", \"c-cell\": \"../components/c-cell/c-cell\", \"navi-npm\": \"cml-test-ui/navi/navi\" } } } usingComponents对象中，key为组件名称，组件名称为小写字母、中划线和下划线组成。value为组件路径，组件路径的规则如下： 相对当前文件的相对路径 src下的绝对路径 node_modules下的组件直接从npm的包名称开始写例如cml-test-ui/navi/navi 组件的路径禁止包含后缀扩展名，查找的优先级为 1.interface文件指向的多态组件 2 .cml文件 3 用户通过hook: find-component找到的组件 组件使用 组件在CML模板中使用，组件名为usingComponents中的key值，组件使用形式为闭合标签，标签名为组件名。例如： { \"base\":{ \"usingComponents\": { \"c-cell\": \"../components/c-cell/c-cell\" } } } "},"extend/event.html":{"url":"extend/event.html","title":"事件标准","keywords":"","body":"事件系统标准 Chameleon 支持一些基础的原生事件和自定义事件，保障各端效果一致运行。 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 原生事件标准 当用户点击该组件的时候会在该组件逻辑vm对象的methods中寻找相应的处理函数，该处理函数会收到一个事件对象。 原生基础事件的类型 类型 触发条件 tap 手指触摸后马上离开 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchend 手指触摸动作结束 原生事件对象 它有以下属性： 名称 类型 说明 type String 事件类型 timeStamp Number 页面打开到触发事件所经过的毫秒数 target Object 触发事件的目标元素 且 target = { id, dataset } currentTarget Object 绑定事件的目标元素 且 currentTarget = { id, dataset } touches Array 触摸事件中的属性，当前停留在屏幕中的触摸点信息的数组 且 touches = [{ identifier, pageX, pageY, clientX, clientY }] changedTouches Array 触摸事件中的属性，当前变化的触摸点信息的数组 且 changedTouches = [{ identifier, pageX, pageY, clientX, clientY }] detail Object 自定义事件所携带的数据。 通过`$cmlEmit`方法触发自定义事件，可以传递自定义数据即detail。具体下面`自定义事件`。 _originEvent Object chameleon对各平台的事件对象进行统一，会把原始的事件对象放到_originEvent属性中，当需要特殊处理的可以进行访问。 target && currentTarget 事件属性 属性类型说明 idString事件源组件的id datasetObject事件源组件上由`data-`开头的自定义属性组成的集合 offsetLeftNumber事件源组件相对于窗口左侧的距离 offsetTopNumber事事件源组件相对于窗口上侧的距离 --> touches && changedTouches 事件属性 数组中的对象具有如下属性： 属性类型说明 identifierNumber触摸点的标识符 pageX, pageYNumber距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴 clientX, clientYNumber距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴 自定义事件标准 自定义事件用于父子组件之间的通信，父组件给子组件绑定自定义事件，子组件内部触发该事件。绑定事件的方法是以bind+事件名称=\"事件处理函数的形式给组件添加属性，规定事件名称不能存在大写字母触发事件的方法是调用this.$cmlEmit(事件名称,detail对象)。 "},"extend/store.html":{"url":"extend/store.html","title":"状态管理标准","keywords":"","body":"状态管理 数据管理 createStore 创建返回数据store实例 store实例方法 Store.commit(type: string, payload?: any) 提交 mutation。详细介绍 Store.dispatch(type: string, payload?: any) 分发 action。详细介绍 Store.mapState(map: Array | Object): Object 为组件创建计算属性以返回 store 中的状态。详细介绍 Store.mapGetters(map: Array | Object): Object 为组件创建计算属性以返回 getter 的返回值。详细介绍 Store.mapMutations(map: Array | Object): Object 创建组件方法提交 mutation。详细介绍 Store.mapActions(map: Array | Object): Object 创建组件方法分发 action。详细介绍 Store.registerModule(path: String, module: Module) 注册一个动态模块。详细介绍 "},"extend/api.html":{"url":"extend/api.html","title":"实现接口能力 chameleon-api","keywords":"","body":"扩展新端api库 用户需要创建一个npm包，参考cml-demo-api。利用多态接口扩展语法，在目标端对每一个内置api的接口进行实现，要保证接口参数的一致。 扩展新端API（以头条小程序为例，假设端扩展标识为：toutiao）: // 引入官方标准interface文件 // 扩展实现新端（以头条小程序为例，假设端扩展标识为：toutiao） class Method implements uiInterface { alert(opt, successCallBack, failCallBack) { // 根据头条小程序实现alert弹窗 let { message, confirmTitle} = opt; tt.showModal({ showCancel: false, title: '', content: message, confirmText: confirmTitle, success() { successCallBack(confirmTitle); }, fail() { failCallBack(confirmTitle); } }); } } export default new Method(); // 想覆写某已有端的方法实现（以微信小程序为例） class Method implements uiInterface { alert(opt, successCallBack, failCallBack) { // 按你的想法重新实现 } } export default new Method(); 需要注意的是，为了方便结合异步流程控制如async、await等进行操作，chameleon官方提供的api接口均以promise形式进行返回。所以你可以在外层使用js文件进行包装，将interface实现进行promise化或进行其他操作（如传入默认值）。 import ui from './index.interface'; export default function alert(opt) { let { message = '操作成功', confirmTitle = '我知道了' } = opt; return new Promise((resolve, reject) => { ui.alert({ message, confirmTitle }, resolve, reject) }); } "},"extend/ui-builtin.html":{"url":"extend/ui-builtin.html","title":"实现内置组件 chameleon-builtin","keywords":"","body":"内置组件扩展 用户需要创建一个npm包，参考cml-demo-ui-builtin。利用多态接口扩展语法，在目标端对每一个内置组件的接口进行实现，要保证接口参数的一致。 扩展新端组件（以头条小程序为例，假设端扩展标识为：toutiao）: 编写 my-ui-builtin/button/button.interface // 引入官方标准interface文件 编写 my-ui-builtin/button/button.toutiao.cml // 扩展实现新端（以头条小程序为例，假设端扩展标识为：toutiao），具体代码可参考在其他端的实现如：chameleon-ui-builtin/components/button/button.wx.cml {{text}} // js实现部分 // 样式部分 // json配置 "},"extend/start.html":{"url":"extend/start.html","title":"定制扩展端手册","keywords":"","body":"扩展新端手册 安装chameleon-tool@0.4.0-mvvm.6 进行扩展新端的开发。chameleon-tool@0.4.0-mvvm系列版本 灰度扩展新端功能。 跨端框架最核心的工作是统一，定义一个标准格式作为统一的规范，通过编译时+运行时的手段去实现各端的代码和功能。chameleon目前支持的端都是采用这种方式，经过实践发现，几乎所有前端框架的开发都可以统一为一个MVVM+的标准规范。chameleon就定义了这种规范，并提供给各端用户扩展新端的方法。 1 需要统一的工作 首先明确一下我们需要对如下部分进行统一： 1.1 语言统一 cml中共涉及到三种语言，CML模板语言，JS语言，CMSS样式语言。 1、JS语言，前端通用语言，如果目标端也采用js语言则不需要语法的编译。 2、CMSS语言，是标准css语言的子集，具体参见：CMSS样式标准，目标端可以对其进行编译，比如统一尺寸单位将cpx转为px或者rpx。例如weex需要将其转为对象的形式。 3、CML模板语言，这是CML定义的独立语言，具体参见CML模板语言标准，用于描述视图层，包括了循环，条件，数据绑定，事件绑定等语法，用户可以根据CML提供的库，将其转为AST语法树，然后针对节点进行编译，编译后输出代码。 以react-native为例，如何将cml单文件进行语法统一？ 思路是将cmss语言转为js 对象，将cml模板语法进行编译 转为jsx语法 放入render函数。 1.2 路由统一 路由表示了前端应用中各页面之间的组织形式，CML中的路由标准化为JSON格式对象，实际上是项目中router.config.json文件的内容。 必选字段routes为设置页面路由对象的数组，每一个页面路由对象必选字段为path,path指向页面的cml文件，页面必须是普通cml文件，页面不能是多态的，path的取值为相对于项目src下的页面绝对路径，不带.cml文件后缀。 { \"routes\":[ { \"path\": \"/pages/index/index\" } ] } 如果目标端的路由需要有其他的字段，也可以在router.config.json中进行添加，例如web端需要url字段： { \"routes\":[ { \"url\": \"cml/h5/index\", \"path\": \"/pages/index/index\" } ] } 用户可以在编写的插件中通过getRouterConfig方法获取到该对象，在编译的过程中可以根据该json对象进行路由的统一。 例如微信小程序端，可以将路由的path放入到app.json的pages字段，web端如果用vue-router，可以生成vue-router对象，插入到编译过程中。 1.3 VM对象统一 VM对象主要负责逻辑的处理，包括调用底层的接口，和视图层之间的数据绑定和事件绑定。标准格式参见VM对象标准。MVVM+模式中都有VM对象，可以通过实现一套运行时框架，提供方法将VM对象转为目标端的VM对象，处理方法可以通过编译时插入。例如： class Index { data = { title: \"chameleon\", } mounted() { } } export default new Index(); // 插入如下代码 import {createApp} from ('cml-target-runtime'); createApp(exports.default); createApp方法接收VM对象，在运行时将其转化为目标端需要的形式。 1.4 组件化统一 前端开发都是以组件为单位，组件化表示了组件之间的关系，标准具体参见组件化标准。 cml文件中的组件关系放在了json配置部分，在编译时可以使用。 例如web端的编译，可以处理cml文件的script部分的时候，获取组件信息进行插入代码。 1.5 事件统一 事件的统一包括了事件名称的统一和事件对象的统一，标准参见：事件标准。涉及到CML模板语法和VM对象处理的工作。事件名称直接通过CML模板语法编译时就可以转，比如c-bind:tap 编译成 bindtap或者v-on:click。事件对象的统一可以采用事件代理的方式，即让所有的事件都绑定事件代理方法，而在事件代理方法中对事件对象统一处理后再触发原来绑定的方法。而事件代理方法可以在对VM对象进行处理时进行混入。 1.6 状态管理统一 面对多页面、多组件之间进行复杂的状态，状态管理是提高效率的解决方案，标准参见：状态管理标准。实现store实例，如果目标端有类似库，可以做封装统一，例如vuex、redux。或者用mobx实现。 1.7 内置组件统一 CML提供了统一的内置组件，例如button， input 让各端能够表现一致，扩展端需要建立一个组件库对内置组件中的接口进行继承和目标端的实现。具体参见扩展内置组件。 1.8 内置API统一 CML提供了统一的内置API，例如网络请求、数据存储，扩展新端需要建立一个appi库对内置API中提供的方法进行实现，具体参见扩展内置API。 2 扩展新端总体编译流程 扩展新端 首先要了解扩展新端总体的编译流程，理解用户扩展新端的工作处于编译的什么阶段。 黄色部分表示cml脚手架及webpack编译 蓝色部分表示扩展的mvvm+编译 绿色部分表示用户要实现的部分，包括： 扩展内置组件库 扩展API库 扩展运行时 编译插件中监听编译事件，进行各端编译处理 3 编译图与编译节点 在总体编译流程中，webpack编译完成后，会将webpack编译的结果转成标准的mvvm编译图projectGraph，这个图由CMLNode节点构成，先理解编译图的组织形式和节点的数据结构，对用户写编译插件有很大帮助。 3.1 编译节点 编译节点是CMLNode类的实例，CMLNode定义如下: class CMLNode { constructor(options = {}) { this.ext; this.realPath; // 文件物理地址 会带参数 this.nodeType; // app/page/component/module // 节点类型 app/page/component 其他的为module cml文件中的每一个部分也是一个Node节点 this.moduleType; // template/style/script/json/asset this.dependencies = []; // 该节点的直接依赖 app.cml依赖pages.cml pages.cml依赖components.cml js依赖js this.childrens = []; // 子模块 cml文件才有子模块 this.parent; // 父模块 cml文件中的子模块才有 this.source; // 模块源代码 this.convert; // 源代码的格式化形式 this.output; // 模块输出 各种过程操作该字段 this.identifier; // 节点唯一标识 this.modId; // 模块化的id requirejs this.extra; // 节点的额外信息 Object.keys(options).forEach(key => { this[key] = options[key]; }) } } 具体字段含义如下: 字段 含义 nodeType 节点类型，分为app/page/component/module，其中只有src/app/app.cml类型为app， router.config.json中配置的cml文件为page，其他的cml文件为component。非cml文件为Module moduleType 模块类型，当节点的nodeType为app/page/component时，其moduleType为undefined。cml文件中四个部分的moduleType分别为template、script、style、json。其他节点的nodeType为module时，根据文件后缀判断moduleType。 后缀 moduleType值 /\\.css|\\.less|\\.stylus|\\.styls$/ style /\\.js|\\.interface$/ script /\\.json$/ json /\\.(png|jpe?g|gif|svg|mp4|webm|ogg|mp3|wav|flac|aac|woff|woff2?|eot|ttf|otf)(\\?.*)?$ asset 其他后缀 other dependencies 节点的依赖节点，app依赖page page依赖component script节点中依赖require的节点 childrens 节点的子节点，只有cml文件才会有子节点，子节点为cml文件的四个部分，分别为四个节点 parent 节点的父节点，只有cml文件节点的子节点才有父节点 source 经过mvvm标准编译之后节点的代码 convert source的转换格式，source均为字符串，convert可能装成AST或者JSON对象 output 节点的输出内容，建议用户编译可以将编译结果放在output字段用于输出 identifier 节点的唯一标识，是webpack module中的request字段，保证了唯一性 modId 节点的模块id，用于js的模块化id标识 extra 节点的额外信息，例如template节点就会添加上模板使用的原生组件和内置组件信息 ext 文件后缀，例如.js 注意如果引用资源后有参数也会带着，例如 .png?__inline realPath 节点对应的文件路径，注意如果引用资源后有参数也会带着，例如 /user/didi/yyl/project/chameleon.png?__inline 3.2 编译图组织结构 编译图由上节介绍的编译节点组成，以nodeType为app的节点开始形成编译图，内部会递归编译节点，根据节点的类型触发相应的用户编译。 4 如何编写用户插件 扩展内置组件库和内置API库是独立的两个NPM包，其他编译相关的工作都放在用户插件中。 4.1 确定端标识名称 扩展一个新端首先要确定这个端的标识名称，例如微信小程序端为wx,百度小程序端为baidu，这个标识决定了构建命令的名称、多态协议中的cmlType, 配置对象中的cmlType等。 4.2 配置插件 在项目的chameleon.config.js中配置构建目标端命令时要执行的插件,这里配置的只是插件的名称，后面会讲解插件的写法。配置的字段为extPlatform Object类型,key值为上一步确定的端标识名称,value为要实现的插件的npm包名称, 例如要扩展头条小程序，确定标识为toutiao。在配置文件中还需要用builtinNpmName字段配置扩展的内置组件库的名称，例如cml-toutiao-ui： cml.config.merge({ extPlatform: { toutiao: 'cml-toutiao-plugin', builtinNpmName: 'cml-toutiao-ui' } }) 当执行cml 端标识名称 dev|build时将走用户插件进行编译。 4.3 扩展新端插件 上一步讲解了如何配置端标识命令对应的用户插件，这里讲一下插件该如何编写。插件是一个类，要求是npm包的入口。下面展示出这个类的属性和方法。 module.exports = class ToutiaoPlugin { constructor(options) { let { cmlType, media} = options; this.webpackRules = []; // webpack的rules设置 用于当前端特殊文件处理 this.moduleRules = []; // 文件后缀对应的节点moduleType this.logLevel = 3; this.originComponentExtList = ['.wxml']; this.runtimeNpmName = 'cml-demo-runtime'; this.runtimeNeedComponents = false; } /** * @description 注册插件 * @param {compiler} 编译对象 * */ register(compiler) { /** * cml节点编译前 * currentNode 当前节点 * nodeType 节点的nodeType */ compiler.hook('compile-preCML', function(currentNode, nodeType) { }) /** * cml节点编译后 * currentNode 当前节点 * nodeType 节点的nodeType */ compiler.hook('compile-postCML', function(currentNode, nodeType) { }) /** * 编译script节点，比如做模块化 * currentNode 当前节点 * parentNodeType 父节点的nodeType */ compiler.hook('compile-script', function(currentNode, parentNodeType) { }) /** * 编译template节点 语法转义 * currentNode 当前节点 * parentNodeType 父节点的nodeType */ compiler.hook('compile-template', function(currentNode, parentNodeType) { }) /** * 编译style节点 比如尺寸单位转义 * currentNode 当前节点 * parentNodeType 父节点的nodeType */ compiler.hook('compile-style', function(currentNode, parentNodeType) { }) /** * 编译json节点 * currentNode 当前节点 * parentNodeType 父节点的nodeType */ compiler.hook('compile-json', function(currentNode, parentNodeType) { }) /** * 编译other类型节点 * currentNode 当前节点 */ compiler.hook('compile-other', function(currentNode) { }) /** * 编译结束进入打包阶段 */ compiler.hook('pack', function(projectGraph) { // 遍历编译图的节点，进行各项目的拼接 //调用writeFile方法写入文件 // compiler.writeFile() }) } } 下面对插件类中的每一个属性和方法的使用进行介绍。 4.3.1 插件构造函数参数 constructor(options) { let { cmlType, media} = options; } 用户插件的构造函数会接受options参数,cmlType是当前端标识名称，例如web|wx|weex, media是构建的模式，dev|build。 4.3.2 register方法 register方法中接受compiler对象，该对象是编译的核心对象，用户通过该对象注册编译流程。 4.3.3 compiler.hook方法 使用该方法可以注册编译流程，第一个参数是钩子名称，第二个参数是处理函数，处理函数中会接收编译流程对应的参数，下面说明每一个钩子的作用和参数。 compiler.hook(钩子名称, function(参数) { }) 1 compile-preCML 参数列表：(currentNode，nodeType) currentNode 当前处理的节点 nodeType 当前节点的nodeType，app/page/component 说明： 这个钩子是编译cml文件节点之前触发，并且传递cml文件节点，可以通过该钩子去处理cml文件节点的template、json、style、script四个子节点之前需要的联系。 2 compile-postCML 参数列表：(currentNode，nodeType) currentNode 当前处理的节点 nodeType 当前节点的nodeType，app/page/component 说明： 这个钩子是编译完cml文件节点的依赖和子节点后触发，传递cml文件节点，可以通过该钩子去处理cml文件节点编译之后的处理。 3 compile-script 参数列表：(currentNode，parentNodeType) currentNode 当前处理的节点 parentNodeType 父节点的nodeType，如果是app/page/component节点的子节点会有值，否则为undefined 说明： 这个钩子用于处理nodeType='module',moduleType='script'的节点，内部已经对js文件进行了babel处理，这个阶段用于做模块的包装，compiler.amd对象提供了amd模块的包装方法，模块id使用节点的modId字段。例如： compiler.hook('compile-script', function(currentNode, parentNodeType) { currentNode.output = compiler.amd.amdWrapModule(currentNode.source, currentNode.modId); }) 4 compile-template 参数列表：(currentNode，parentNodeType) currentNode 当前处理的节点 parentNodeType 父节点的nodeType，如果是app/page/component节点的子节点会有值，否则为undefined 说明： 这个钩子用于处理nodeType='module',moduleType='template'的节点，如果模板是类vue语法，内部已经将其转为标准的cml语法，这个阶段用于对模板语法进行编译，生成目标代码，转义可以采用mvvm-template-parsernpm包提供的方法，可以将模板字符串转为ast语法树进行操作。例如： const {cmlparse,generator,types,traverse} = require('mvvm-template-parser'); compiler.hook('compile-template', function(currentNode, parentNodeType) { let ast = cmlparse(currentNode.source); traverse(ast, { enter(path) { //进行转义 } }); currentNode.output = generate(ast).code; }) 5 compile-style 参数列表：(currentNode，parentNodeType) currentNode 当前处理的节点 parentNodeType 父节点的nodeType，如果是app/page/component节点的子节点会有值，否则为undefined 说明： 这个钩子用于处理nodeType='module',moduleType='style'的节点，内部已经对less stylus等语法进行编译处理，这里得到的已经是标准的css格式，可以转成对应端的样式，比如对尺寸单位cpx的转换，将css转成对象形式等。例如： compiler.hook('compile-style', function(currentNode, parentNodeType) { //利用编写postcss插件的形式进行转义 let output = postcss([cpx()]).process(currentNode.source).css; currentNode.output = output; }) 6 compile-json 参数列表：(currentNode，parentNodeType) currentNode 当前处理的节点 parentNodeType 父节点的nodeType，如果是app/page/component节点的子节点会有值，否则为undefined 说明： 这个钩子用于处理nodeType='module',moduleType='json'的节点。例如： compiler.hook('compile-json', function(currentNode, parentNodeType) { let jsonObj = currentNode.convert; jsonObj.name = \"用户自定义操作\" currentNode.output = JSON.stringify(jsonObj); }) 6 compile-other 参数列表：(currentNode) currentNode 当前处理的节点 说明： 这个钩子用于处理nodeType='module',moduleType='other'的节点。对于不是cml识别的模块类型进行编译。 7 compile-asset 参数列表：(currentNode，parentNodeType) currentNode 当前处理的节点 parentNodeType 父节点的nodeType，如果是app/page/component节点的子节点会有值，否则为undefined 说明： 这个钩子用于处理nodeType='module',moduleType='asset'的节点，资源节点内部已经将其source转为js语法，返回资源的publichPath,所以将其等同于script节点进行处理。例如： compiler.hook('compile-script', function(currentNode, parentNodeType) { currentNode.output = compiler.amd.amdWrapModule(currentNode.source, currentNode.modId); }) 8 pack 参数列表：(projectGraph) projectGraph 编译图根节点 说明： 所有编译结束之后触发这个钩子，在这个钩子中编译图，拼接目标端的文件内容，调用compiler.writeFile()方法写入要生成的文件路径及内容。 compiler.hook('pack', function(projectGraph) { // 遍历编译图的节点，进行各项目的拼接 //调用writeFile方法写入生成文件 compiler.writeFile('/app.json',projectGraph.output) }) 4.3.4 webpackRules属性 类型：Array 配置weback的module.rules字段，用于扩展目标端特殊文件类型的处理，这里控制的是webpack编译过程，用户可以扩展webpack编译过程的loader。例如： this.webpackRules = [{ test: /\\.vue$/, use: [{ loader:'vue-loader', options: {} }] }] 4.3.5 moduleRules属性 类型：Array 设置文件类型对应的moduleType，可以配合webpackRules使用，内置对应关系如下： [ // 文件后缀对应module信息 { test: /\\.css|\\.less|\\.stylus|\\.styls$/, moduleType: 'style' }, { test: /\\.js|\\.interface$/, moduleType: 'script' }, { test: /\\.json$/, moduleType: 'json' }, { test: /\\.(png|jpe?g|gif|svg|mp4|webm|ogg|mp3|wav|flac|aac|woff|woff2?|eot|ttf|otf)(\\?.*)?$/, moduleType: 'asset' } ] 例如用户可以扩展.vue类型的moduleType为vue。 this.webpackRules = [{ test: /\\.vue$/, moduleType: 'vue' }] 在递归触发用户编译阶段的钩子名称，也是根据节点的moduleType决定，所以用户扩展了节点的moduleType，相应这个节点触发的编译钩子也为compile-${moduleType}, 上面的例子中触发compile-vue。 4.3.6 compiler.amd compiler.amd对象提供了js语言的AMD模块化方案供开发者使用， 1 compiler.amd.amdWrapModule 参数列表 ({content, modId}) content js模块的内容 modId 该模块的Id 说明： 将js模块包装成amd模块。 例如modId为src/pages/index/index.cml,content为如下的模块： class Index { data = { title: \"chameleon\", chameleonSrc: require('../../assets/images/chameleon.png') } } export default new Index(); 调用compiler.amd.amdWrapModule后返回的结果为： cmldefine('src/pages/index/index.cml', function(require, exports, module) { class Index { data = { title: \"chameleon\", chameleonSrc: require('../../assets/images/chameleon.png') } } export default new Index(); }) 2 compiler.amd.getGlobalBootstrap 参数列表 (globalName) globalName 环境的全局变量 说明: 该方法返回js amd模块方案的启动脚本，这个脚本是将cmldefine和cmlrequire都放到用户传递的全局变量上。返回代码如下： (function(cmlglobal) { cmlglobal = cmlglobal || {}; cmlglobal.cmlrequire; var factoryMap = {}; var modulesMap = {}; cmlglobal.cmldefine = function(id, factory) { factoryMap[id] = factory; }; cmlglobal.cmlrequire = function(id) { var mod = modulesMap[id]; if (mod) { return mod.exports; } var factory = factoryMap[id]; if (!factory) { throw new Error('[ModJS] Cannot find module `' + id + '`'); } mod = modulesMap[id] = { exports: {} }; var ret = (typeof factory == 'function') ? factory.apply(mod, [require, mod.exports, mod]) : factory; if (ret) { mod.exports = ret; } return mod.exports; }; })($GLOBAL); // 全局变量 2 compiler.amd.getModuleBootstrap 无参数。 说明： 某些平台没有提供全局变量，所有amd的启动脚本也提供了模块化的方案。返回如下代码： /** * 模块型 */ (function() { var factoryMap = {}; var modulesMap = {}; var cmldefine = function(id, factory) { factoryMap[id] = factory; }; var cmlrequire = function(id) { var mod = modulesMap[id]; if (mod) { return mod.exports; } var factory = factoryMap[id]; if (!factory) { throw new Error('[ModJS] Cannot find module `' + id + '`'); } mod = modulesMap[id] = { exports: {} }; var ret = (typeof factory == 'function') ? factory.apply(mod, [require, mod.exports, mod]) : factory; if (ret) { mod.exports = ret; } return mod.exports; }; module.exports = { cmldefine, cmlrequire } })(); 4.3.7 compiler.writeFile 参数列表 (filePath, content) filePath 文件路径相对路径，会在项目根目录dist/${端标识}下拼接上filePath。 content 输出的文件内容 String or Buffer 说明： 在pack钩子中通知用户所有节点已经编译完成，用户可以遍历projectGraph编译图，进行目标文件的拼接，调用compiler.writeFile方法进行写出，pack钩子执行完毕后，内部编译将输出文件。例如： let appJson = { window: { \"navigationBarTitleText\": \"Chameleon\" } } compiler.writeFile('/app.json', JSON.stringify(appJson)) 扩展新端demo仓库: https://github.com/yylgit/cml-extplatform-demo "},"extend/template.html":{"url":"extend/template.html","title":"CML 模板语言标准","keywords":"","body":"CML模板语言协议 CML支持两种语法，在模板template标签中声明 lang属性即可 声明模板中用 cml 语法 声明模板中用类 vue 的语法 如果不声明的话默认就是cml语法 CML语法协议 数据绑定 模板中的数据要使用 Mustache{{}}将变量包起来，可以作用于 标签内容 {{message}} class Index{ data = { message:\"hello chameleon\" } } 组件属性 简单属性 class Index{ data = { id:0 } } 控制属性 运算：可以在 {{}}中进行简单的运算，支持如下几种形式 三元运算 逻辑判断 5}}\"> 字符串运算 {{'hello' + name}} class Index{ data = { name:'chameleon' } } 数据路径运算 {{object.key}} {{array[0]}} class Index{ data = { object:{key:'Hello'}, array:['Chameleon'] } } 组合 可以在 {{}}中直接写数组； {{item.name}} 列表渲染 默认数组的当前项的下标变量名为 index,数组当前项的变量名为item {{index}}:{{item.message}} class Index{ data = { array:[{ message:\"foo\", },{ message:\"bar\", }] } } 使用 c-for-item可以用来指定数组当前元素的变量名 使用c-for-index可以指定数组当前下标的变量名 {{idx}}:{{itemName.message}} 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态 c-key 的值以两种形式提供 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如： 当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 c-key等于item项中某个property class Index{ data = { array:[{ id:\"foo\", },{ id:\"bar\", }] } } c-key等于关键字 *this class Index{ data = { array:[1,2,3] } } 条件渲染 结合c-else-if c-else 事件绑定 c-bind表示可以冒泡的事件 class Index{ methods = { handleClick(e){ console.log(e) //默认传递一个事件对象参数 } } } c-catch表示阻止冒泡的事件 内联事件 内联事件可以直接传递参数，特殊的参数 $event代表事件对象参数 class Index{ data = { array:[{name:'apple'},{name:'orange'}] } methods = { handleClick1(...args){ console.log(...args) } handleClick1(...args){ console.log(...args) } } } 类Vue语法协议 数据绑定 标签内容 模板中的标签内容中的变量要使用 Mustache{{}}包起来 {{message}} class Index{ data = { message:\"hello chameleon\" } } 标签中的内容支持简单的运算 字符串运算 {{'hello' + name}} class Index{ data = { name:'chameleon' } } 数据路径运算 {{object.key}} {{array[0]}} class Index{ data = { object:{key:'Hello'}, array:['Chameleon'] } } 组件属性 简单属性 模板中组件属性中的变量要通过 :id=\"value\"或者 v-bind:id=\"value\"这种形式去使用。 class Index{ data = { id:0 } } 控制属性 列表渲染 v-for指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 （item,index) in items 形式的特殊语法，items 是源数据数组并且 item是数组元素迭代的别名,index是数组元素的下标 {{index}}:{{item.message}} class Index{ data = { array:[{ message:\"foo\", },{ message:\"bar\", }] } } 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态 :key 的值以两种形式提供 class Index{ data = { array:[{ id:\"foo\", },{ id:\"bar\", }] } } :key等于 数组元素 class Index{ data = { array:[1,2,3] } } 条件渲染 结合v-else-if v-else 5\"> class Index{ data = { length:5 } } 事件绑定 @eventName或者 v-on:eventName 表示可以冒泡的事件 class Index{ methods = { handleClick(e){ console.log(e) //默认传递一个事件对象参数 } } } @eventName.stop或者v-on:eventName.stop表示阻止冒泡的事件 内联事件 内联事件可以直接传递参数，特殊的参数 $event代表事件对象参数 class Index{ data = { array:[{name:'apple'},{name:'orange'}] } methods = { handleClick1(...args){ console.log(...args) } handleClick1(...args){ console.log(...args) } } } "},"example/main.html":{"url":"example/main.html","title":"教程","keywords":"","body":"教程(Tutorial) CML 特点是“一端所见即多端所见”，你只需开发一次就能跑所有端。 跟随这个教程，开启你的 chameleon 跨端开发。 视频教程 1 起步 1.1 安装运行环境 开发 chameleon 项目的第一步是要安装运行环境和全局安装 chameleon-tool\b。 [success] 运行环境 node >= 8.10.0 npm >= 5.6.0 建议安装使用nvm管理 node 版本。 1.2 安装脚手架工具 npm i -g chameleon-tool 注：暂不支持使用 yarn、cnpm 等第三方 npm 工具进行安装。 安装成功后，执行 cml -v 即可查看当前版本， cml -h查看命令行帮助文档，更多命令参见脚手架工具。接下来就可以使用它快速的创建 chameleon 项目。 1.3 创建与启动第一个 chameleon 项目 执行 cml init project 输入项目名称 等待自动执行 npm install 依赖 切换到项目根目录执行cml dev 会自动打开预览界面 预览界面如下： web 端可以点击模拟器内页面右上角打开 \b 新的浏览器窗口。 native 端的效果请 \b 下载chameleon playground(目前可下载 Android 端，IOS 端即将发布)或者下载weex playground扫码预览 微信小程序端请下载微信开发者工具，打开项目根目录下的 /dist/wx 目录预览。 支付宝小程序端请下载支付宝开发者工具，打开项目根目录下的 /dist/alipay 目录预览。 百度小程序端请下载百度开发者工具，打开项目根目录下的 /dist/baidu 目录预览。 快应用正在测试中。 接下来，我们一起看看 chameleon 项目的目录结构与代码构成。 2 目录结构与 \b 代码构成 2.1 目录结构 刚刚生成 \bchameleon 项目的目录结构如下： ├── chameleon.config.js // 项目的配置文件 ├── dist // 打包产出目录 ├── mock // 模拟数据目录 ├── node_modules // npm包依赖，基于多态协议直接使用各端原生组件 ├── package.json └── src // 项目源代码 ├── app // app入口 ├── components // 组件文件夹 ├── pages // 页面文件夹 ├── router.config.json // 路由配置文件 └── store // 全局状态管理 \b 编辑器中语法高亮，暂时使用.vue的插件，参见编辑器插件，后续会推出更强大的插件。 chameleon 的目录结构将组件、页面、路由、\b 全局状态管理、静态资源、模拟数据等按照功能进行划分。更多参见目录结构。 你可以留意到这个项目中的 app 入口、组件和页面 \b 下都是.cml为后缀的文件，接下来我们就看看.cml文件代码构成。 2.2 .cml 文件代码构成 \b 从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，同样道理，chameleon 中采用的是 \bCML + CMSS + JS。我们定义了扩展名为.cml的文件 \b\b 将一个组件需要的所有部分组合（CML、CMSS、JS 逻辑交互、JSON 配置）在一起，更方便开发。 2.2.1 CML CML（Chameleon Markup Language）用于描述页面的结构，我们知道 HTML 是有一套标准的语义化标签，例如 \b 文本是 \b 按钮是。CML 同样具有一套标准的标签，我们将标签定义为组件，CML 为用户提供了一系列组件。CML 中还支持模板语法，例如条件渲染、列表渲染，数据绑定等等，更多参见CML。简单举例： {{ message }} {{ message2 }} {{idx}}: {{itemName.city}} 切换展示 class Index { data = { message: \"Hello Chameleon!\", array: [ { city: \"北京\" }, { city: \"上海\" }, { city: \"广州\" } ], showlist: true }; computed = { message2: function() { return \"computed\" + this.message; } }; watch = { showlist(newVal, oldVal) { console.log(`showlist changed:` + newVal); } }; methods = { changeShow() { this.showlist = !this.showlist; } }; } export default new Index(); 同时，CML 支持使用类 VUE 语法，让你更快入手。 2.2.2 CMSS CMSS(Chameleon Style Sheets)用于描述 CML\b 页面结构的样式语言，其具有大部分 CSS 的特性，也做了一些扩充和修改。 1 支持 c\bss 的预处语言less与 \bstylus。 2 新增了尺寸单位 cpx。在写 CSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。CMSS 在底层支持新的尺寸单位 cpx ，开发者可以免去换算的烦恼，只要交给 chameleon 底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。 3 为了各端样式一致性，内置了一些一致性基础样式。 4 chameleon 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 5 cml 文件中支持样式多态，即可以针对不同的平台写不同的样式。 6 如果只跨 web 和小程序端CMSS 将会更加灵活。 简单举例： @import \"./global.css\"; @size: 10px; .header { width: @size; height: @size; } 更多参见CMSS。 2.2.3 JS 逻辑交互 JS 语法用于处理页面的逻辑部分，cml 文件标签中的export default导出的 VM 对象即采用 \bJS 语法。它负责业务逻辑、交互逻辑的处理与 \b 驱动视图更新，拥有完整的生命周期，watch，\bcomputed，数据双向绑定等优秀的特性，能够快速提高开发速度、降低维护成本。 \bdata 为数据。 props 为 \b 属性，父组件进行传递。 computed 为计算属性，\b 是动态的数据，可以对数据进行逻辑处理后返回结果。 watch 为侦听属性，监听数据的变化，触发相应操作。 methods 为方法 \b，处理业务逻辑与交互逻辑。 beforeCreate、created\b 等生命周期，掌握生命周期的触发时机，做相应操作。 简单举例： class Index { // data data = { message: 'Hello', } // 计算属性 computed = { reversedMessage: function () { return this.message.split('').reverse().join('') } } // 观察数据变化 watch: { message: function (newV, oldV) { } } // 各种生命周期 mounted: function(res) { // 模板或者html编译完成,且渲染到dom中完成,在整个vue的生命周期中只执行一次 } } export default new Index(); 更多参见逻辑层。 2.2.4 JSON 配置 JSON 配置部分用于描述 \b 应用、页面或组件的配置信息，对应于小程序的 json\b 配置文件。可以在其中为各端做不同的配置。举例如下，base对象为各端共用的配置对象,都 \b 引组件demo-com。wx、alipay、baidu分别对应生成微信小程序、支付宝小程序和百度小程序的各自配置。更多参见组件配置。 { \"base\": { \"usingComponents\": { \"demo-com\": \"/components/demo-com/demo-com\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" }, \"alipay\": { \"defaultTitle\": \"index\", \"pullRefresh\": false, \"allowsBounceVertical\": \"YES\", \"titleBarColor\": \"#ffffff\" }, \"baidu\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"index\", \"backgroundColor\": \"#ffffff\", \"backgroundTextStyle\": \"dark\", \"enablePullDownRefresh\": false, \"onReachBottomDistance\": 50 } } \b 通过以上对于 CML、CMSS、JS 交互逻辑以及 JSON 配置的学习，你已经具备了开发 chameleon 的页面和组件的能力, 可以参考卡片拖拽手势删除效果实现你想要的页面效果。但要想快速开发还需要掌握 chameleon 提供的组件和 API。 3 开发能力 3.1 组件 chameleon 提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成需要的功能。 就像 HTML 的 div, p 等标签一样，在 chameleon 里边，你只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要一个 switch 开关组件，你只需要这样写： class Switch { data = { switchValue: false }; methods = { switchChange(e) { this.switchValue = e.detail.value; } }; } export default new Switch(); { \"base\": {} } 使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如checked属性用于控制 switch 的 \b 开关状态: 组件的内部行为也会通过事件的形式让开发者可以感知，例如c-bind:change绑定 change 事件的处理函数为switchChange方法，在该方法中拿到改变的值，修改switchValue的值。 更多的组件的使用参见组件。 3.2 API chameleon 封装了丰富的基础 api 库chameleon-api供开发者使用，这些 api 屏蔽了各平台的底层接口差异，例如数据存储功能，我们只需要这样使用，而不需要关心各端数据存储 \b 接口的差异。 import cml from \"chameleon-api\"; cml.setStorage(\"name\", \"chameleon\").then(() => {}, function(err) {}); 例如弹出 toast 方法，只需要这样使用： import cml from \"chameleon-api\"; cml.showToast({ message: \"Hello chameleon!\", duration: 1000 }); 注意：接口均以 promise 形式进行返回，所以你可以结合异步流程控制如 async、await 进行操作。 更多 API 能力参见API 3.3 路由管理 \bchameleon 项目是应用级的项目，应用内允许多个页面的存在，下面学习项目中多个页面之间的路由管理与跨应用之间的跳转。 chameleon 项目内置了一套各端统一的路由管理方式，项目根目录 \b 下的src/router.config.json是路由的配置文件,内容如下: { \"mode\": \"history\", \"domain\": \"https://www.chameleon.com\", \"routes\":[ { \"url\": \"/cml/h5/index\", \"path\": \"/pages/index/index\", \"mock\": \"index.php\" } ] } mode 为 web 端路由模式，分为hash或history。 domain 为 web 端地址的域名。 routes 为路由配置 path 为路由对应的 cml 文件的路径,以 src 目录下开始的绝对路径，以/开头。 url 为 web 端的访问路径 mock 为该路由对应的mock 文件(仅模拟模板下发需要) 小程序端，构建时会将router.config.json的内容，插入到 app.json 的 pages 字段，实现小程序端的路由。 路由跳转分为应用内跳转和应用间跳转，chameleon-api都提供了相应的方法： navigateTo 打开新页面 redirectTo 页面 \b 重定向 navigateBack 页面返回 open 打开其他应用页面 例如应用内打开新页面： import cml from 'chameleon-api'; cml.navigateTo({ path: '/pages/page2/page2' }) 更多参见路由配置。 3.4 数据管理 当项目中的组件和页面越来越多，越来越复杂 \b 后，他们之间会出现 \b 共同管理数据状态的情况，这时我们建议使用 chameleon 提供的全局数据管理chameleon-store进行管理，它位于项目根目录下的src/store中 \b，目录结构如下： └── store ├── action-types.js # 定义 actions 的类型 ├── actions.js # 根级别的 actions ├── getter-types.js # 定义 getters 的类型 ├── getters.js # 根级别的 getters ├── index.js # 我们组装模块并导出 store 的地方 ├── mutation-types.js # 定义 mutations 的类型 ├── mutations.js # 根级别的 mutation ├── state.js # 组件初始状态数据 └── modules # 子模块 ├── ... 类似 Vuex 数据理念和语法规范，chameleon-store 主要有以下核心概念： state getters mutation action 子模块 通过 chameleon-store 创建的Store实例,方法如下： ChameleonStore.createStore(options: Object): Object 更多参见数据管理。 可以通过cml init project --demo todo\b \b 初始化todo 示例 demo，学习其中对于 \b 数据管理的使用。 3.5 自由定制 API 和组件 目前学习到现在，\b 我们都是利用一套代码实现多端的开发，但是当你遇到特殊的情况时，一套代码无法满足多端的需求时，chameleon 提供的多态协议，可以让你自由的扩展 API 和组件。有如下几种 \b 情况： 第一 定制化的组件，比如要使用 echarts 组件，这时就需要使用多态组件实现，例如手把手教你系列- 实现多态 echart。 第二 定制化的底层接口，可以参考手把手教你系列- 实现多态 API。 第三 业务需求导致的各端差异化实现，比如 web 端和小程序要有不用的逻辑处理，可以利用多态组件和多态接口实现。 注： 多态协议是 Chameleon 业务层代码和各端底层组件和接口的分界点，是跨端底层差异化的解决方案，普通用户开发基本上使用不到多态协议，因为 chameleon 已经 \b 使用多态协议封装了丰富的组件和接口。 4 工程化能力 当我们执行cml dev进行开发时，就已经使用了 chameleon 的工程化能力，如果还想使用热更新与自动刷新、调试窗口、mock 数据、代码的压缩、资源发布路径、打包资源分析、文件指纹等功能就需要进一步的学习。 mock 数据是本地开发必不可少的工作，chameleon 项目中在mock文件夹的文件中写 express 中间件的形式 mock 数据,更多参见 数据 mock，例如： module.exports = [ { method: [\"get\", \"post\"], path: \"/api/getMessage\", controller: function(req, res, next) { res.json({ total: 0, message: [ { name: \"Hello chameleon!\" } ] }); } } ]; chameleon 的其他工程化配置统一收敛在项目根目录 \b 下的chameleon.config.js文件，在该文件中可以使用全局对象 cml 的 api 去操作配置对象。例如： 配置当前项目支持的端 cml.config.merge({ platforms: [\"web\", \"wx\"] }); 配置是否进行文件压缩 cml.config.merge({ web: { dev: { minimize: true } } }); 配置资源发布路径，分离线上和线下的资源路径。 cml.config.merge({ web: { build: { publicPath: \"http://www.chameleon.com/static\" } } }); 更多配置参见工程配置 5 渐进式跨端 如果你既想一套代码运行多端，又不用大刀阔斧的重构项目，可以将多端重用组件用 Chameleon 开发，直接在原有项目里面调用。参见导入与导出。也有如下手把手实例进行参考 手把手教你系列 - 普通项目使用 chameleon 跨端组件 手把手教你系列 - webpack 集成 chameleon 6 端渲染能力接入 如果你需要跨 native 端渲染，则需要接入chameleon SDK，目前支持的渲染引擎是 weex，即将支持 react native，使用时二者选其一作为项目的 native 渲染引擎。chameleon SDK 包括对原生组件和本地 api 能力的扩展，对性能和稳定性的优化。使用方式可以参见Android Chameleon SDK 与IOS Chameleon SDK。 7 智能规范校验 chameleon 提供了多种规范校验，对这些规范的学习可以提高开发效率，保证代码质量。 接口校验语法 是使用多态协议扩展多态组件和多态接口时使用。可以通过配置进行开启或者关闭。 全局变量校验 是保证跨端代码全局变量正确性的检查方法，可以通过配置进行开启或者关闭。 代码规范校验 是对项目结构,文件规范，样式规范等进行校验，可以通过配置进行开启或者关闭。 更多示例 API 扩展 多态组件扩展 手势拖拽效果 工程化实例 普通项目使用跨端组件 webpack 集成 chameleon 只跨 web 和小程序的应用 微信小程序项目迁移 chameleon 指引 Android Chameleon SDK iOS Chameleon SDK "},"example/chameleon-api.html":{"url":"example/chameleon-api.html","title":"API 扩展","keywords":"","body":"手把手教你系列- 实现多态API 目前chameleon-api提供的是主要的跨端\b方法，如果你\b在里面没有找到需要的方法，还可以使用多态协议接口多态来进行扩展。今天我们就手把手来实现一个多态api接口。 举例-创建一个获取\b一些信息的跨端接口 我们可以在项目根目录下执行cml init component，选择Polymorphic function，输入文件名称，例如getSomeInfo，生成如下文件结构 ├── components │ ├── getSomeInfo │ │ ├── getSomeInfo.interface 文件内容如下： interface GetSomeInfoInterface { type Info = { env: String, extra: String, myInput: String, } getSomeInfo(input: String): Info; } class Method implements GetSomeInfoInterface { getSomeInfo(input) { // 一些获取的操作，得到信息 return { env: 'web', extra: '其他的信息', myInput: input } } } export default new Method(); class Method implements GetSomeInfoInterface { getSomeInfo(input) { // 一些获取的操作，得到信息 return { env: 'weex', extra: '其他的信息', myInput: input } } } export default new Method(); class Method implements GetSomeInfoInterface { getSomeInfo(input) { // 一些获取的操作，得到信息 return { env: 'wx', extra: '其他的信息', myInput: input } } } export default new Method(); class Method implements GetSomeInfoInterface { getSomeInfo(input) { // 一些获取的操作，得到信息 return { env: 'alipay', extra: '其他的信息', myInput: input } } } export default new Method(); class Method implements GetSomeInfoInterface { getSomeInfo(input) { // 一些获取的操作，得到信息 return { env: 'baidu', extra: '其他的信息', myInput: input } } } export default new Method(); 在interface文件中，\b\b在cml-type=\"interface\"部分规定\b入参和出参的具体类型。在cml-type=\"web|weex|wx|alipay|baidu\"等\b各自端中实现对应方法。\b即可实现一个可以跨端使用的多态接口。 使用多态接口 在你的项目中可以通过路径引用到该方法，进行使用。 import myApi from 'components/getSomeInfo/getSomeInfo.interface' const someInfo = myApi.getSomeInfo(); // 对获得的信息进行使用 值得一提的是，你可以在每个端自由引入在该端所需的库（你的项目库，npm包，jsbridge等），尽情丰富方法的实现，如在web端，当网页在客户端外的时候，你可以使用\b普通方法进行实现；如果该网页也会出现在客户端内，你可以使用jsbridge对于方法进行\b增强，获得更好的体验。 "},"example/poly.html":{"url":"example/poly.html","title":"多态组件扩展","keywords":"","body":"手把手教你系列- 实现多态 echart 背景介绍 正常情况下大部分功能可以用CML语法即可实现；常常会有特殊情况： 当我们想实现一个特别复杂功能时常常会用到成熟的第三方库 当产品经理需要各端差异化实现需求 类似“分享到朋友圈”功能在小程序、Web、Native天生有底层能力差异 我们这里举例实现一个柱状图图表一般会想到很强大的开源可视化库 echart。 本文讲讲如何在CML项目中优雅的使用echart库,最终效果图如下： 在CML项目中使用第三方库可以基于多态组件来开发。 多态协议的意义我就不做赘述了，直接说怎么使用。 项目初始化 新建一个项目 demo-poly cml init project 在项目中调用组件创建命令： cd demo-poly cml init component 切换选择Polymorphic component 输入echart 此时项目中看到./src/components/echart文件夹 ./src/components └── echart ├── echart.interface ├── echart.web.cml ├── echart.weex.cml └── echart.wx.cml 修改src/pages/index/index.cml文件里面的json配置，引用多态组件 \"base\": { \"usingComponents\": { \"echart\": \"/components/echart/echart\", \"demo-com\": \"/components/demo-com/demo-com\" } } 修改src/pages/index/index.cml文件里面的组件template模板，调用echart组件 修改style标签代码给标签添加宽高 .scroller-wrap { display: flex; flex-direction: column; align-items: center; } .echart{ display:flex; flex-direction:row; justify-content: center; height: 500px; width: 500px; } 在项目根目录下启动预览cml dev，有效果如下，展现2个组件分别是默认项目初始化放置的和我们刚刚添加的组件。 echart作为多态组件，在web、weex、微信小程序分别展示的是不同文案。 web端效果如下： 多态组件构成介绍 echart.interface：描述echart组件的输入和输出。 默认interface定义了一个组件，参数name的值是一个字符串，事件onshow的值是一个函数，函数的回调是一个Object结构为{value: 字符串}。 /* 定义一个inteface用于描述组件的属性和事件 1、 如何区分组件属性和事件？ 通过类型来区分，事件为函数类型，属性为非函数类型 2、 如何定义组件属性 给interface添加同名的属性即可，指定类型 3、 如何定义组件事件 以事件名称为key值给interface定义属性，该属性是一个函数类型，返回值为void， 定义函数的第一个参数为自定义事件传递的detail对象类型 */ //定义事件detail对象的参数 type EventDetail = { value: String } interface EchartInterface { name: String, onshow(eventDetail: EventDetail): void; } 其中的具体语法参见。 这里我们先不用改。 echart.web.cml、echart.weex.cml、echart.wx.cml：文件是灰度区，它是唯一可以调用下层端组件的CML文件，分别是web、weex、wx三个端的调用入口。建议这一块代码尽量薄，只是用来调用下层端代码，不要编写过于重的代码。 在灰度区的template模板中：可以调用下层组件，传入的属性也可以是各自下层端的语法，绑定的函数回调事件对象也是原始对象。也可以正常使用普通的cml模板语法 在灰度区的script逻辑代码中：可以调用下层端的全局变量和任意方法，以及下层段的生命周期。也可以正常使用普通cml逻辑代码。 在灰度区的style样式代码中：可以使用下层端css语法。也可以正常调用cmss语法。 实现微信echart 我们先修改./src/components/echart/echart.wx.cml实现微信的 echart 功能。 Google搜索到了echarts-for-weixin，我们看该项目的使用文档，我们把该项目下的ec-canvas文件夹拷贝到./src/components/echart文件夹下 ./src/components └── echart ├── ec-canvas │ ├── ec-canvas.js │ ├── ec-canvas.json │ ├── ec-canvas.wxml │ ├── ec-canvas.wxss │ ├── echarts.js │ └── wx-canvas.js ├── echart.interface ├── echart.web.cml ├── echart.weex.cml └── echart.wx.cml 修改./src/components/echart/echart.wx.cml文件里面的json配置，引用微信组件 \"base\": { \"usingComponents\": { \"ec-canvas\": \"./ec-canvas/ec-canvas\" } } 修改cml模板，调用组件 新建./src/components/echart/bar.js，作为统一存放echart图表的配置代码，代码如下： export default function getdata () { var option = { tooltip: {}, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36] }] }; return option; } 修改./src/components/echart/echart.wx.cml文件里面的JS代码，编写传递给组件的参数 import * as echarts from './ec-canvas/echarts'; let chart = null; import getBar from './bar' function initChart(canvas, width, height) { chart = echarts.init(canvas, null, { width: width, height: height }); canvas.setChart(chart); chart.setOption(getBar()); return chart; } class Echart implements EchartInterface { props = { name: { type: String, default: '默认值' } } data = { ec: { onInit: initChart } } computed = { } watch = { } methods = { } beforeCreate() { } created() { } beforeMount() { } mounted() { this.$cmlEmit('onshow',{ value: this.name }) } beforeDestroy() { } destroyed() { } } export default new Echart(); 修改./src/components/echart/echart.wx.cml文件里面的style代码，设置宽高 .mychart_dom_bar, .container{ height: 750cpx; width: 750cpx; } 此时能看到微信能展现图表了 实现web端echart web端使用vue框架，所以找到echart的vue版本 vue-echarts， 按他说明文档，直接在chameleon项目根目录demo-poly(我创建的project名)下安装组件 npm install echarts vue-echarts --save 打开src/components/echart/echart.web.cml 修改json标签配置，引用组件 { \"base\": { \"usingComponents\": { \"chart\": \"vue-echarts/components/ECharts\" } } } 修改cml模板，调用组件 修改script，设置传入chart组件的参数 import 'echarts/lib/chart/bar' import getBar from './bar' class Echart implements EchartInterface { props = { name: { type: String, default: '默认值' } } data = { bar: getBar(), initOptions: { renderer: 'canvas' } } computed = { } watch = { } methods = { } beforeCreate() { } created() { } beforeMount() { } mounted() { this.$cmlEmit('onshow',{ value: this.name }) } beforeDestroy() { } destroyed() { } } export default new Echart(); 此时web端也能看到图表效果了 实现native weex端echart weex不支持canvas接口，所以无法在weex环境下运行，我们可以用weex的web组件 需要注意点就是 weex的 web组件是用于展示一个页面的 所以，我们需要新建一个页面用于展示 echarts cml init page 然后输入页面名称 weex-echarts 然后在 ./src/pages/weex-echarts/weex-echarts.cml中写入图表这个页面的内容 class Index { data = { } } export default new Index(); .scroller-wrap { display: flex; flex-direction: column; align-items: center; } .echart{ display:flex; flex-direction:row; justify-content: center; height: 500px; width: 500px; } { \"base\": { \"usingComponents\": { \"echart\": \"/components/echart/echart\", } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } 在./src/components/echart/echart.weex.cml里面修改 class Echart implements EchartInterface { props = { name: { type: String, default: '默认值' } } data = { pagestart: '', pagefinish: '', title: '', error: '', canGoBack: false, canGoForward: false, //这是作者的本机IP,cml/h5/weex-echarts 这个页面只有echarts图表 h5url: 'http://172.22.137.224:8000/cml/h5/weex-echarts' } methods = { onPageStart: function(e) { this.pagestart = e.url; }, onPageFinish: function(e) { this.pagefinish = e.url; this.canGoBack = e.canGoBack; this.canGoForward = e.canGoForward; if (e.title) { this.title = e.title; } }, onError: function(e) { this.error = url; }, onReceivedTitle: function(e) { this.title = e.title; } } mounted() { this.$cmlEmit('onshow',{ value: this.name }) } } export default new Echart(); .mychart_dom_bar{ height: 500cpx; width: 750cpx; } .container{ height: 500cpx; width: 750cpx; } { \"base\": { \"usingComponents\": { } } } 此时weex端也能看到图表效果了 最后 同时如果有更多配置参数需要由调用方index.cml传入时，可以再echart.interface中定义更多输入输出的参数，保障各端一致。 基于多态协议开发各端上实现差异较大的一类组件，调用上抹平了差异，同时我们可以各自维护，修改其中一端代码时，不会影响其他端的代码，做到充分隔离。 后期我们可以把这 src/components/echart 单独发布成一个npm包，单拉出来维护 "},"example/gestures.html":{"url":"example/gestures.html","title":"手势拖拽效果","keywords":"","body":"手把手教你系列- 卡片拖拽手势删除效果 背景介绍 手势效果是终端开发的常见需求，这篇文章手把手教你如何快速实现一个手势功能。 最终效果 项目初始化 新建一个项目 demo-gesture cml init project 进入项目 cd demo-gesture 设计数据结构 我们要做一个列表，所以先设计一个数据结构如下： data = { list: [ { // 用作样式名称 className: 'inner-first', // 用作元素位置偏移 transform: { y: 0, x: 0 } , } ] } 写进/src/pages/index/index.cml文件里面逻辑层JS代码里面 class Index { data = { list: [ { className: 'inner-first', transform: { y: 0, x: 0 } }, { className: 'inner-second', transform: { y: 0, x: 0 } }, { className: 'inner-third', transform: { y: 0, x: 0 } }, { className: 'inner-fouth', transform: { y: 0, x: 0 } } ], } methods = { } } export default new Index(); 书写CML使用数据 我们查看CML文档使用列表渲染， 写进/src/pages/index/index.cml文件里面CML代码 {{idx}} 删 书写CMSS 查看CMSS文档，CMSS针对多端情况只能使用 flex 给页面布局， .wrapper{ flex-direction: col; justify-content: space-around; height: 1200cpx; } .inner-first{ background: red; } .inner-second{ background: yellow; } .inner-third{ background: blue; } .inner-fouth{ background: green; } .box{ height: 200cpx; } .txt{ text-align: center; line-height: 50cpx; height: 50cpx; } .remove-btn{ height: 50cpx; width: 50cpx; border: 1px solid hotpink; font-size: 10cpx; border-radius: 50cpx; transform: translate(780cpx, 0) } .rm{ text-align: center; line-height: 50cpx; color: hotpink; } 目前三端效果展现如下 添加手势 我们查看事件绑定文档 给box元素添加事件绑定： c-bind:touchstart=\"eventhandler\" c-bind:touchmove=\"eventhandler\" c-bind:touchend=\"eventhandler\" 添加事件回调函数 methods = { eventHandler(event){ // 获取当前手指位置 let myPreX = event.changedTouches[0].pageX; // 获取当前手指所触摸的Item元素 let index = event.currentTarget.dataset.index; // 获取当前手指所触摸的Item元素的偏移值 let transform = this.list[index].transform; if(index >= this.list.length) { return; } console.log(index); // 手指触摸开始时将上一个X方向偏移设为null if(event.type == 'touchstart'){ preX = null; }else if( event.type == 'touchmove'){ if(preX !== null){ let x = parseInt(transform.x) + myPreX - preX ; //x 100 当手指往左滑动超过100时不允许滑动滑块 if(Math.abs(x) 添加删除按钮事件回调函数 给remove-btn元素添加事件绑定： c-bind:click=\"onRemove\" methods = { onRemove(e){ let index = e.currentTarget.dataset.index; this.list.splice(index, 1); } } /src/pages/index/index.cml 最终全部代码如下： {{idx}} 删 let preX = null; class Index { data = { list: [ { className: 'inner-first', transform: { y: 0, x: 0 } }, { className: 'inner-second', transform: { y: 0, x: 0 } }, { className: 'inner-third', transform: { y: 0, x: 0 } }, { className: 'inner-fouth', transform: { y: 0, x: 0 } } ], } methods = { eventHandler(event){ // 获取当前手指位置 let myPreX = event.changedTouches[0].pageX; // 获取当前手指所触摸的Item元素 let index = event.currentTarget.dataset.index; // 获取当前手指所触摸的Item元素的偏移值 if(index >= this.list.length) { return; } console.log(index); let transform = this.list[index].transform; // 手指触摸开始时将上一个X方向偏移设为null if(event.type == 'touchstart'){ preX = null; }else if( event.type == 'touchmove'){ if(preX !== null){ let x = parseInt(transform.x) + myPreX - preX ; //x 100 当手指往左滑动超过100时不允许滑动滑块 if(Math.abs(x) .wrapper{ flex-direction: col; justify-content: space-around; height: 1200cpx; } .inner-first{ background: red; } .inner-second{ background: yellow; } .inner-third{ background: blue; } .inner-fouth{ background: green; } .box{ height: 200cpx; } .txt{ text-align: center; line-height: 50cpx; height: 50cpx; } .remove-btn{ height: 50cpx; width: 50cpx; border: 1px solid hotpink; font-size: 10cpx; border-radius: 50cpx; transform: translate(780cpx, 0) } .rm{ text-align: center; line-height: 50cpx; color: hotpink; } { } 最终不到150行代码实现三端拖拽效果： "},"example/project.html":{"url":"example/project.html","title":"工程化实例","keywords":"","body":"手把手教你系列 - 工程化配置 前端工程化是前端领域在不断发展摸索过程中，总结出的使用软件工程对项目的开发、上线和维护等阶段中进行管理的集成解决方案。 chameleon根据自身框架特征，设计并完成了一套具有高度自由度、可定制化的自有工程化解决方案，可在以下几个方面针对不同场景进行配置支持。 数据mock 打包构建 文件指纹 代码压缩 项目初始化 按照快速上手新建一个以test_project为名称的项目。 项目的source目录如下： src ├── app │ └── app.cml ├── assets │ └── images │ └── chameleon.png ├── components │ ├── com2 │ │ └── com2.cml │ └── demo-com │ └── demo-com.cml ├── main.js ├── pages │ ├── a │ │ └── a.cml │ └── index │ └── index.cml ├── router.config.json └── store ├── actions.js ├── getters.js ├── index.js ├── mutations.js └── state.js 数据mock 数据mock是前后端分离的基本保障，在快速上手中已经有了比较详细介绍，这里就不在赘述。 打包构建 执行如下命令 $ cml build 打包出来的dist目录结构如下 dist ├── config.json // 各端映射关系表 ├── web // web端部署包 ├── weex // weex端部署包 └── wx // wx端部署包 进入weex包, 并查看weex包内容 $ tree dist/weex dist/weex/ └── test_project_c6bdf9074a821f01e70f.js cml build默认在打包的时候添加文件指纹，因为大多数场景下，静态资源以强缓存的方式会存放到cdn上，使用文件指纹可以避免代码修改后，客户端缓存导致未更新的问题。 从上边的结果上看打包出来的weex bundle文件名已添加上了文件指纹。 不过有些场景下希望不添加文件指纹，比如静态资源为使用协商式缓存的情况。 文件指纹 让我们一起把文件指纹去掉，进入刚才创建项目的根目录，找到并打开根目录下的chameleon.config.js，找到如下代码片段。 weex: { dev: { }, build: { publicPath: `${publicPath}/weex`, apiPrefix }, custom: { publicPath: `${publicPath}/wx`, apiPrefix } } 在weex.build下 增加hash: false的配置 weex: { dev: { }, build: { publicPath: `${publicPath}/weex`, apiPrefix, hash: false }, custom: { publicPath: `${publicPath}/wx`, apiPrefix } } 再次执行 $ cml build $ tree dist/weex/ dist/weex/ └── test_project.js 只需简单的配置，文件指纹即已去除！ 代码压缩 代码压缩作为前端工程师的性能优化利器，chameleon已默认配置了build的阶段的代码压缩。 当然，也有某些场景下需要构建出来的产物不进行代码压缩，比如集成测试的时候，使用压缩前的代码能够最便捷的发现问题，下面操作如何取消代码压缩。 仍旧打开根目录下的chameleon.config.js文件，增加minimize: false参数即达目的。 weex: { dev: { }, build: { publicPath: `${publicPath}/weex`, apiPrefix, hash: false, minimize: false }, custom: { publicPath: `${publicPath}/wx`, apiPrefix } } 再次执行 $ cml build 这时构建出来的代码即为压缩前代码。 "},"example/webpack_output.html":{"url":"example/webpack_output.html","title":"普通项目使用跨端组件","keywords":"","body":"手把手教你系列 - 普通项目使用chameleon跨端dialog组件 背景介绍 这里考虑如下场景，很多基础组件是多端共用的，单独开发则需要维护多套代码，而使用chameleon维护一套跨端ui库，通过组件导出给某一端进行使用，这样提高的开发效率可想而知。本文将一步一步介绍如何导出某一端组件及应用。 项目初始化 关于chameleon-cli的安装及环境配置请参照快速上手，首先使用项目初始化命令cml init project完成项目初始化，然后cd projectName进入项目目录使用cml init component初始化diaolog组件，这里选择普通组件。最终dialog组件效果如下图： web端组件导出及应用 导出 首先是配置chameleon.config.js，增加如下配置: 更多配置请参照组件导出应用 完成配置后进入项目目录，使用cml web export命令执行web端组件导出，导出目录如下： 应用 \b\b组件导出后我们直接用vue-cli创建一个webpack项目，这里使用的是vue-cli@2.9.6。\b初始化\b项目如下图： 现在开始\b增加导出组件的配置。 第一步：修改\b.babelrc文件，删除\bmodules: false，前后对比如下图： 第二步：将common文件夹拷贝至webpack项目资源\b\b目录，并\b在webpack项目的入口文件中引入\bweb_global.js\b，代码如下图： \b现在将前面导出的dialog组件拷贝至webpack项目的组件目录\b下，拷贝后webpack项目目录结构如下图： 然后\bapp.vue文件中直接使用c-dialog组件，代码如下： import CDialog from './components/c-dialog/c-dialog.js' export default { name: 'App', components: { CDialog } } @import \"./components/c-dialog/c-dialog.css\"; 最终\b效果如下图： weex端组件导出及应用 导出 首先是配置chameleon.config.js，为weex端增加如下配置： 更多配置信息请查看组件导出应用，配置好之后在该项目目录下执行cml weex export命令执行weex端组件导出，导出目录如下： 应用 首先通过weex官网提供的weex-toolkit初始化weex项目，初始化项目如下图： 将前面导出的dialog组件拷贝值weex项目的组件目录下，拷贝后目录结构如下图： 然后在index.vue组件中引入并使用c-dialog组件，代码如下： The environment is ready! import HelloWorld from '@/components/HelloWorld' import CDialog from '@/components/c-dialog/c-dialog.js'; export default { name: 'App', components: { HelloWorld, CDialog }, data () { return { logo: 'https://gw.alicdn.com/tfs/TB1yopEdgoQMeJjy1XaXXcSsFXa-640-302.png' } } } .wrapper { justify-content: center; align-items: center; } .logo { width: 424px; height: 200px; } .greeting { text-align: center; margin-top: 70px; font-size: 50px; color: #41B883; } .message { margin: 30px; font-size: 32px; color: #727272; } 最终效果如下图： 小程序端（wx、alipay、baidu）组件导出及应用 导出 首先在chameleon.config.js增加小程序端导出配置，这里以微信小程序举例： { wx: { export: { entry: ['src/components/c-dialog'], publicPath: 'https://static/resource.com' //静态资源线上地址, hash: false //方便使用，导出组件名不加hash } } } 更多配置信息请查看组件导出应用，配置好之后在该项目目录下执行cml wx export命令执行wx端组件导出，导出目录如下： 支付宝小程序组件导出命令为：cml alipay export, 百度小程序组件导出命令为：cml baidu export 应用 首先通过微信小程序开发者工具初始化项目，如下图： 将导出的组件文件目录拷贝至微信小程序项目根目录下，拷贝后目录结构如下图： 这里我们直接在微信默认创建的首页中使用，代码如下： // index.json { \"usingComponents\": { \"c-dialog\": \"/wx/components/c-dialog/c-dialog\" } } // index.wxml 获取头像昵称 {{userInfo.nickName}} {{motto}} 最终效果如下图： 注意 在使用组件导出时，组件所用静态资源必须为线上资源。 "},"example/webpack_plugin.html":{"url":"example/webpack_plugin.html","title":"webpack 集成 chameleon","keywords":"","body":"手把手教你系列 - webpack集成chameleon 注：内部webpack插件版本基于webpack@3.12.0开发选择，暂不兼容webpack4。 背景介绍 在webpack项目中使用chamelon组件有两种方式，一种是将组件导出到项目中进行使用，而另一种是直接在webpack项目中集成chameleon，为其增加chameleon的编译能力，集成后可直接使用chamelon的语法进行开发。本文将一步一步介绍如何集成chameleon及使用已有chameleon组件和开发chameleon组件。 项目初始化 首先需要初始化一个webpack项目，这里直接使用vue-cli，初始化项目如下图： 集成chameleon 第一步：在webpack项目下执行npm i easy-chameleon chameleon-ui-builtin命令，安装集成依赖。 第二步：执行node node_modules/\\easy-chameleon/bin/index.js命令，安装chameleon依赖。 第三步：修改.babelrc文件，为preset添加flow，在chameleon中使用了flow语法，下图是修改前后对比： 第四步：在入口文件中引入easy-chameleon/entry/web_global.js文件，代码如下： import 'easy-chameleon/entry/web_global.js' import Vue from 'vue' import App from './App' Vue.config.productionTip = false new Vue({ el: '#app', components: { App }, template: '' }) 第五步：修改webpack配置文件，增加chameleon编译能力。 修改webpack.base.conf.js文件，代码如下： const { getConfig } = require('easy-chameleon'); const merge = require('webpack-merge') module.exports = merge(baseConfig, getConfig({ cmlType: 'web', media: 'dev', hot: true, disableExtract: false, context: path.join(__dirname,'../'), cmss: { rem: false, scale: 0.5 } })) 这里只贴出了该文件中所增加的代码，其中baseConfig为webpack原有配置。至此，webpack项目已成功集成chameleon。 使用已有chameleon组件 我们已经使用chameleon开发出一套ui组件库，这里我们直接在webpack中使用。 首先，执行npm install cml-ui命令安装chameleon-ui组件库，安装成功后我们直接在app.vue中使用，代码如下： import HelloWorld from './components/HelloWorld' import CDialog from 'cml-ui/components/c-dialog/c-dialog' export default { name: 'App', components: { HelloWorld, CDialog } } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 最终效果如下图： 开发chameleon组件 在组件目录下新建.cml文件，chameleon组件模版如下： class Chameleon { data = { } computed = { } watch = { } methods = { } beforeCreate() { } created() { } beforeMount() { } mounted() { } beforeDestroy() { } destroyed() { } } export default new Chameleon(); { \"base\": { \"usingComponents\": { } } } 我在项目中新建了一个HelloChamelon.cml组件，开发完成后在App.vue中引入使用，代码如下: import HelloChameleon from './components/HelloChameleon' export default { name: 'App', components: { HelloChameleon } } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 最终效果如下图： \b注意 在chameleon\b组件开发中\b样式单位为cpx，编译时默认会转为rem，\b具体单位转换规则参考项目配置中的\bcmss处理。 "},"example/android_example.html":{"url":"example/android_example.html","title":"Android Chameleon SDK","keywords":"","body":"手把手教你系列- 变色龙SDK使用范例 以一个小demo工程，讲述变色龙SDK的使用方式，引领轻松入门。Demo 工程在根目录 app 目录下，用 Android Studio 导入并 run 起来后，再对照以下说明文档看会好理解。 根目录 assets 目录下的 cml-demo-say.zip 是个简单的示例工程 用来演示native 和 weex容器或web容器的双向通信。app 目录下demo工程加载的 weex bundle 和 h5 页就是这个工程实现的。 1. compile 依赖添加 1.1 项目根目录 build.gradle 里添加 maven 仓库地址 buildscript { repositories { jcenter() maven { url 'https://maven.google.com/' } } ... } allprojects { repositories { maven { url 'https://maven.google.com/' } jcenter() mavenCentral() ... } } 1.2 在 app 模块的 build.gradle 里添加依赖 1.2.1 首先添加如下依赖 dependencies { ... compile \"com.android.support:support-v4:$SUPPORT_VER\" compile \"com.android.support:appcompat-v7:$SUPPORT_VER\" compile \"com.android.support:recyclerview-v7:$SUPPORT_VER\" compile \"com.didiglobal.chameleon:cmlsdk:$VERSION\" compile \"com.didiglobal.chameleon:cmlweb:$VERSION\" } 1.2.2 添加渲染引擎依赖 cml native sdk 采用 weex 作为渲染引擎，当前依赖的weex版本是 weex -> com.taobao.android:weex_sdk:0.20.0.2 dependencies { ... compile \"com.didiglobal.chameleon:cmlweex:$VERSION\" } com.android.tools.build:gradle 3.0 以后的版本用 implementation 替换 compile，完整的依赖列表可参考示例工程。 2. 权限添加及 android 6.0 以上系统授权 Chameleon SDK 已经添加了如下权限，android 6.0 以上系统版本需要在调起相关页面后手动授权。 3. 混淆 参考示例工程 4. 初始化入口 实现自己的 Application 类，在应用启动的时候进行初始化调用。 4.1 Application demo public class MyApplication extends Application implements CmlConfig { @Override public void onCreate() { super.onCreate(); CmlEngine.getInstance().init(this, this); } @Override public void configAdapter() { // 开发阶段可以禁用js bundle缓存 CmlEnvironment.CML_ALLOW_BUNDLE_CACHE = false; // 开发阶段手动降级测试 // CmlEnvironment.CML_DEGRADE = false; // 注册降级Adapter CmlEnvironment.setDegradeAdapter(new CmlDegradeDefault()); // CmlEnvironment.setToastAdapter(xxx); // CmlEnvironment.setLoggerAdapter(xxx); // CmlEnvironment.setDialogAdapter(xxx); // CmlEnvironment.setNavigatorAdapter(xxx); // CmlEnvironment.setStatisticsAdapter(xxx); // CmlEnvironment.setImageLoaderAdapter(xxx); } @Override public void registerModule() { CmlEngine.getInstance().registerModule(ModuleDemo.class); } } 4.2 将 Application 添加到 AndroidManifest.xml 4.3 适配器的实现 适配器是暴露给SDK使用者的一组接口，用于提供扩展SDK的能力，其中一部分接口提供了默认实现，未提供默认实现的需要使用者自己实现并注册到SDK中。 以下适配器提供了默认实现 http / json / log / modal / storage / thread / websocket / imagloader 以下适配器未提供默认实现 navigator / degrade / statistics 以降级适配器举例，只需要两个步骤： 新建类 CmlDegradeDefault，实现接口 ICmlDegradeAdapter 在 MyApplication 的 configAdapter 方法里注册适配器。 4.4 module 的实现 module 的基本概念可参看这里, SDK层实现在如下位置： module 的实现主要分两个步骤，一个是 native 侧的代码实现，一个是 js 侧的代码实现。同时，native 和 js 的通信是双向的，及native 可以主动调用 js 侧的方法，js 侧也可以主动调用 native 侧的方法。 4.4.1 native 侧的实现 以下内容请在 Chameleon SDK demo 运行起来的前提下阅读，方便理解即将描述的内容。 实现一个module扩展需要如下几个步骤： 根据需求和前端RD确定module/method/args参数 native RD根据约定实现module扩展，前端RD根据约定实现js 并打包成jsbundle native RD可以将jsbundle放到assets目录下加载调试，也可以远程加载调试 demo实现了双向通信，js 调用 native接口约定如下 (module的概念): module名是 moduleDemo method名是 sayHello args名是 {\"content\":\"测试\"} 实现的效果是点击jsbundle里的按钮，会弹 测试 toast native 调用 js接口约定如下: module名是 moduleDemo method名是 NaTellJS args名是 {\"content\":\"测试\"} 实现的效果是点击 native 侧的按钮，会动态改变 jsbundle里的文字显示。 module 的实现需要先了解3个注解 @CmlModule 标注这个类是扩展模块 @CmlMethod 标注可供JS侧调用的方法 @CmlParam 标注调用的参数 以下是根据约定实现的 module 扩展示例 @CmlModule(alias = \"moduleDemo\") public class ModuleDemo { @CmlMethod(alias = \"sayHello\") public void sayHello(ICmlActivityInstance instance, @CmlParam(name = \"content\") String content) { Toast.makeText(instance.getContext(), content, Toast.LENGTH_SHORT); } } 将 module 注册到SDK public class MyApplication extends Application implements CmlConfig { @Override public void onCreate() { super.onCreate(); CmlEngine.getInstance().init(this, this); CmlEngine.getInstance().registerModule(ModuleDemo.class); // 在这里注册 } ... } 从前端RD拿到 JSBundle， 进行渲染，重点关注demo工程里CmlViewActivity private static final String URL_JS_BUNDLE_OK = \"https://www.example.com/degradle.html?cml_addr=http://172.22.138.92:8000/weex/cml-demo-say.js\"; @Override protected void onCreate(Bundle savedInstanceState) { .... // cmlView.render(URL_JS_BUNDLE_OK, null); // 加载远程jsbundle cmlView.render(\"file://local/cml-demo-say.js\", null); // 加载assets目录里的jsbundle ... } js侧的实现以及 jsbundle 打包参看接下来的 4.4.2 小结。 4.4.2 js 侧的实现 同样以上面要实现的module和方法为例，我们来看一下js侧的实现。 参考根目录 assets 目录下的 cml-demo-say.zip 1.初始化前端项目（也可以使用已有的项目） cml init project 请输入项目名称 cml-demo-say 2.打开项目下 src/pages/index/index.cml文件，粘贴以下代码。以下代码主要是展示了js和native双向的通信的方法实现。先粘贴，然后我们在下面介绍通信封装的原理。 1，JS调用Native callback返回内容: {{callbackRes}} 2，Native调用JS 的NaTellJS方法已经注册监听，点击Native的改变文字按钮,下发状态文字将改变 状态：{{status}} import cml from \"chameleon-api\"; import cmlBridge from \"chameleon-bridge\"; class Index { data = { title: \"chameleon\", callbackRes: '', status: '等待Native调用', winHeight: 0 } methods = { // 此处的方法实现你可以封装到其他目录，作为统一扩展的api sayHello() { cmlBridge.callNative( 'moduleDemo', // 模块名 'sayHello', // 方法名 { content: 'Hello Chameleon!' }, // 参数 res => { this.callbackRes = res; } // 回调方法 ); } } mounted() { // 主动监听客户端调用js cmlBridge.listenNative( 'moduleDemo', // 模块名 'NaTellJS', // 方法名 res => { this.status = res.content; } ); cml.getSystemInfo().then((info) => { this.winHeight = Number(info.viewportHeight) }); } } export default new Index(); .scroller-wrap { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } 3.你可以运行cml weex dev或者cml weex build命令，将jsbundle文件的在线地址或本地文件给到Native同学，按照上面Native部分提到的集成方式（本地或远程地址）进行联调。点击第一项的按钮你可以看到，客户端弹出了\"Hello Chameleon!\"的弹框。同时在callback返回内容:后返回了内容。点击Native端的“改变文字”按钮，在页面上的“状态：”后显示了客户端发来的“测试”字样。 4.接下来我们看一下原理： 我们通过chameleon-bridge提供的callNative和listenNative来与端通信，他们的参数及意义如下： callNative(module:String, method:String, args:Object, callback:Function) JS主动调用Native方法 listenNative(module:String, method:String, callback:Function) 监听Native调用js JS主动调用Native方法 首先看methods里我们通过chameleon-bridge提供的callNative方法实现了sayHello方法，让js与native主动通信。 sayHello() { cmlBridge.callNative( 'moduleDemo', // 模块名 'sayHello', // 方法名 { content: 'Hello Chameleon!' }, // 参数 res => { this.callbackRes = res; } // 回调方法 ); } 这样就调用到了native的模块名为moduleDemo的模块的sayHello方法，同时native会回调我们。当然你还可以封装到其他目录，作为统一扩展的api来存放并引入到项目文件中使用。 监听Native调用js mounted里我们通过chameleon-bridge提供的listenNative方法在页面初始化时监听了客户端要调用我们的模块名为moduleDemo的NaTellJS方法。注意，这个模块在前端其实可以理解为一个和Native同学约定的方法命名集合。调用前端chameleon-bridge库的listenNative方法会进行监听的注册，便可以被客户端调用到。 cmlBridge.listenNative( 'moduleDemo', // 模块名 'NaTellJS', // 方法名 res => { this.status = res.content; } ); 同样你可以将此方法封装到其他api集合位置，进行引入使用，如： export function onNaTellJS(callback) { cmlBridge.listenNative( 'moduleDemo', // 模块名 'NaTellJS', // 方法名 callback ); } 如此一来，你便可以封装自己的扩展api了。 4.5 js bundle 缓存的禁用 开发截断为了方便实时预览效果，可以关闭 js bundle 的缓存。 @Override public void configAdapter() { // 开发阶段可以禁用js bundle缓存 CmlEnvironment.CML_ALLOW_BUNDLE_CACHE = false; ... } 5. 页面调起 5.1 整个页面使用 Chameleon 容器实现 CmlEngine.getInstance().launchPage(activity, url, options); // 即将支持 CmlEngine.getInstance().launchPage(activity, url, options, requestCode, launchCallback); 5.2 使用CmlView 参考根目录 app 目录下demo CmlView 用在和原生 Native View 混合布局的场景， private CmlView cmlView; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_test_cml_view); FrameLayout flRoot = findViewById(R.id.fl_root); cmlView = new CmlView(this); flRoot.addView(cmlView, new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); cmlView.onCreate(); cmlView.render(MainActivity.TEST_URL, null); } @Override protected void onResume() { super.onResume(); if (cmlView != null) { cmlView.onResume(); } } @Override protected void onPause() { super.onPause(); if (cmlView != null) { cmlView.onPause(); } } @Override protected void onDestroy() { super.onDestroy(); if (cmlView != null) { cmlView.onDestroy(); } } 5.3 打开普通URL 如果打开的是普通的URL，则会自动使用 CmlWebEngine 调起 Web Container，渲染 H5 页面 // 演示打开一般的URL private static final String URL_NORMAL = \"https://www.didiglobal.com\"; ... @Override public void onClick(View view) { switch (view.getId()) { case R.id.txt_open_url: CmlEngine.getInstance().launchPage(this, URL_NORMAL, null); break; ... } } 5.4 打开 JS Bundle 如果打开的是JS Bundle URL，则会自动使用 native 渲染引擎调起 native Container，渲染 JS Bundle // 这是一个可以正常打开的 JS_BUNDLE private static final String URL_JS_BUNDLE_OK = \"https://beatles-chameleon.github.io/chameleon-ui-builtin/dist/web/chameleon-ui-builtin.html?cml_addr=https%3A%2F%2Fbeatles-chameleon.github.io%2Fchameleon-ui-builtin%2Fdist%2Fweex%2Fchameleon-ui-builtin.js#/\"; ... @Override public void onClick(View view) { switch (view.getId()) { ... case R.id.txt_open_js_bundle: CmlEngine.getInstance().launchPage(this, URL_JS_BUNDLE_OK, null); break; ... } } 5.5 预加载 如果打开的是一个已经预加载过的 JS Bundle URL，则会忽略下载过程，直接使用 native 渲染引擎渲染界面 // 这是一个测试预加载的 JS_BUNDLE private static final String URL_JS_BUNDLE_PRELOAD = \"https://beatles-chameleon.github.io/chameleon-ui-builtin/dist/web/chameleon-ui-builtin.html?cml_addr=https%3A%2F%2Fbeatles-chameleon.github.io%2Fchameleon-ui-builtin%2Fdist%2Fweex%2Fchameleon-ui-builtin.js#/\"; ... @Override public void onClick(View view) { switch (view.getId()) { ... case R.id.txt_preload: CmlEngine.getInstance().launchPage(this, URL_JS_BUNDLE_PRELOAD, null); break; ... } } 5.6 自动降级 如果打开的是一个错误的JS Bundle URL，则会自动降级，使用 CmlWebEngine 调起 Web Container，渲染前面 H5 地址页面，具体可以查看 工程化 -> Chameleon URL 一节关于，Chameleon URL 的定义 Native渲染能力接入 -> 自动降级 一节，关于自动降级的详细说明 // 这是一个错误的 JS_BUNDLE private static final String URL_JS_BUNDLE_ERR = \"https://www.didiglobal.com?cml_addr=xxx.js\"; ... @Override public void onClick(View view) { switch (view.getId()) { ... case R.id.txt_degrade: CmlEngine.getInstance().launchPage(this, URL_JS_BUNDLE_ERR, null); break; } } 6. 预加载 如果某些 js bundle 不需要实时下载下来渲染，可以先配置到预加载列表里提前下载下来，提升用户交互体验。 6.1 预加载列表的配置 组装 CmlBundle 列表，并通过 CmlEngine 接口设置到SDK里，具体可以参考 demo。 private List getPreloadList() { CmlJsBundleEnvironment.DEBUG = true; List cmlModels = new ArrayList<>(); CmlBundle model = new CmlBundle(); model.bundle = Util.parseCmlUrl(URL_JS_BUNDLE_PRELOAD); model.priority = 2; cmlModels.add(model); return cmlModels; } ... CmlEngine.getInstance().initPreloadList(getPreloadList()); 6.2 开始预加载列表 根据使用方的业务，在适当位置执行预加载 CmlEngine.getInstance().performPreload(); "},"example/ios_example.html":{"url":"example/ios_example.html","title":"iOS Chameleon SDK","keywords":"","body":"手把手教你系列- 变色龙SDK使用范例 以一个一个小demo，讲述变色龙SDK的使用方式，引领轻松入门。 Demo 工程在根目录 “Example” 目录下，打开“Chameleon.xcworkspace”文件即可打开工程。 工程集成 在你的Podfile文件中，添加如下代码（以demo工程为例）： platform :ios, '9.0' target 'Chameleon_Example' do #Chameleon pod 'Chameleon', :path => '../Chamleon/' #写入weex依赖。 pod 'WeexSDK', '~> 0.19.0.2' #写入react_native依赖。 pod 'React', :path => '../Chamleon/react_native/node_modules/react-native', :subspecs => [ 'Core', 'CxxBridge', # 如果RN版本 >= 0.45则加入此行 'DevSupport', # 如果RN版本 >= 0.43，则需要加入此行才能开启开发者菜单 'RCTText', 'RCTNetwork', 'RCTWebSocket', # 这个模块是用于调试功能的 ] pod 'yoga', :path => '../Chamleon/react_native/node_modules/react-native/ReactCommon/yoga' pod 'DoubleConversion', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/DoubleConversion.podspec' pod 'glog', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/GLog.podspec' pod 'Folly', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/Folly.podspec' end 将podfile保存，并运行pod install。 工程中使用 初始化变色龙环境 在appdelegate.m中的appDidFinishLaunchingWithOptions方法中添加: //初始化SDK实例 [CMLSDKEngine initSDKEnvironment]; //设置渲染引擎为weex [CMLEnvironmentManage chameleon].serviceType = CMLServiceTypeWeex; 如果需要使用预加载的功能，则： //设置预加载的链接地址 [CMLEnvironmentManage chameleon].weexService.config.prefetchContents = @[@\"http%3A%2F%2F172.22.139.32%3A8000%2Fweex%2Fchameleon-bridge.js%3Ft%3D1546502643623\"]; //启动预加载 [[CMLEnvironmentManage chameleon].weexService setupPrefetch]; 在 [CMLEnvironmentManage chameleon].weexService.config 实例中可以看到更多的设置选项。 使用 实例化一个Weex渲染页面 以demo为例： CMLWeexRenderPage *weexDemo = [[CMLWeexRenderPage alloc] initWithLoadUrl:encodeUrl]; weexDemo.service = [CMLEnvironmentManage chameleon].weexService; [self.navigationController pushViewController:weexDemo animated:YES]; 实例化一个ReactNative渲染页面 ReactNative的渲染容器待完善 添加一个自己的module 我们以CMLStorageModule为例： 在头文件中 #import #import \"CMLModuleProtocol.h\" //实现“CMLModuleProtocol.h” @interface CMLStorageModule : NSObject @property (nonatomic, weak) CMLInstance *cmlInstance; @end 在实现文件中 #import \"CMLStorageModule.h\" #import \"CMLUtility.h\" #import \"CMLConstants.h\" @implementation CMLStorageModule @synthesize cmlInstance; //使用 CML_EXPORT_METHOD 导出方法以供JS所调用。 CML_EXPORT_METHOD(@selector(setStorage:callBack:)) - (void)setStorage:(NSDictionary *)parms callBack:(CMLMoudleCallBack)callback{ NSString *key = parms[@\"key\"]; NSString *value = parms[@\"value\"]; if (!key || key.length "},"example/chameleon-product-diff.html":{"url":"example/chameleon-product-diff.html","title":"为什么用多态协议","keywords":"","body":"普通跨端 VS Chameleon 正常业务代码重复实现 // 普通业务代码web if (业务逻辑判断A) { 业务操作(); } else if (业务逻辑判断B) { 业务操作(); } // 普通业务代码小程序 if (业务逻辑判断A) { 业务操作(); } else if (业务逻辑判断B) { 业务操作(); } // 普通业务代码Objective-c if (业务逻辑判断A) { [XXX业务操作]; } else if(业务逻辑判断B){ [XXX业务操作]; } 一套代码运行多端合并 哇好牛逼，一套代码多端实现，开发效率显著提升 // 普通跨端框架，实现一套代码运行多端 if (业务逻辑判断A) { 业务操作(); } else if(业务逻辑判断B) { 业务操作(); } 理想很美好，现实很骨感 遇到了产品差异化实现：“我希望web端下载APP，小程序不用下载” // 普通跨端框架，实现一套代码运行多端 if (业务逻辑判断A) { 业务操作(); if (ENV.小程序) { 业务差异操作(); } else if (ENV.web) { 业务差异操作(); } else if (ENV.端) { 业务差异操作(); } } else if (业务逻辑判断B) { 业务操作(); if(小程序) { 业务差异操作(); } else if (web) { 业务差异操作(); } else if (端) { 业务差异操作(); } } 这就尴尬了，如果你觉得以上不复杂，假设有4、5个端呢，业务逻辑掺杂跨端逻辑，产品逻辑别打断，可读性差，需求变更，牵一发动全身，每个端都要测试，跨端代码效率变得适得其反。 Chameleon Chameleon 将特有代码充分隔离，保证正常产品逻辑整体具有连续性，保障各端产品差异化模块的独立性、一致性、可读。 差异化产品修改不会影响其他端，各端底层接口调用不会影响其他端。 // Chameleon跨端设计遇到产品差异化的代码 if (业务逻辑判断A) { 业务操作(); interface_foo(); // 产品多态接口 } else if (业务逻辑判断B) { 业务操作(); interface_foo2(); // 产品多态接口 } "},"framework/edit-plugin.html":{"url":"framework/edit-plugin.html","title":"编辑器插件","keywords":"","body":"编辑器插件 \bchameleon项目编辑器中语法高亮，暂时使用.vue的插件，后续会推出更强大的插件，各编辑器配置插件教程如下： Visual Studio Code 在vscode 左侧Extensions搜索框中输入cml，点击 install 安装cml插件。 Atom 使用快捷键打开编辑器设置页面： command + ,(逗号) 选择左侧的Install Tab，然后在搜索框输入language-cml, 在搜索结果中找到cml语言支持并安装 Webstorm 使用快捷键打开编辑器设置页面： command + ,(逗号) 选择左侧plugins，然后在搜索框输入cml-language-support，然后安装。 "},"framework/deploy.html":{"url":"framework/deploy.html","title":"上线指南","keywords":"","body":"chameleon 上线指南 1 是否添加polyfill chameleon框架中js代码都是经过了babel编译，但是babel默认只转换语法，而不处理新的API，例如Object.assign,Object.entries。如果项目中使用了一些不经过babel的API，并且线上产品需要兼容低版本系统的手机，chameleon提供了在各端添加polyfill的配置 参见babelPolyfill。 2 静态资源发布路径 静态资源发布路径 是配合项目静态资源最终线上地址,设置方法参见资源发布路径。 例如： 项目中引用了一个本地图片： class Index { data = { chameleonSrc: require('../../assets/images/chameleon.png') } } 该图片执行cml web build 打包到本地 web/static/img/chameleon_83ee00e.png; 如果预计将该静态资源上线到https://static.cml.js/vender下，例如图片线上地址https://static.cml.js/vender/web/static/img/chameleon_83ee00e.png。 则应该将publicPath设置为https://static.cml.com/vender后执行cml web build。 cml.config.merge({ web: { build: { publicPath: \"https://static.cml.com/vender\" } } }); 这样代码中的图片地址线上就能够正确访问。 同理适用于 web端html页面中注入的link和script标签。 小程序中的静态资源上线 由于小程序有包大小的限制，所有建议打包出的静态资源单独上线，不放在小程序包中，chameleon-tool@0.3.0-alpha.1版本在dev模式也默认将图片的地址改成本地web服务器访问的地址，解决css中background-image不能使用本地图片的问题。 如果不将静态资源单独上线，注意要将publicPath设置为/，而且不能在百度小程序中这样使用。 3 api请求前缀 请求前缀的配置可以灵活的控制项目中所有ajax请求的服务器地址，上线时记得将其改成正确的线上地址。具体讲解参见 api请求前缀和domain 多域名请求前缀。 4 web端的路由模式 很多人将web端的html页面上线之后访问是空白页面。就是没有注意web端路由模式。web端路由模式分为history和hash，在项目的src/router.config.json中配置。如果web端的页面没有后端服务提供路由，那么应该路由设置成hash模式，然后用页面地址+hash值访问到相应的页面。history模式适用于有后端路由服务，访问设置的路由可以返回该html页面。 例如路由如下： { \"mode\": \"hash\", \"routes\":[ { \"url\": \"/cml/h5/index\", \"path\": \"/pages/index/index\", \"name\": \"首页\", \"mock\": \"index.php\" }, { \"url\": \"/cml/login/index\", \"path\": \"/pages/index/index\", \"name\": \"首页\", \"mock\": \"index.php\" } ] } 如果最终线上地址为https://static.cml.com/project/page1.html,则两个页面访问地址为 https://static.cml.com/project/page1.html#/cml/h5/index 和 https://static.cml.com/project/page1.html#/cml/login/index。 如果直接访问https://static.cml.com/project/page1.html 则会寻找路由为/的页面 https://static.cml.com/project/page1.html#/ 5 跨端chameleonUrl与config.json的关系 跨端项目之间的跳转，chameleon提供的解决方式是使用open方法传入统一的chameleonUrl地址，chameleonUrl地址的生成就是需要根据项目build模式打包出的config.json信息。 例如： [ { \"wx\": { \"appId\": \"wx_appid\", \"path\": \"/pages/index/index\" }, \"baidu\": { \"appId\": \"baidu_appid\", \"path\": \"/pages/index/index\" }, \"alipay\": { \"appId\": \"alipay_app_id\", \"path\": \"/pages/index/index\" }, \"web\": { \"url\": \"https://www.chameleon.com/index.html#/cml/h5/index\" }, \"weex\": { \"url\": \"https://static.cml.com/vender/weex/test2_dba27fda9a7f49fae912.js\", \"query\": { \"path\": \"/pages/index/index\" } } } ] config.json中包含了每一个页面在各端的访问路径信息，用户可以根据这些信息拼接成chameleonUrl，由后端下发给页面进行跳转。 weex信息构成： \"weex\": { \"url\": \"https://static.cml.com/vender/weex/test2_dba27fda9a7f49fae912.js\", \"query\": { \"path\": \"/pages/index/index\" } } url是根据publichPath决定 query中path信息是router.config.json中的path。 web信息构成： \"web\": { \"url\": \"https://www.chameleon.com/index.html#/cml/h5/index\" }, url是根据router.config.json中设置的domain拼接path构成。domain是这个页面的最终线上地址，和publichPath不一样，publicPath只是前缀。 注意: router.config.json中的domain指定页面最终线上地址，只是用于config.json的生成。 而配置文件中的publicPath是指定静态资源线上地址的前缀。 小程序信息的构成： \"wx\": { \"appId\": \"wx_appid\", \"path\": \"/pages/index/index\" }, \"baidu\": { \"appId\": \"baidu_appid\", \"path\": \"/pages/index/index\" }, \"alipay\": { \"appId\": \"alipay_app_id\", \"path\": \"/pages/index/index\" } 小程序的地址由appId和path构成，appId来自于chameleon.config.js中的buildInfo的设置。 cml.config.merge({ buildInfo: { wxAppId: 'wx_appid', baiduAppId: 'baidu_appid', alipayAppId: 'alipay_app_id' } }) 6 微信小程序分包加载 参见 https://github.com/didi/chameleon/issues/73 "},"example/components-link.html":{"url":"example/components-link.html","title":"组件实例","keywords":"","body":"Chameleon 组件实例 view text cell page scroller list button input textarea switch radio checkbox image video c-animation c-picker-panel c-picker-item c-toast c-dialog c-popup c-tip c-loading c-actionsheet c-picker c-checkbox-group c-radio-group c-tab row col container "},"example/view.html":{"url":"example/view.html","title":"view","keywords":"","body":"view 视图容器。 示例 flex-direction: row I II III flex-direction: column I II III class View { data = { } } export default new View(); .page-demo { background: #FAFAFA; position: absolute; top:0; bottom:0; left:0; right:0; } .page-box { margin-top: 80cpx; } .page-section-title { font-size: 32cpx; margin: 0 30cpx; } .page-section-content { margin: 80cpx; display: flex; font-size: 32cpx; text-align: center; justify-content: center; align-items: center; } .flex-item { width: 200cpx; height: 300cpx; line-height: 300cpx; justify-content: center; align-items: center; } .flex-item-V { width: 300cpx; height: 200cpx; line-height: 200cpx; justify-content: center; align-items: center; } .demo-1 { background-color: #81c0c0; } .demo-2 { background-color: #97cbff; } .demo-3 { background-color: #e0e0e0; } { \"base\": {} } "},"example/text.html":{"url":"example/text.html","title":"text","keywords":"","body":"text 文本容器。 示例 {{item}} add line remove line class Text { data = { allLine: [ \"chameleon的目标是Write once run everywhere\", \"chameleon主要特性: \", \"1、简洁强大的构建配置\", \"2、语法统一、快速上手\", \"3、方便的数据管理方案\", \"4、差异化方案\", \"......\" ], addLine: [] } computed = { addTextClass() { return this.allLine.length === this.addLine.length ? 'disable-text' : 'active-text'; }, removeTextClass() { return this.addLine.length === 0 ? 'disable-text': 'active-text'; } } methods = { add() { if(this.addLine.length >= this.allLine.length) { return; } this.addLine.push(this.allLine[this.addLine.length]) }, remove() { if(this.addLine.length .page-demo { background: #F8F8F8; flex: 1; } .text-area { margin: 100cpx 50cpx 100cpx; padding: 40cpx; min-height: 300cpx; background-color: #fff; font-size: 30cpx; color: #353535; text-align: center; } .line-text { font-size: 30cpx; text-align: center; } .btn { height: 100cpx; width: 600cpx; border-radius: 6cpx; display: flex; justify-content: center; align-items: center; margin: 30cpx 75cpx; border: 1px solid #999; } .active-text { color: #000; font-size: 40cpx; } .disable-text { color: #999; font-size: 40cpx; } { \"base\": {} } "},"example/page.html":{"url":"example/page.html","title":"page","keywords":"","body":"page 含titleBar基础页面容器。 内置了weex端titleBar以及多端修改页面标题方法。 示例 基础使用 这是页面内容 import cml from 'chameleon-api' class Page { methods = { goback() { cml.showToast({ message: 'goback' }) } } } export default new Page(); .main { color: red; } { \"base\": {} } 自定义titlebar 自定义标题 这是页面内容 import cml from 'chameleon-api' class Page { methods = { goback() { cml.showToast({ message: 'goback' }) } } } export default new Page(); .main { color: red; } { \"base\": {} } "},"example/cell.html":{"url":"example/cell.html","title":"cell","keywords":"","body":"cell 子列表项容器。 示例 {{item}} import cml from 'chameleon-api' const LOADMORE_COUNT = 4 class Cell { data = { /** * list 配置 子元素必须是 cell 标签 */ bottomOffset: 20, lists: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] } methods = { onBottom(e) { cml.showToast({ message: \"loadmore\", duration: 1000 }); setTimeout(() => { const length = this.lists.length for (let i = length; i .panel { display: flex; width: 600cpx; height: 300cpx; margin-left: 75cpx; margin-top: 35cpx; margin-bottom: 35cpx; flex-direction: column; justify-content: center; border-width: 2cpx; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); } .text { font-size: 88cpx; text-align: center; color: #41B883; } { \"base\": {} } "},"example/scroller.html":{"url":"example/scroller.html","title":"scroller","keywords":"","body":"scroller 可滚动视图区域。 可容纳排成一列的子组件的滚动器。 属性 属性名 类型 必填 默认值 说明 height Number scroll-direction为`vertical`时必传 0 定义纵向滚动区域的高度 width Number scroll-direction为`horizontal`时必传 0 定义横向滚动区域的宽度 scroll-direction String 否 vertical 定义滚动的方向。可选为 horizontal 或者 vertical bottom-offset Number 否 0 距底部/右边多远时（单位cpx），触发 onBottom 事件 c-bind:scrolltobottom EventHandle 否 滚动到底部，会触发 scrolltobottom 事件 返回事件对象： event.type= \"scrolltobottom\" event.detail = { direction } c-bind:onscroll EventHandle 否 滚动时触发， 返回事件对象： event.type = 'scroll' event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 限制 不允许相同方向的 或者 互相嵌套，换句话说就是嵌套的 / 必须是不同的方向。 举个例子，不允许一个垂直方向的 嵌套的一个垂直方向的 中，但是一个垂直方向的 是可以嵌套的一个水平方向的 或者 中的。 示例 {{item.label}} import cml from \"chameleon-api\" class Scroller { data = { /** * scroller 配置 */ bottomOffset: 20, scrollDirection: 'vertical', panels: [ ], rows: [], winHeight: 0 } methods = { change (e) { let target = e.currentTarget let dataset = target.dataset let i = dataset.idx const item = this.panels[i] if (item) { item.height = item.height === 200 ? 400 : 200 item.width = item.width === 330 ? 730 : 330 item.computedStyle = this.$cmlStyle(`height:${item.height}cpx;width:${item.width}cpx;background-color:${item.bgc};opacity:${item.opacity}`) } }, randomfn () { let ary = []; for(let i = 1; i{ this.winHeight = Number(info.viewportHeight) }) } } export default new Scroller(); .container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .title { text-align: center; flex-direction: row; justify-content: center; } .panel { display: flex; margin: 10cpx; top:10cpx; align-items: center; justify-content: center; text-align: center; border: 1px solid #666; border-radius: 10cpx; transition-property: width,height; transition-duration: 0.5s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); } .cell{ display: flex; background-color:white; flex-direction: row; } .text { font-size: 60cpx; color: white; } { \"base\": {} } wx web native 推荐使用 视窗为设备屏幕，示例如下 ... Bug & Tip 使用竖向滚动时，需要有一个固定高度。 如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 可以当作根元素或者嵌套元素使用。 中不可以使用 、 组件。 "},"example/list.html":{"url":"example/list.html","title":"list","keywords":"","body":"list 可滚动长列表。 标签内可包含多条 ，适合用于长列表的展示。 使用文档 cell。 属性 属性名 类型 必填 默认值 说明 height Number 必传 0 定义滚动区域的高度 bottom-offset Number 否 0 距底部/右边多远时（单位cpx），触发 onBottom 事件 c-bind:scrolltobottom EventHandle 否 滚动到底部，会触发 scrolltobottom 事件 返回事件对象： event.type= \"scrolltobottom\" event.detail = { direction } c-bind:onscroll EventHandle 否 滚动时触发， 返回事件对象： event.type = 'scroll' event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 限制 不允许相同方向的 或者 互相嵌套，换句话说就是嵌套的 / 必须是不同的方向。 举个例子，不允许一个垂直方向的 嵌套的一个垂直方向的 中，但是一个垂直方向的 是可以嵌套的一个水平方向的 list 或者 中的。 示例 {{item}} import cml from 'chameleon-api' const LOADMORE_COUNT = 4 class List { data = { /** * list 配置 子元素必须是 cell 标签 */ bottomOffset: 20, lists: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], winHeight: 0 } mounted(res) { cml.getSystemInfo().then((info)=>{ this.winHeight = Number(info.viewportHeight) }) } methods = { onBottom(e) { cml.showToast({ message: \"loadmore\", duration: 1000 }); setTimeout(() => { const length = this.lists.length for (let i = length; i .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .panel { display: flex; width: 600cpx; height: 300cpx; margin-left: 75cpx; margin-top: 35cpx; margin-bottom: 35cpx; flex-direction: column; justify-content: center; border-width: 2cpx; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); } .text { font-size: 88cpx; text-align: center; color: #41B883; } { \"base\": {} } wx web native 推荐使用 视窗为填满设备屏幕，示例如下 为根节点时无需设置高度，但是内嵌 高度必须可计算，你可以使用 flex 或 postion 将 设为一个响应式高度（例如全屏显示）, 也可以显式设置 组件的 height 样式。 ... Bug & Tip 组件的父容器必须为可定位元素， 内容的布局由父容器决定。 中不可以使用 、 组件。 "},"example/container.html":{"url":"example/container.html","title":"container","keywords":"","body":"container 示例 以下是demo header main header main footer aside main header aside main header aside main foot aside header main aside header main footer class CLayout { data = { headerTitle: 'layout布局', headerDesc: 'layout布局', asideStyle: 'height:300cpx;', headStyle: '', mainStyle: 'height:300cpx', footStyle: '' } } export default new CLayout(); .container-wrap{ padding-bottom:30cpx; padding-left:15cpx; padding-right:15cpx; } .container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .container-item{ flex:1; display:flex; flex-direction:row; justify-content:center; align-items:center; font-size: 28cpx; color: #333; } .title{ display:flex; flex-direction:row; justify-content:center; line-height: 88cpx; font-size: 28cpx; text-align: center; height: 88cpx; color: #999; } { \"base\": {} } wx web native "},"example/row.html":{"url":"example/row.html","title":"row","keywords":"","body":"row flex布局行容器 示例 class Row { data = { } } export default new Row(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .col-item { background: #ccc; width:200cpx; height:100cpx; margin:0 10cpx; } .col-item-2 { background: #aaa; width:200cpx; height:100cpx; } { \"base\": {} } "},"example/col.html":{"url":"example/col.html","title":"col","keywords":"","body":"col flex布局列容器 示例 class Row { data = { } } export default new Row(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .col-item { background: #ccc; width:200cpx; height:100cpx; margin:0 10cpx; } .col-item-2 { background: #aaa; width:200cpx; height:100cpx; } { \"base\": {} } "},"example/button.html":{"url":"example/button.html","title":"button","keywords":"","body":"button 按钮 示例 类型样式 default/blue disabled orange red && disabled green 尺寸 big medium small 微信开放能力 进入客服会话 触发用户转发 获取用户信息 获取用户手机号 打开APP 打开授权设置页 打开“意见反馈页面” import cml from 'chameleon-api' class Button { data = { sessionFrom: '会话来源', messageTitle: '标题', messagePath: '路径', messageImg: '图片', contactPath: '', contactQuery: {}, errMsg: '', iv: '', encryptedData: '', appErrMsg: '' } methods = { testclick(e) { let type = e.detail.type cml.showToast({ message: type + ' button' }) }, bindcontact(e) { this.contactPath = e.path; this.contactQuery = e.query; }, bindgetuserinfo(e) { console.log(e.detail); }, bindgetphonenumber(e) { this.errMsg = e.detail.errMsg; this.iv = e.detail.iv; this.encryptedData = e.detail.encryptedData; }, binderror(e) { this.appErrMsg = e.detail.errMsg; }, bindopensetting(e) { console.log(e); } } } export default new Button(); .container { position: absolute; top:0; left: 0; right: 0; bottom: 0; padding-bottom: 60cpx; font-size: 32cpx; font-family: -apple-system-font,Helvetica Neue,Helvetica,sans-serif; } .button-list { display: flex; flex-direction: column; align-items: center; } .section-title { margin-top: 60cpx; display: flex; flex-direction: row; justify-content: center; } .section-title-text { color: #fc9153; font-size: 40cpx; } .button-text { display: block; color: #999; margin-top: 40cpx; margin-left: 8cpx; margin-bottom: 16cpx; } { \"base\": {} } "},"example/input.html":{"url":"example/input.html","title":"input","keywords":"","body":"input 输入框 示例 focus聚焦 web端不支持 数据绑定,value:{{inputValue}} 监听input事件,当前事件：{{eventName}} 最大长度是5 text类型的input number类型的input password类型的input 禁用input 键盘右下键按钮done web端不支持 键盘右下键按钮search web端不支持 键盘右下键按钮next web端不支持 键盘右下键按钮go web端不支持 placeholderColor web端不支持 自定义样式 class Input { data = { isfocus: false, inputValue: '', eventName: '触发的事件名称', winHeight: 0 } computed = {} watch = {} methods = { inputEvent(e) { this.inputValue = e.detail.value; }, testEvent(e) { this.eventName = e.type }, bindblurevent() { console.log('blur') this.isfocus = false; } } mounted(res) { console.log('mounted') setTimeout(() => { this.isfocus = true; }, 300); } }; export default new Input(); .page-demo { background: #FAFAFA; position: absolute; top:0; bottom:0; left:0; right:0; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .end-item { margin-bottom: 40cpx; position: relative; border-top: 1px solid #D9D9D9; border-bottom: 1px solid #D9D9D9; } .input-wrap { position: relative; border-top: 1px solid #D9D9D9; border-bottom: 1px solid #D9D9D9; } { \"base\": {} } "},"example/textarea.html":{"url":"example/textarea.html","title":"textarea","keywords":"","body":"textarea 多行输入框 示例 focus聚焦 数据绑定,value:{{inputValue}} 监听input事件,当前事件：{{eventName}} placeholderColor web端不支持 自定义样式 class Texrarea { data = { isfocus: false, inputValue: '', eventName: '触发的事件名称' } computed = {} watch = {} methods = { inputEvent(e) { this.inputValue = e.detail.value; }, testEvent(e) { this.eventName = e.type }, bindblurevent() { console.log('blur') this.isfocus = false; } } mounted(res) { setTimeout(() => { this.isfocus = true; }, 300); } }; export default new Texrarea(); .page-demo { background: #FAFAFA; position: absolute; top:0; bottom:0; left:0; right:0; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .end-item { margin-bottom: 40cpx; position: relative; border-top: 1px solid #D9D9D9; border-bottom: 1px solid #D9D9D9; } .input-wrap { position: relative; border-top: 1px solid #D9D9D9; border-bottom: 1px solid #D9D9D9; } { \"base\": {} } "},"example/switch.html":{"url":"example/switch.html","title":"switch","keywords":"","body":"switch 开关 示例 switch value: {{ switchValue1 ? 'true': 'false' }} switch value: {{ switchValue2 ? 'true': 'false'}} switch value: {{ switchValue3 ? 'true': 'false' }} switch value: {{ switchValue4 ? 'true': 'false' }} class Switch { data = { switchValue1: false, switchValue2: true, switchValue3: true, switchValue4: false } methods = { switchChange1 (e) { this.switchValue1 = e.detail.value }, switchChange2 (e) { this.switchValue2 = e.detail.value } } } export default new Switch(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 10cpx 30cpx; background: #eee } .radio-value { font-size: 32cpx; } .box { margin: 0cpx 50cpx; } { \"base\": {} } "},"example/radio.html":{"url":"example/radio.html","title":"radio","keywords":"","body":"radio 单选框 示例 value: {{ radioValue1 ? 'true' : 'false' }} value: {{ radioValue2 ? 'true' : 'false' }} value: {{ radioValue3 ? 'true' : 'false' }} value: {{ radioValue4 ? 'true' : 'false' }} class Radio { data = { radioValue1:false, radioValue2:true, radioValue3:true, radioValue4:false } methods = { valueChange1 (e) { this.radioValue1 = e.detail.value; }, valueChange2 (e) { this.radioValue2 = e.detail.value; } } } export default new Radio(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 10cpx 30cpx; background: #eee } .radio-value { font-size: 32cpx; } .box { margin: 0cpx 50cpx; } { \"base\": {} } "},"example/checkbox.html":{"url":"example/checkbox.html","title":"checkbox","keywords":"","body":"checkbox 复选框 示例 Checkbox value: {{ checkboxValue1 ? 'true' : 'false' }} value: {{ checkboxValue2 ? 'true' : 'false' }} value: {{ checkboxValue3 ? 'true' : 'false' }} class Checkbox { data = { checkboxValue1: true, checkboxValue2: true, checkboxValue3: true } methods = { valueChange1 (e) { this.checkboxValue1 = e.detail.value }, valueChange2 (e) { this.checkboxValue2 = e.detail.value } } } export default new Checkbox(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 8cpx 30cpx; background: #eee } .checkbox-value { font-size: 32cpx; } .box { margin: 10cpx 50cpx; } { \"base\": {} } "},"example/image.html":{"url":"example/image.html","title":"image","keywords":"","body":"image 图片 示例 class Image { data = { imageSrc: require('../../assets/images/chameleon.png') } methods = { imageLoad(e) { console.log(e); }, imageError(e) {} } } export default new Image() .container { display: flex; flex-direction: column; align-items: center; } { \"base\": {} } "},"example/video.html":{"url":"example/video.html","title":"video","keywords":"","body":"video 视频播放器 示例 视频state: {{state}} import cml from 'chameleon-api' class Video { data = { videoSrc: 'http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400', state: '----', } methods = { onstart (event) { this.state = 'onstart' cml.showToast({ message: this.state }) }, onpause (event) { this.state = 'onpause' cml.showToast({ message: this.state }) }, onfinish (event) { this.state = 'onfinish' cml.showToast({ message: this.state }) }, onfail (event) { this.state = 'onfail' cml.showToast({ message: this.state }) } } } export default new Video(); .container { display: flex; flex-direction: column; align-items: center; } .text-wrap { flex-direction: row; margin-bottom: 20cpx; } .info { font-size: 40cpx; text-align: center; color: #fc9153; } { \"base\": {} } "},"example/animation.html":{"url":"example/animation.html","title":"animation","keywords":"","body":"c-animation 动画组件 示例 Transform Others Anim import cml from 'chameleon-api'; const animation = cml.createAnimation(); class CAnimation { data = { animationData: {}, current_rotate: 0, current_scale: 1, current_translate: 50, current_transform: [45, 1], current_color: '#F0AD4E', current_opacity: 1, current_width: 250, current_height: 250, } methods = { rotate () { let animationCreation = animation; while (this.current_rotate !== 360) { this.current_rotate += 90; animationCreation = animationCreation .rotate(this.current_rotate) .step({ duration: 500, timingFunction: 'ease-in-out', delay: 0, }) } this.animationData = animationCreation.export(); this.current_rotate = 0 }, scale () { this.current_scale = this.current_scale === 2 ? 1 : 2 this.animationData = animation .scale(this.current_scale) .step({ duration: 500, timingFunction: 'linear', delay: 0 }) .export() }, translate () { this.current_translate = this.current_translate === 50? -50 : 50; this.animationData = animation .translate(this.current_translate, this.current_translate) .step({ duration: 500, timingFunction: 'ease-in', delay: 0, }) .export() }, transform () { this.current_transform = this.current_transform[0] === 0 ? [45, 1.2]:[0, 1]; this.animationData = animation .rotate(this.current_transform[0]) .scale(this.current_transform[1]) .step({ duration: 500, timingFunction: 'ease-out', delay: 0 }) .rotate(\"-90deg\") .scale(1.2) .step({ duration: 500, timingFunction: 'ease-out', delay: 0 }) .export() }, backgroundColor () { this.current_color = this.current_color === '#F0AD4E' ? '#D9534F' : '#F0AD4E'; this.animationData = animation .backgroundColor(this.current_color) .step({ duration: 500, timingFunction: 'linear', delay: 0 }) .export() }, opacity () { this.current_opacity = this.current_opacity === 1 ? 0.1 : 1; this.animationData = animation .opacity(this.current_opacity) .step({ duration: 500, timingFunction: 'linear', delay: 0 }) .export() }, width () { this.current_width = this.current_width === 250 ? 125 : 250; this.animationData = animation .width(this.current_width) .step({ timingFunction: 'linear', delay: 0, duration: 500, }) .export() }, height () { this.current_height = this.current_height === 250 ? 125 : 250; this.animationData = animation .height(this.current_height) .step({ duration: 500, timingFunction: 'linear', delay: 0 }) .export() }, composite () { this.current_transform = this.current_transform[0] === 0 ? [45, 1.5]:[0, 1]; this.current_color = this.current_color === '#F0AD4E' ? '#D9534F' : '#F0AD4E'; this.current_opacity = this.current_opacity === 1 ? 0.1 : 1; this.current_translate = this.current_translate === 50? -50 : 50; this.current_width = this.current_width === 250 ? 125 : 250; this.current_height = this.current_height === 250 ? 125 : 250; this.animationData = animation .width(this.current_width) .height(this.current_height) .rotate(this.current_transform[0]) .scale(this.current_transform[1]) .opacity(this.current_opacity) .backgroundColor(this.current_color) .translate(this.current_translate, this.current_translate) .step({ duration: 1000, timingFunction: 'ease-out', delay: 0 }) .export() } } } export default new CAnimation(); .title { font-size: 45cpx; font-weight: 400; margin: 20cpx 0; padding: 8cpx 30cpx; background: #4a4c5b; color:#FFFFFF; display: block; } .animation-entity { position: fixed; width: 250cpx; height: 250cpx; top: 500cpx; left: 400cpx; background-color: #F0AD4E; display:flex; justify-content:center; align-items:center; } .animation-text { color:#FFFFFF; font-size:70cpx; } .btn-wraper { margin: 6cpx 10cpx; display: flex; align-items: start; justify-content: flex-start; flex-direction: column; } .page-container { font-size: 32cpx; color: #000; padding: 20cpx 25cpx; background: #fafafa; } { \"base\": { \"usingComponents\": {} } } "},"example/c-toast.html":{"url":"example/c-toast.html","title":"c-toast","keywords":"","body":"c-toast 提示框 示例 class Index { data = { show: false, message: '', type: 'loading', mask: false, duration: 3000, btnStyle: 'margin-bottom: 20cpx' } methods = { changeShow(e) { this.show = e.detail.value }, showLoading() { this.message=\"loading toast\" this.type=\"loading\" this.mask = false; this.duration = 1000*3; this.show = true; }, showMask() { this.message=\"mask toast\" this.type=\"loading\" this.mask = true; this.duration = 1000*3; this.show = true; }, showSuccess() { this.message=\"success toast\" this.type=\"success\" this.mask = true; this.duration = 1000*3; this.show = true; }, showWarn() { this.message=\"warn toast\" this.type=\"warn\" this.mask = true; this.duration = 1000*3; this.show = true; } } } export default new Index(); .toast-page { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { \"c-toast\": \"cml-ui/components/c-toast/c-toast\" } } } "},"example/c-dialog.html":{"url":"example/c-dialog.html","title":"c-dialog","keywords":"","body":"c-dialog 对话框 示例 class C_dialog { data = { show: false, mask: true, showClose: false, headerTitle: \"c-dialog\", headerDesc: \"c-dialog\", message: \"\", type: \"alert\", btnStyle: \"margin-bottom: 20cpx\", iconType: \"warn\", iconStyle: { width: \"60cpx\", height: \"60cpx\" }, title: \"我是标题\", content: \"我是内容\" } methods = { changeShow(e) { this.show = e.detail.value; }, showAlert() { this.type = \"alert\"; this.title = \"我是标题\"; this.content = \"我是内容\"; this.iconType = \"warn\"; this.showClose = false; this.show = true; }, showConfirm() { this.type = \"confirm\"; this.title = \"确定离开吗\"; this.content = \"\"; this.iconType = \"network\"; this.showClose = false; this.show = true; }, showCloseIcon() { this.type = \"alert\"; this.title = \"我是标题\"; this.content = \"我是内容\"; this.iconType = \"warn\"; this.showClose = true; this.show = true; }, closeEvent() {}, confirmEvent() {}, cancelEvent() {} } }; export default new C_dialog(); .dialog-page { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\" } } } "},"example/c-popup.html":{"url":"example/c-popup.html","title":"c-popup","keywords":"","body":"c-popup 蒙层 示例 class C_popup { data = { show: false, headerTitle: \"c-popup\", headerDesc: \"c-popup\", mask: true, btnStyle: \"margin-bottom: 20cpx\" } methods = { showPopup() { this.show = true; }, close() { this.show = false; } } }; export default new C_popup(); { \"base\":{ \"usingComponents\": { \"c-popup\": \"cml-ui/components/c-popup/c-popup\" } } } "},"example/c-tip.html":{"url":"example/c-tip.html","title":"c-tip","keywords":"","body":"c-tip 提示 示例 Tip Show tip Awesome! chameleon-ui class CTip { data = { showtip1: false, showtip2: false, direction: \"top\" } computed = { tipStyle() { let style; switch (this.direction) { case \"top\": style = \"position:absolute;top:0;left: 260cpx;\"; break; case \"bottom\": style = \"position:absolute;top:164cpx;left: 260cpx;\"; break; case \"left\": style = \"position:absolute;left:20cpx;top:93cpx;\"; break; case \"right\": style = \"position:absolute;left:480cpx;top:93cpx;\"; break; } return this.$cmlStyle(style); } } methods = { closeTip1(){ this.showtip1=false; }, showTip1(){ this.showtip1=true; }, closeTip2(){ this.showtip2 = false; }, showTip2(){ this.direction=\"top\"; this.showtip2 = true; }, showTip2Top(){ this.direction=\"top\"; this.showtip2 = true; }, showTip2Bottom(){ this.direction=\"bottom\"; this.showtip2= true; }, showTip2Left(){ this.direction=\"left\"; this.showtip2=true; }, showTip2Right(){ this.direction=\"right\"; this.showtip2=true; } } } export default new CTip(); .container { display: flex; flex-direction: column; } .tip-eg { width: 750cpx; align-self: center; padding: 100cpx 0; position: relative; display: flex; flex-direction: column; } .tip-btn { padding: 9cpx 10cpx; border: 1px solid #fc9153; border-radius: 4cpx; font-size: 24cpx; color: #fc9153; align-self: center; } .btn { margin-top: 20cpx; align-self: center; } { \"base\": { \"usingComponents\": { \"c-tip\": \"cml-ui/components/c-tip/c-tip\" } } } "},"example/c-loading.html":{"url":"example/c-loading.html","title":"c-loading","keywords":"","body":"c-loading 加载中 示例 class CLoading { data = { loading: true, } methods = { changeLoading() { this.loading = !this.loading; }, } } export default new CLoading(); .content { width: 750cpx; height: 300cpx; background-color: peru; } .button-wrapper { flex: 1; justify-content: center; align-items: center; margin-top: 50cpx; } { \"base\": { \"usingComponents\": { \"c-loading\": \"cml-ui/components/c-loading/c-loading\" } } } "},"example/c-actionsheet.html":{"url":"example/c-actionsheet.html","title":"c-actionsheet","keywords":"","body":"c-actionsheet 操作列表 示例 import cml from 'chameleon-api'; class CActionsheet { data = { actionShow: false, mask: true, list: [\"高铁\", \"火车\", \"飞机\", \"打车\", \"地铁\"], active: -1, title: \"出行方式\", pickerStyle: false } methods = { showActionSheet() { this.pickerStyle = false; this.actionShow = true; }, showActionSheetActive() { this.pickerStyle = false; this.actionShow = true; }, showActionSheetPicker() { this.pickerStyle = true; this.actionShow = true; }, cancel() { this.actionShow = false; cml.showToast({ message: \"Clicked 取消\" }); }, select(e) { this.actionShow = false; this.active = +e.detail.index; cml.showToast({ message: \"Clicked\" + \" \" + e.detail.value }); } } } export default new CActionsheet(); .btn { margin-top: 20cpx; align-self: center; } { \"base\": { \"usingComponents\": { \"c-actionsheet\": \"cml-ui/components/c-actionsheet/c-actionsheet\" } } } "},"example/c-picker.html":{"url":"example/c-picker.html","title":"c-picker","keywords":"","body":"c-picker 底部弹起的滚动选择器 示例 点击选择：{{column[columnIndex]}} class Index { data = { column: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, columnIndex: 0, pickerShow: false } methods = { selectchange(e) { this.columnIndex = this.defaultIndex = e.detail.index; }, showClick() { this.pickerShow = true; }, cancel() { this.pickerShow = false; }, confirm() { this.pickerShow = false; } } }; export default new Index(); .select-text { display: flex; justify-content: center; align-items: center; font-size: 32cpx; text-align: center; } { \"base\": { \"usingComponents\": { \"c-picker\": \"cml-ui/components/c-picker/c-picker\" } } } "},"example/c-picker-panel.html":{"url":"example/c-picker-panel.html","title":"c-picker-panel","keywords":"","body":"c-picker-panel 从底部弹起的控制板。 示例 点击选择：{{provins[provinsIndex]}} class Index { data = { headerTitle: \"c-picker-item\", headerDesc: \"c-picker-item组件\", provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0, panelShow: false } methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; }, showClick() { this.panelShow = true; }, cancel() { this.panelShow = false; }, confirm() { this.panelShow = false; } } }; export default new Index(); .select-text { font-size: 32cpx; text-align: center; } { \"base\": { \"usingComponents\": { \"c-picker-panel\": \"cml-ui/components/c-picker-panel/c-picker-panel\", \"c-picker-item\": \"cml-ui/components/c-picker-item/c-picker-item\" } } } "},"example/c-picker-item.html":{"url":"example/c-picker-item.html","title":"c-picker-item","keywords":"","body":"c-picker-item 滚动选择器 示例 选择的值：{{provins[provinsIndex]}} class Index { data = { provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0 } methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; } } }; export default new Index(); .select-text { font-size: 32cpx; text-align: center; } { \"base\": { \"usingComponents\": { \"c-picker-item\": \"cml-ui/components/c-picker-item/c-picker-item\" } } } "},"example/c-checkbox-group.html":{"url":"example/c-checkbox-group.html","title":"c-checkbox-group","keywords":"","body":"c-checkbox-group 复选框列表 示例 selected value: {{ selected1 }} selected value: {{ selected2 }} selected value: {{ selected3 }} class CCheckbox { data = { checkboxGroupOption1: [{ checked: true, label: 'one', disabled: true }, { checked: false, label: 'two' }, { checked: false, label: 'three' }], selected1: 'one', checkboxGroupOption2: [{ checked: true, label: 'one', disabled: true }, { checked: false, label: 'two' }, { checked: false, label: 'three' }], selected2: 'one', checkboxGroupOption3: [{ checked: true, label: 'one', disabled: true }, { checked: false, label: 'two' }, { checked: false, label: 'three' }], selected3: 'one' } methods = { valueChange1 (e) { this.checkboxValue1 = e.detail.value }, groupChangeHandler1 (e) { this.checkboxGroupOption1 = e.detail.value this.selected1 = e.detail.selected.join(', ') }, groupChangeHandler2 (e) { this.checkboxGroupOption2 = e.detail.value this.selected2 = e.detail.selected.join(', ') }, groupChangeHandler3 (e) { this.checkboxGroupOption3 = e.detail.value this.selected3 = e.detail.selected.join(', ') }, valueChange2 (e) { this.checkboxValue2 = e.detail.value } } } export default new CCheckbox(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 8cpx 30cpx; background: #eee } .checkbox-value { font-size: 32cpx; } .box { margin: 10cpx 50cpx; } { \"base\": { \"usingComponents\": { \"c-checkbox-group\": \"cml-ui/components/c-checkbox-group/c-checkbox-group\" } } } "},"example/c-radio-group.html":{"url":"example/c-radio-group.html","title":"c-radio-group","keywords":"","body":"c-radio-group 单选框列表 示例 selected value: {{ radioSelect1 ? 'true' : 'false'}} selected value: {{ radioSelect2 ? 'true' : 'false' }} selected value: {{ radioSelect3 ? 'true' : 'false' }} class CRadio { data = { radioGroupOption1: [{ checked: false, label: 'Option1', }, { checked: false, label: 'Option2' }, { checked: false, label: 'Option3', disabled: true }], radioSelect1: '', radioGroupOption2: [{ checked: true, label: 'Option1', }, { checked: false, label: 'Option2' }, { checked: false, label: 'Option3', disabled: true }], radioSelect2: 'Option1', radioGroupOption3: [{ checked: true, label: 'Option1', }, { checked: false, label: 'Option2' }, { checked: false, label: 'Option3', disabled: true }], radioSelect3: 'Option1', } computed = { } watch = { } methods = { groupChangeHandler1 (e) { this.radioSelect1 = this.radioGroupOption1[e.detail.index].label }, groupChangeHandler2 (e) { this.radioSelect2 = this.radioGroupOption2[e.detail.index].label }, groupChangeHandler3 (e) { this.radioSelect3 = this.radioGroupOption3[e.detail.index].label }, } beforeCreate() { } created() { } beforeMount() { } mounted() { } beforeDestroy() { } destroyed() { } } export default new CRadio(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 10cpx 30cpx; background: #eee } .radio-value { font-size: 32cpx; } .box { margin: 0 50cpx; } { \"base\": { \"usingComponents\": { \"c-radio-group\": \"cml-ui/components/c-radio-group/c-radio-group\" } } } "},"example/c-tab.html":{"url":"example/c-tab.html","title":"c-tab","keywords":"","body":"c-tab 示例 单tab案例 tab+pane案例 {{item.label}} --> 1 2 3 4 /*** * prefixStyle suffixStyle 可以用来放置图标 */ class CTab { data = { headerTitle: 'c-tabs', headerDesc: 'c-tabs', tabsAlone:[{ label:'label11', // prefixStyle:\"width:50cpx;height:20cpx;background-color:red;\", },{ label:\"label22\", // suffixStyle:\"width:50cpx;height:20cpx;background-color:red;\" },{ label:'label33', }], activeLabelAlone:'label33', tabs:[{ label:'label1', // prefixStyle:\"width:50cpx;height:20cpx;background-color:red\" },{ label:\"label2\", // suffixStyle:\"width:50cpx;height:20cpx;background-color:red\" },{ label:'label3', // labelStyle:\"color:green\" }], activeLabel:'label3', } methods = { handleTabTap(e){ console.log(e); this.activeLabel = e.detail.label; }, handleTabTapAlone(e){ this.activeLabelAlone = e.detail.label; } } } export default new CTab(); { \"base\":{ \"usingComponents\": { \"c-tab\": \"cml-ui/components/c-tab/c-tab\", \"c-tab-pane\": \"cml-ui/components/c-tab-pane/c-tab-pane\", \"c-tab-pane-item\": \"cml-ui/components/c-tab-pane-item/c-tab-pane-item\" } } } .container { flex: 1; background: #f8f8f8; } .title{ display:flex; flex-direction:row; justify-content:center; line-height: 88cpx; font-size: 28cpx; text-align: center; height: 88cpx; color: #999; } .one{ color:#fff; height:500cpx; background-color:rgb(46, 240, 127); } .two{ color:#fff; height:500cpx; background-color:rgb(0, 162, 255); } .three{ color:#fff; height:500cpx; background-color:#00ffe4; } wx web native "},"framework/faq.html":{"url":"framework/faq.html","title":"FAQ","keywords":"","body":"FAQ 怎么理解框架的实现原理？ 实现原理图 我想使用chameleon，是否需要大刀阔斧的重构项目？ 不需要，可以使用chameleon开发公用组件，导出到各端原有项目中使用。 用CML标准编写代码，是否增加调试成本？ 我们实现了全面的语法检查功能，且在持续加强。理论上框架是降低调试成本，就像从原生js开发到vuejs、reactjs是否认为也增加了调试成本，见仁见智。 各端包括小程序的接口更新频繁，如何保证框架编译的抽象度和稳定性？ 1、自建输入语法标准 cml，编译输出结果自定的格式语法。 2、框架的runtime层实现匹配接收的编译输出代码，runtime跟随小程序更新。 3、框架整体方向一致：mvvm底层设计模式为标准设计接口。 基于以上三条，你可以理解为：我们设计了一个框架统一标准协议，再在各个端runtime分别实现这个框架，宏观的角度就像nodejs同时运行在window和macOS系统，就像flutter运行在Android和iOS一个道理。各端小程序接口更新除非遇到不向下兼容情况，否则不影响框架，如果真遇到不向下兼容更新，这种情况下是否用框架都需要改。 框架有多大，性能是否有影响？ 1、小程序的主要运行性能瓶颈是webview和js虚拟机的传输性能，我们在这里会做优化，尽可能diff出修改的部分进行传输，性能会更好。 2、包大小，小程序有包大小限制，web端包大小也是工程师关心的点。首先基于多态协议，产出包纯净保留单端代码；其次框架的api和组件会按需打包。包大小是我们重点发力点，会持续优化到极致。目前build模式包大小测试结果如下: minimize | minimize + gzip 平台js总体积外部框架chameleon运行时代码其他代码 web 141.87kb | 43.72kb vue+vuex+vue-router 99.26kb | 33.89kb 35.96kb | 8.85kb 业务代码 weex 135kb | 32.43kb vuex+vue-router 33.49kb | 17.96kb 25.23kb | 5.94kb 业务代码 wx 101.66kb | 28.12kb mobx算在chameleon运行时中 98.75kb | 26.53kb 业务代码 baidu 101.72kb | 28.13kb mobx算在chameleon运行时中 98.78kb | 26.61kb 业务代码 alipay 102kb | 28.12kb mobx算在chameleon运行时中 99.15kb | 26.34kb 业务代码 我只想跨web和各类小程序，是否可以不使用 Flexbox 布局模型？ 可以，如果你的项目不在 快应用、react-native、weex等平台运行，可以更便捷开发项目，特别是CSS的限制更少： 只跨web和小程序的应用 一套代码运行多端，如何保证各个端充分的定制化空间？ 基于多态协议，充分保证各端发挥，且保证最终一致性。 各端包括小程序的接口更新后，是否一定依赖框架更新？ 同上一个问题，基于多态协议，可自己直接调用新的底层接口。 "},"update_record.html":{"url":"update_record.html","title":"更新记录","keywords":"","body":"更新记录 https://github.com/didi/chameleon/blob/master/CHANGELOG.md "}}